
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model administrador
 * 
 */
export type administrador = $Result.DefaultSelection<Prisma.$administradorPayload>
/**
 * Model categoria
 * 
 */
export type categoria = $Result.DefaultSelection<Prisma.$categoriaPayload>
/**
 * Model cliente
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type cliente = $Result.DefaultSelection<Prisma.$clientePayload>
/**
 * Model comision
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type comision = $Result.DefaultSelection<Prisma.$comisionPayload>
/**
 * Model detalle_diagnostico
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type detalle_diagnostico = $Result.DefaultSelection<Prisma.$detalle_diagnosticoPayload>
/**
 * Model detalle_proforma
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type detalle_proforma = $Result.DefaultSelection<Prisma.$detalle_proformaPayload>
/**
 * Model diagnostico
 * 
 */
export type diagnostico = $Result.DefaultSelection<Prisma.$diagnosticoPayload>
/**
 * Model empleado
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type empleado = $Result.DefaultSelection<Prisma.$empleadoPayload>
/**
 * Model factura
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type factura = $Result.DefaultSelection<Prisma.$facturaPayload>
/**
 * Model herramienta
 * 
 */
export type herramienta = $Result.DefaultSelection<Prisma.$herramientaPayload>
/**
 * Model horario
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type horario = $Result.DefaultSelection<Prisma.$horarioPayload>
/**
 * Model horario_empleado
 * 
 */
export type horario_empleado = $Result.DefaultSelection<Prisma.$horario_empleadoPayload>
/**
 * Model marca_herramienta
 * 
 */
export type marca_herramienta = $Result.DefaultSelection<Prisma.$marca_herramientaPayload>
/**
 * Model marca_moto
 * 
 */
export type marca_moto = $Result.DefaultSelection<Prisma.$marca_motoPayload>
/**
 * Model moto
 * 
 */
export type moto = $Result.DefaultSelection<Prisma.$motoPayload>
/**
 * Model movimiento_herramienta
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type movimiento_herramienta = $Result.DefaultSelection<Prisma.$movimiento_herramientaPayload>
/**
 * Model orden_trabajo
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type orden_trabajo = $Result.DefaultSelection<Prisma.$orden_trabajoPayload>
/**
 * Model proforma
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type proforma = $Result.DefaultSelection<Prisma.$proformaPayload>
/**
 * Model proforma_repuesto
 * 
 */
export type proforma_repuesto = $Result.DefaultSelection<Prisma.$proforma_repuestoPayload>
/**
 * Model servicio
 * 
 */
export type servicio = $Result.DefaultSelection<Prisma.$servicioPayload>
/**
 * Model usuario
 * 
 */
export type usuario = $Result.DefaultSelection<Prisma.$usuarioPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const estado_orden: {
  ABIERTA: 'ABIERTA',
  EN_PROCESO: 'EN_PROCESO',
  CERRADA: 'CERRADA',
  ANULADA: 'ANULADA'
};

export type estado_orden = (typeof estado_orden)[keyof typeof estado_orden]


export const estado_pago: {
  PENDIENTE: 'PENDIENTE',
  PAGADA: 'PAGADA',
  RECHAZADA: 'RECHAZADA'
};

export type estado_pago = (typeof estado_pago)[keyof typeof estado_pago]


export const estado_proforma: {
  PENDIENTE: 'PENDIENTE',
  APROBADA: 'APROBADA',
  ANULADA: 'ANULADA'
};

export type estado_proforma = (typeof estado_proforma)[keyof typeof estado_proforma]

}

export type estado_orden = $Enums.estado_orden

export const estado_orden: typeof $Enums.estado_orden

export type estado_pago = $Enums.estado_pago

export const estado_pago: typeof $Enums.estado_pago

export type estado_proforma = $Enums.estado_proforma

export const estado_proforma: typeof $Enums.estado_proforma

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Administradors
 * const administradors = await prisma.administrador.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Administradors
   * const administradors = await prisma.administrador.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.administrador`: Exposes CRUD operations for the **administrador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Administradors
    * const administradors = await prisma.administrador.findMany()
    * ```
    */
  get administrador(): Prisma.administradorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.categoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.clienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comision`: Exposes CRUD operations for the **comision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comisions
    * const comisions = await prisma.comision.findMany()
    * ```
    */
  get comision(): Prisma.comisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detalle_diagnostico`: Exposes CRUD operations for the **detalle_diagnostico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detalle_diagnosticos
    * const detalle_diagnosticos = await prisma.detalle_diagnostico.findMany()
    * ```
    */
  get detalle_diagnostico(): Prisma.detalle_diagnosticoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detalle_proforma`: Exposes CRUD operations for the **detalle_proforma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detalle_proformas
    * const detalle_proformas = await prisma.detalle_proforma.findMany()
    * ```
    */
  get detalle_proforma(): Prisma.detalle_proformaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diagnostico`: Exposes CRUD operations for the **diagnostico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnosticos
    * const diagnosticos = await prisma.diagnostico.findMany()
    * ```
    */
  get diagnostico(): Prisma.diagnosticoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.empleado`: Exposes CRUD operations for the **empleado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleados
    * const empleados = await prisma.empleado.findMany()
    * ```
    */
  get empleado(): Prisma.empleadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.factura`: Exposes CRUD operations for the **factura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facturas
    * const facturas = await prisma.factura.findMany()
    * ```
    */
  get factura(): Prisma.facturaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.herramienta`: Exposes CRUD operations for the **herramienta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Herramientas
    * const herramientas = await prisma.herramienta.findMany()
    * ```
    */
  get herramienta(): Prisma.herramientaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.horario`: Exposes CRUD operations for the **horario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Horarios
    * const horarios = await prisma.horario.findMany()
    * ```
    */
  get horario(): Prisma.horarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.horario_empleado`: Exposes CRUD operations for the **horario_empleado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Horario_empleados
    * const horario_empleados = await prisma.horario_empleado.findMany()
    * ```
    */
  get horario_empleado(): Prisma.horario_empleadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marca_herramienta`: Exposes CRUD operations for the **marca_herramienta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marca_herramientas
    * const marca_herramientas = await prisma.marca_herramienta.findMany()
    * ```
    */
  get marca_herramienta(): Prisma.marca_herramientaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marca_moto`: Exposes CRUD operations for the **marca_moto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marca_motos
    * const marca_motos = await prisma.marca_moto.findMany()
    * ```
    */
  get marca_moto(): Prisma.marca_motoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moto`: Exposes CRUD operations for the **moto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motos
    * const motos = await prisma.moto.findMany()
    * ```
    */
  get moto(): Prisma.motoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.movimiento_herramienta`: Exposes CRUD operations for the **movimiento_herramienta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movimiento_herramientas
    * const movimiento_herramientas = await prisma.movimiento_herramienta.findMany()
    * ```
    */
  get movimiento_herramienta(): Prisma.movimiento_herramientaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orden_trabajo`: Exposes CRUD operations for the **orden_trabajo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orden_trabajos
    * const orden_trabajos = await prisma.orden_trabajo.findMany()
    * ```
    */
  get orden_trabajo(): Prisma.orden_trabajoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proforma`: Exposes CRUD operations for the **proforma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proformas
    * const proformas = await prisma.proforma.findMany()
    * ```
    */
  get proforma(): Prisma.proformaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proforma_repuesto`: Exposes CRUD operations for the **proforma_repuesto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proforma_repuestos
    * const proforma_repuestos = await prisma.proforma_repuesto.findMany()
    * ```
    */
  get proforma_repuesto(): Prisma.proforma_repuestoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicio`: Exposes CRUD operations for the **servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicio.findMany()
    * ```
    */
  get servicio(): Prisma.servicioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    administrador: 'administrador',
    categoria: 'categoria',
    cliente: 'cliente',
    comision: 'comision',
    detalle_diagnostico: 'detalle_diagnostico',
    detalle_proforma: 'detalle_proforma',
    diagnostico: 'diagnostico',
    empleado: 'empleado',
    factura: 'factura',
    herramienta: 'herramienta',
    horario: 'horario',
    horario_empleado: 'horario_empleado',
    marca_herramienta: 'marca_herramienta',
    marca_moto: 'marca_moto',
    moto: 'moto',
    movimiento_herramienta: 'movimiento_herramienta',
    orden_trabajo: 'orden_trabajo',
    proforma: 'proforma',
    proforma_repuesto: 'proforma_repuesto',
    servicio: 'servicio',
    usuario: 'usuario'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "administrador" | "categoria" | "cliente" | "comision" | "detalle_diagnostico" | "detalle_proforma" | "diagnostico" | "empleado" | "factura" | "herramienta" | "horario" | "horario_empleado" | "marca_herramienta" | "marca_moto" | "moto" | "movimiento_herramienta" | "orden_trabajo" | "proforma" | "proforma_repuesto" | "servicio" | "usuario"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      administrador: {
        payload: Prisma.$administradorPayload<ExtArgs>
        fields: Prisma.administradorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.administradorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.administradorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          findFirst: {
            args: Prisma.administradorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.administradorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          findMany: {
            args: Prisma.administradorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>[]
          }
          create: {
            args: Prisma.administradorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          createMany: {
            args: Prisma.administradorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.administradorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>[]
          }
          delete: {
            args: Prisma.administradorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          update: {
            args: Prisma.administradorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          deleteMany: {
            args: Prisma.administradorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.administradorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.administradorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>[]
          }
          upsert: {
            args: Prisma.administradorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administradorPayload>
          }
          aggregate: {
            args: Prisma.AdministradorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdministrador>
          }
          groupBy: {
            args: Prisma.administradorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdministradorGroupByOutputType>[]
          }
          count: {
            args: Prisma.administradorCountArgs<ExtArgs>
            result: $Utils.Optional<AdministradorCountAggregateOutputType> | number
          }
        }
      }
      categoria: {
        payload: Prisma.$categoriaPayload<ExtArgs>
        fields: Prisma.categoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          findFirst: {
            args: Prisma.categoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          findMany: {
            args: Prisma.categoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>[]
          }
          create: {
            args: Prisma.categoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          createMany: {
            args: Prisma.categoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>[]
          }
          delete: {
            args: Prisma.categoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          update: {
            args: Prisma.categoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          deleteMany: {
            args: Prisma.categoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>[]
          }
          upsert: {
            args: Prisma.categoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoria>
          }
          groupBy: {
            args: Prisma.categoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriaCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number
          }
        }
      }
      cliente: {
        payload: Prisma.$clientePayload<ExtArgs>
        fields: Prisma.clienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          findFirst: {
            args: Prisma.clienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          findMany: {
            args: Prisma.clienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload>[]
          }
          create: {
            args: Prisma.clienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          createMany: {
            args: Prisma.clienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload>[]
          }
          delete: {
            args: Prisma.clienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          update: {
            args: Prisma.clienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          deleteMany: {
            args: Prisma.clienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload>[]
          }
          upsert: {
            args: Prisma.clienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.clienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.clienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      comision: {
        payload: Prisma.$comisionPayload<ExtArgs>
        fields: Prisma.comisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload>
          }
          findFirst: {
            args: Prisma.comisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload>
          }
          findMany: {
            args: Prisma.comisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload>[]
          }
          create: {
            args: Prisma.comisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload>
          }
          createMany: {
            args: Prisma.comisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.comisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload>[]
          }
          delete: {
            args: Prisma.comisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload>
          }
          update: {
            args: Prisma.comisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload>
          }
          deleteMany: {
            args: Prisma.comisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.comisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload>[]
          }
          upsert: {
            args: Prisma.comisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comisionPayload>
          }
          aggregate: {
            args: Prisma.ComisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComision>
          }
          groupBy: {
            args: Prisma.comisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.comisionCountArgs<ExtArgs>
            result: $Utils.Optional<ComisionCountAggregateOutputType> | number
          }
        }
      }
      detalle_diagnostico: {
        payload: Prisma.$detalle_diagnosticoPayload<ExtArgs>
        fields: Prisma.detalle_diagnosticoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detalle_diagnosticoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detalle_diagnosticoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload>
          }
          findFirst: {
            args: Prisma.detalle_diagnosticoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detalle_diagnosticoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload>
          }
          findMany: {
            args: Prisma.detalle_diagnosticoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload>[]
          }
          create: {
            args: Prisma.detalle_diagnosticoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload>
          }
          createMany: {
            args: Prisma.detalle_diagnosticoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.detalle_diagnosticoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload>[]
          }
          delete: {
            args: Prisma.detalle_diagnosticoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload>
          }
          update: {
            args: Prisma.detalle_diagnosticoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload>
          }
          deleteMany: {
            args: Prisma.detalle_diagnosticoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.detalle_diagnosticoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.detalle_diagnosticoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload>[]
          }
          upsert: {
            args: Prisma.detalle_diagnosticoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_diagnosticoPayload>
          }
          aggregate: {
            args: Prisma.Detalle_diagnosticoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetalle_diagnostico>
          }
          groupBy: {
            args: Prisma.detalle_diagnosticoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Detalle_diagnosticoGroupByOutputType>[]
          }
          count: {
            args: Prisma.detalle_diagnosticoCountArgs<ExtArgs>
            result: $Utils.Optional<Detalle_diagnosticoCountAggregateOutputType> | number
          }
        }
      }
      detalle_proforma: {
        payload: Prisma.$detalle_proformaPayload<ExtArgs>
        fields: Prisma.detalle_proformaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detalle_proformaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detalle_proformaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload>
          }
          findFirst: {
            args: Prisma.detalle_proformaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detalle_proformaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload>
          }
          findMany: {
            args: Prisma.detalle_proformaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload>[]
          }
          create: {
            args: Prisma.detalle_proformaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload>
          }
          createMany: {
            args: Prisma.detalle_proformaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.detalle_proformaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload>[]
          }
          delete: {
            args: Prisma.detalle_proformaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload>
          }
          update: {
            args: Prisma.detalle_proformaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload>
          }
          deleteMany: {
            args: Prisma.detalle_proformaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.detalle_proformaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.detalle_proformaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload>[]
          }
          upsert: {
            args: Prisma.detalle_proformaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$detalle_proformaPayload>
          }
          aggregate: {
            args: Prisma.Detalle_proformaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetalle_proforma>
          }
          groupBy: {
            args: Prisma.detalle_proformaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Detalle_proformaGroupByOutputType>[]
          }
          count: {
            args: Prisma.detalle_proformaCountArgs<ExtArgs>
            result: $Utils.Optional<Detalle_proformaCountAggregateOutputType> | number
          }
        }
      }
      diagnostico: {
        payload: Prisma.$diagnosticoPayload<ExtArgs>
        fields: Prisma.diagnosticoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.diagnosticoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.diagnosticoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          findFirst: {
            args: Prisma.diagnosticoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.diagnosticoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          findMany: {
            args: Prisma.diagnosticoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>[]
          }
          create: {
            args: Prisma.diagnosticoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          createMany: {
            args: Prisma.diagnosticoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.diagnosticoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>[]
          }
          delete: {
            args: Prisma.diagnosticoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          update: {
            args: Prisma.diagnosticoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          deleteMany: {
            args: Prisma.diagnosticoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.diagnosticoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.diagnosticoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>[]
          }
          upsert: {
            args: Prisma.diagnosticoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnosticoPayload>
          }
          aggregate: {
            args: Prisma.DiagnosticoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnostico>
          }
          groupBy: {
            args: Prisma.diagnosticoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosticoGroupByOutputType>[]
          }
          count: {
            args: Prisma.diagnosticoCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosticoCountAggregateOutputType> | number
          }
        }
      }
      empleado: {
        payload: Prisma.$empleadoPayload<ExtArgs>
        fields: Prisma.empleadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.empleadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.empleadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          findFirst: {
            args: Prisma.empleadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.empleadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          findMany: {
            args: Prisma.empleadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>[]
          }
          create: {
            args: Prisma.empleadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          createMany: {
            args: Prisma.empleadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.empleadoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>[]
          }
          delete: {
            args: Prisma.empleadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          update: {
            args: Prisma.empleadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          deleteMany: {
            args: Prisma.empleadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.empleadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.empleadoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>[]
          }
          upsert: {
            args: Prisma.empleadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          aggregate: {
            args: Prisma.EmpleadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpleado>
          }
          groupBy: {
            args: Prisma.empleadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpleadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.empleadoCountArgs<ExtArgs>
            result: $Utils.Optional<EmpleadoCountAggregateOutputType> | number
          }
        }
      }
      factura: {
        payload: Prisma.$facturaPayload<ExtArgs>
        fields: Prisma.facturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.facturaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.facturaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          findFirst: {
            args: Prisma.facturaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.facturaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          findMany: {
            args: Prisma.facturaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>[]
          }
          create: {
            args: Prisma.facturaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          createMany: {
            args: Prisma.facturaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.facturaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>[]
          }
          delete: {
            args: Prisma.facturaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          update: {
            args: Prisma.facturaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          deleteMany: {
            args: Prisma.facturaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.facturaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.facturaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>[]
          }
          upsert: {
            args: Prisma.facturaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facturaPayload>
          }
          aggregate: {
            args: Prisma.FacturaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactura>
          }
          groupBy: {
            args: Prisma.facturaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.facturaCountArgs<ExtArgs>
            result: $Utils.Optional<FacturaCountAggregateOutputType> | number
          }
        }
      }
      herramienta: {
        payload: Prisma.$herramientaPayload<ExtArgs>
        fields: Prisma.herramientaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.herramientaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.herramientaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload>
          }
          findFirst: {
            args: Prisma.herramientaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.herramientaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload>
          }
          findMany: {
            args: Prisma.herramientaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload>[]
          }
          create: {
            args: Prisma.herramientaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload>
          }
          createMany: {
            args: Prisma.herramientaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.herramientaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload>[]
          }
          delete: {
            args: Prisma.herramientaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload>
          }
          update: {
            args: Prisma.herramientaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload>
          }
          deleteMany: {
            args: Prisma.herramientaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.herramientaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.herramientaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload>[]
          }
          upsert: {
            args: Prisma.herramientaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$herramientaPayload>
          }
          aggregate: {
            args: Prisma.HerramientaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHerramienta>
          }
          groupBy: {
            args: Prisma.herramientaGroupByArgs<ExtArgs>
            result: $Utils.Optional<HerramientaGroupByOutputType>[]
          }
          count: {
            args: Prisma.herramientaCountArgs<ExtArgs>
            result: $Utils.Optional<HerramientaCountAggregateOutputType> | number
          }
        }
      }
      horario: {
        payload: Prisma.$horarioPayload<ExtArgs>
        fields: Prisma.horarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.horarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.horarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload>
          }
          findFirst: {
            args: Prisma.horarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.horarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload>
          }
          findMany: {
            args: Prisma.horarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload>[]
          }
          create: {
            args: Prisma.horarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload>
          }
          createMany: {
            args: Prisma.horarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.horarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload>[]
          }
          delete: {
            args: Prisma.horarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload>
          }
          update: {
            args: Prisma.horarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload>
          }
          deleteMany: {
            args: Prisma.horarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.horarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.horarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload>[]
          }
          upsert: {
            args: Prisma.horarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horarioPayload>
          }
          aggregate: {
            args: Prisma.HorarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHorario>
          }
          groupBy: {
            args: Prisma.horarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<HorarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.horarioCountArgs<ExtArgs>
            result: $Utils.Optional<HorarioCountAggregateOutputType> | number
          }
        }
      }
      horario_empleado: {
        payload: Prisma.$horario_empleadoPayload<ExtArgs>
        fields: Prisma.horario_empleadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.horario_empleadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.horario_empleadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload>
          }
          findFirst: {
            args: Prisma.horario_empleadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.horario_empleadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload>
          }
          findMany: {
            args: Prisma.horario_empleadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload>[]
          }
          create: {
            args: Prisma.horario_empleadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload>
          }
          createMany: {
            args: Prisma.horario_empleadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.horario_empleadoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload>[]
          }
          delete: {
            args: Prisma.horario_empleadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload>
          }
          update: {
            args: Prisma.horario_empleadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload>
          }
          deleteMany: {
            args: Prisma.horario_empleadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.horario_empleadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.horario_empleadoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload>[]
          }
          upsert: {
            args: Prisma.horario_empleadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$horario_empleadoPayload>
          }
          aggregate: {
            args: Prisma.Horario_empleadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHorario_empleado>
          }
          groupBy: {
            args: Prisma.horario_empleadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Horario_empleadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.horario_empleadoCountArgs<ExtArgs>
            result: $Utils.Optional<Horario_empleadoCountAggregateOutputType> | number
          }
        }
      }
      marca_herramienta: {
        payload: Prisma.$marca_herramientaPayload<ExtArgs>
        fields: Prisma.marca_herramientaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.marca_herramientaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.marca_herramientaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload>
          }
          findFirst: {
            args: Prisma.marca_herramientaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.marca_herramientaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload>
          }
          findMany: {
            args: Prisma.marca_herramientaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload>[]
          }
          create: {
            args: Prisma.marca_herramientaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload>
          }
          createMany: {
            args: Prisma.marca_herramientaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.marca_herramientaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload>[]
          }
          delete: {
            args: Prisma.marca_herramientaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload>
          }
          update: {
            args: Prisma.marca_herramientaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload>
          }
          deleteMany: {
            args: Prisma.marca_herramientaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.marca_herramientaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.marca_herramientaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload>[]
          }
          upsert: {
            args: Prisma.marca_herramientaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_herramientaPayload>
          }
          aggregate: {
            args: Prisma.Marca_herramientaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarca_herramienta>
          }
          groupBy: {
            args: Prisma.marca_herramientaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Marca_herramientaGroupByOutputType>[]
          }
          count: {
            args: Prisma.marca_herramientaCountArgs<ExtArgs>
            result: $Utils.Optional<Marca_herramientaCountAggregateOutputType> | number
          }
        }
      }
      marca_moto: {
        payload: Prisma.$marca_motoPayload<ExtArgs>
        fields: Prisma.marca_motoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.marca_motoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.marca_motoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload>
          }
          findFirst: {
            args: Prisma.marca_motoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.marca_motoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload>
          }
          findMany: {
            args: Prisma.marca_motoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload>[]
          }
          create: {
            args: Prisma.marca_motoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload>
          }
          createMany: {
            args: Prisma.marca_motoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.marca_motoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload>[]
          }
          delete: {
            args: Prisma.marca_motoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload>
          }
          update: {
            args: Prisma.marca_motoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload>
          }
          deleteMany: {
            args: Prisma.marca_motoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.marca_motoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.marca_motoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload>[]
          }
          upsert: {
            args: Prisma.marca_motoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marca_motoPayload>
          }
          aggregate: {
            args: Prisma.Marca_motoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarca_moto>
          }
          groupBy: {
            args: Prisma.marca_motoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Marca_motoGroupByOutputType>[]
          }
          count: {
            args: Prisma.marca_motoCountArgs<ExtArgs>
            result: $Utils.Optional<Marca_motoCountAggregateOutputType> | number
          }
        }
      }
      moto: {
        payload: Prisma.$motoPayload<ExtArgs>
        fields: Prisma.motoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.motoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.motoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload>
          }
          findFirst: {
            args: Prisma.motoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.motoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload>
          }
          findMany: {
            args: Prisma.motoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload>[]
          }
          create: {
            args: Prisma.motoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload>
          }
          createMany: {
            args: Prisma.motoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.motoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload>[]
          }
          delete: {
            args: Prisma.motoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload>
          }
          update: {
            args: Prisma.motoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload>
          }
          deleteMany: {
            args: Prisma.motoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.motoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.motoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload>[]
          }
          upsert: {
            args: Prisma.motoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$motoPayload>
          }
          aggregate: {
            args: Prisma.MotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoto>
          }
          groupBy: {
            args: Prisma.motoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.motoCountArgs<ExtArgs>
            result: $Utils.Optional<MotoCountAggregateOutputType> | number
          }
        }
      }
      movimiento_herramienta: {
        payload: Prisma.$movimiento_herramientaPayload<ExtArgs>
        fields: Prisma.movimiento_herramientaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.movimiento_herramientaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.movimiento_herramientaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload>
          }
          findFirst: {
            args: Prisma.movimiento_herramientaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.movimiento_herramientaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload>
          }
          findMany: {
            args: Prisma.movimiento_herramientaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload>[]
          }
          create: {
            args: Prisma.movimiento_herramientaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload>
          }
          createMany: {
            args: Prisma.movimiento_herramientaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.movimiento_herramientaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload>[]
          }
          delete: {
            args: Prisma.movimiento_herramientaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload>
          }
          update: {
            args: Prisma.movimiento_herramientaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload>
          }
          deleteMany: {
            args: Prisma.movimiento_herramientaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.movimiento_herramientaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.movimiento_herramientaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload>[]
          }
          upsert: {
            args: Prisma.movimiento_herramientaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$movimiento_herramientaPayload>
          }
          aggregate: {
            args: Prisma.Movimiento_herramientaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovimiento_herramienta>
          }
          groupBy: {
            args: Prisma.movimiento_herramientaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Movimiento_herramientaGroupByOutputType>[]
          }
          count: {
            args: Prisma.movimiento_herramientaCountArgs<ExtArgs>
            result: $Utils.Optional<Movimiento_herramientaCountAggregateOutputType> | number
          }
        }
      }
      orden_trabajo: {
        payload: Prisma.$orden_trabajoPayload<ExtArgs>
        fields: Prisma.orden_trabajoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orden_trabajoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orden_trabajoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload>
          }
          findFirst: {
            args: Prisma.orden_trabajoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orden_trabajoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload>
          }
          findMany: {
            args: Prisma.orden_trabajoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload>[]
          }
          create: {
            args: Prisma.orden_trabajoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload>
          }
          createMany: {
            args: Prisma.orden_trabajoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.orden_trabajoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload>[]
          }
          delete: {
            args: Prisma.orden_trabajoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload>
          }
          update: {
            args: Prisma.orden_trabajoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload>
          }
          deleteMany: {
            args: Prisma.orden_trabajoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.orden_trabajoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.orden_trabajoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload>[]
          }
          upsert: {
            args: Prisma.orden_trabajoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orden_trabajoPayload>
          }
          aggregate: {
            args: Prisma.Orden_trabajoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrden_trabajo>
          }
          groupBy: {
            args: Prisma.orden_trabajoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Orden_trabajoGroupByOutputType>[]
          }
          count: {
            args: Prisma.orden_trabajoCountArgs<ExtArgs>
            result: $Utils.Optional<Orden_trabajoCountAggregateOutputType> | number
          }
        }
      }
      proforma: {
        payload: Prisma.$proformaPayload<ExtArgs>
        fields: Prisma.proformaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.proformaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.proformaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload>
          }
          findFirst: {
            args: Prisma.proformaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.proformaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload>
          }
          findMany: {
            args: Prisma.proformaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload>[]
          }
          create: {
            args: Prisma.proformaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload>
          }
          createMany: {
            args: Prisma.proformaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.proformaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload>[]
          }
          delete: {
            args: Prisma.proformaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload>
          }
          update: {
            args: Prisma.proformaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload>
          }
          deleteMany: {
            args: Prisma.proformaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.proformaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.proformaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload>[]
          }
          upsert: {
            args: Prisma.proformaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proformaPayload>
          }
          aggregate: {
            args: Prisma.ProformaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProforma>
          }
          groupBy: {
            args: Prisma.proformaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProformaGroupByOutputType>[]
          }
          count: {
            args: Prisma.proformaCountArgs<ExtArgs>
            result: $Utils.Optional<ProformaCountAggregateOutputType> | number
          }
        }
      }
      proforma_repuesto: {
        payload: Prisma.$proforma_repuestoPayload<ExtArgs>
        fields: Prisma.proforma_repuestoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.proforma_repuestoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.proforma_repuestoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload>
          }
          findFirst: {
            args: Prisma.proforma_repuestoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.proforma_repuestoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload>
          }
          findMany: {
            args: Prisma.proforma_repuestoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload>[]
          }
          create: {
            args: Prisma.proforma_repuestoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload>
          }
          createMany: {
            args: Prisma.proforma_repuestoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.proforma_repuestoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload>[]
          }
          delete: {
            args: Prisma.proforma_repuestoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload>
          }
          update: {
            args: Prisma.proforma_repuestoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload>
          }
          deleteMany: {
            args: Prisma.proforma_repuestoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.proforma_repuestoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.proforma_repuestoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload>[]
          }
          upsert: {
            args: Prisma.proforma_repuestoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$proforma_repuestoPayload>
          }
          aggregate: {
            args: Prisma.Proforma_repuestoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProforma_repuesto>
          }
          groupBy: {
            args: Prisma.proforma_repuestoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Proforma_repuestoGroupByOutputType>[]
          }
          count: {
            args: Prisma.proforma_repuestoCountArgs<ExtArgs>
            result: $Utils.Optional<Proforma_repuestoCountAggregateOutputType> | number
          }
        }
      }
      servicio: {
        payload: Prisma.$servicioPayload<ExtArgs>
        fields: Prisma.servicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.servicioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload>
          }
          findFirst: {
            args: Prisma.servicioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload>
          }
          findMany: {
            args: Prisma.servicioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload>[]
          }
          create: {
            args: Prisma.servicioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload>
          }
          createMany: {
            args: Prisma.servicioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.servicioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload>[]
          }
          delete: {
            args: Prisma.servicioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload>
          }
          update: {
            args: Prisma.servicioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload>
          }
          deleteMany: {
            args: Prisma.servicioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.servicioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.servicioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload>[]
          }
          upsert: {
            args: Prisma.servicioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicioPayload>
          }
          aggregate: {
            args: Prisma.ServicioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicio>
          }
          groupBy: {
            args: Prisma.servicioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicioCountArgs<ExtArgs>
            result: $Utils.Optional<ServicioCountAggregateOutputType> | number
          }
        }
      }
      usuario: {
        payload: Prisma.$usuarioPayload<ExtArgs>
        fields: Prisma.usuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findFirst: {
            args: Prisma.usuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findMany: {
            args: Prisma.usuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          create: {
            args: Prisma.usuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          createMany: {
            args: Prisma.usuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          delete: {
            args: Prisma.usuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          update: {
            args: Prisma.usuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          deleteMany: {
            args: Prisma.usuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          upsert: {
            args: Prisma.usuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.usuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    administrador?: administradorOmit
    categoria?: categoriaOmit
    cliente?: clienteOmit
    comision?: comisionOmit
    detalle_diagnostico?: detalle_diagnosticoOmit
    detalle_proforma?: detalle_proformaOmit
    diagnostico?: diagnosticoOmit
    empleado?: empleadoOmit
    factura?: facturaOmit
    herramienta?: herramientaOmit
    horario?: horarioOmit
    horario_empleado?: horario_empleadoOmit
    marca_herramienta?: marca_herramientaOmit
    marca_moto?: marca_motoOmit
    moto?: motoOmit
    movimiento_herramienta?: movimiento_herramientaOmit
    orden_trabajo?: orden_trabajoOmit
    proforma?: proformaOmit
    proforma_repuesto?: proforma_repuestoOmit
    servicio?: servicioOmit
    usuario?: usuarioOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdministradorCountOutputType
   */

  export type AdministradorCountOutputType = {
    orden_trabajo: number
  }

  export type AdministradorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden_trabajo?: boolean | AdministradorCountOutputTypeCountOrden_trabajoArgs
  }

  // Custom InputTypes
  /**
   * AdministradorCountOutputType without action
   */
  export type AdministradorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministradorCountOutputType
     */
    select?: AdministradorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdministradorCountOutputType without action
   */
  export type AdministradorCountOutputTypeCountOrden_trabajoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orden_trabajoWhereInput
  }


  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    servicio: number
  }

  export type CategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | CategoriaCountOutputTypeCountServicioArgs
  }

  // Custom InputTypes
  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountServicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicioWhereInput
  }


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    factura: number
    proforma: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    factura?: boolean | ClienteCountOutputTypeCountFacturaArgs
    proforma?: boolean | ClienteCountOutputTypeCountProformaArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountFacturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facturaWhereInput
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountProformaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proformaWhereInput
  }


  /**
   * Count Type DiagnosticoCountOutputType
   */

  export type DiagnosticoCountOutputType = {
    detalle_diagnostico: number
  }

  export type DiagnosticoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_diagnostico?: boolean | DiagnosticoCountOutputTypeCountDetalle_diagnosticoArgs
  }

  // Custom InputTypes
  /**
   * DiagnosticoCountOutputType without action
   */
  export type DiagnosticoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosticoCountOutputType
     */
    select?: DiagnosticoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiagnosticoCountOutputType without action
   */
  export type DiagnosticoCountOutputTypeCountDetalle_diagnosticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_diagnosticoWhereInput
  }


  /**
   * Count Type EmpleadoCountOutputType
   */

  export type EmpleadoCountOutputType = {
    diagnostico: number
    horario_empleado: number
    orden_trabajo: number
  }

  export type EmpleadoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostico?: boolean | EmpleadoCountOutputTypeCountDiagnosticoArgs
    horario_empleado?: boolean | EmpleadoCountOutputTypeCountHorario_empleadoArgs
    orden_trabajo?: boolean | EmpleadoCountOutputTypeCountOrden_trabajoArgs
  }

  // Custom InputTypes
  /**
   * EmpleadoCountOutputType without action
   */
  export type EmpleadoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadoCountOutputType
     */
    select?: EmpleadoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpleadoCountOutputType without action
   */
  export type EmpleadoCountOutputTypeCountDiagnosticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnosticoWhereInput
  }

  /**
   * EmpleadoCountOutputType without action
   */
  export type EmpleadoCountOutputTypeCountHorario_empleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: horario_empleadoWhereInput
  }

  /**
   * EmpleadoCountOutputType without action
   */
  export type EmpleadoCountOutputTypeCountOrden_trabajoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orden_trabajoWhereInput
  }


  /**
   * Count Type HerramientaCountOutputType
   */

  export type HerramientaCountOutputType = {
    movimiento_herramienta: number
  }

  export type HerramientaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movimiento_herramienta?: boolean | HerramientaCountOutputTypeCountMovimiento_herramientaArgs
  }

  // Custom InputTypes
  /**
   * HerramientaCountOutputType without action
   */
  export type HerramientaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HerramientaCountOutputType
     */
    select?: HerramientaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HerramientaCountOutputType without action
   */
  export type HerramientaCountOutputTypeCountMovimiento_herramientaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: movimiento_herramientaWhereInput
  }


  /**
   * Count Type HorarioCountOutputType
   */

  export type HorarioCountOutputType = {
    horario_empleado: number
  }

  export type HorarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    horario_empleado?: boolean | HorarioCountOutputTypeCountHorario_empleadoArgs
  }

  // Custom InputTypes
  /**
   * HorarioCountOutputType without action
   */
  export type HorarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HorarioCountOutputType
     */
    select?: HorarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HorarioCountOutputType without action
   */
  export type HorarioCountOutputTypeCountHorario_empleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: horario_empleadoWhereInput
  }


  /**
   * Count Type Marca_herramientaCountOutputType
   */

  export type Marca_herramientaCountOutputType = {
    herramienta: number
  }

  export type Marca_herramientaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    herramienta?: boolean | Marca_herramientaCountOutputTypeCountHerramientaArgs
  }

  // Custom InputTypes
  /**
   * Marca_herramientaCountOutputType without action
   */
  export type Marca_herramientaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marca_herramientaCountOutputType
     */
    select?: Marca_herramientaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Marca_herramientaCountOutputType without action
   */
  export type Marca_herramientaCountOutputTypeCountHerramientaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: herramientaWhereInput
  }


  /**
   * Count Type Marca_motoCountOutputType
   */

  export type Marca_motoCountOutputType = {
    moto: number
  }

  export type Marca_motoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moto?: boolean | Marca_motoCountOutputTypeCountMotoArgs
  }

  // Custom InputTypes
  /**
   * Marca_motoCountOutputType without action
   */
  export type Marca_motoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marca_motoCountOutputType
     */
    select?: Marca_motoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Marca_motoCountOutputType without action
   */
  export type Marca_motoCountOutputTypeCountMotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: motoWhereInput
  }


  /**
   * Count Type MotoCountOutputType
   */

  export type MotoCountOutputType = {
    diagnostico: number
  }

  export type MotoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostico?: boolean | MotoCountOutputTypeCountDiagnosticoArgs
  }

  // Custom InputTypes
  /**
   * MotoCountOutputType without action
   */
  export type MotoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotoCountOutputType
     */
    select?: MotoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MotoCountOutputType without action
   */
  export type MotoCountOutputTypeCountDiagnosticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnosticoWhereInput
  }


  /**
   * Count Type Orden_trabajoCountOutputType
   */

  export type Orden_trabajoCountOutputType = {
    movimiento_herramienta: number
  }

  export type Orden_trabajoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movimiento_herramienta?: boolean | Orden_trabajoCountOutputTypeCountMovimiento_herramientaArgs
  }

  // Custom InputTypes
  /**
   * Orden_trabajoCountOutputType without action
   */
  export type Orden_trabajoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orden_trabajoCountOutputType
     */
    select?: Orden_trabajoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Orden_trabajoCountOutputType without action
   */
  export type Orden_trabajoCountOutputTypeCountMovimiento_herramientaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: movimiento_herramientaWhereInput
  }


  /**
   * Count Type ProformaCountOutputType
   */

  export type ProformaCountOutputType = {
    detalle_proforma: number
    proforma_repuesto: number
  }

  export type ProformaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_proforma?: boolean | ProformaCountOutputTypeCountDetalle_proformaArgs
    proforma_repuesto?: boolean | ProformaCountOutputTypeCountProforma_repuestoArgs
  }

  // Custom InputTypes
  /**
   * ProformaCountOutputType without action
   */
  export type ProformaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProformaCountOutputType
     */
    select?: ProformaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProformaCountOutputType without action
   */
  export type ProformaCountOutputTypeCountDetalle_proformaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_proformaWhereInput
  }

  /**
   * ProformaCountOutputType without action
   */
  export type ProformaCountOutputTypeCountProforma_repuestoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proforma_repuestoWhereInput
  }


  /**
   * Count Type ServicioCountOutputType
   */

  export type ServicioCountOutputType = {
    detalle_proforma: number
    orden_trabajo: number
  }

  export type ServicioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_proforma?: boolean | ServicioCountOutputTypeCountDetalle_proformaArgs
    orden_trabajo?: boolean | ServicioCountOutputTypeCountOrden_trabajoArgs
  }

  // Custom InputTypes
  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioCountOutputType
     */
    select?: ServicioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountDetalle_proformaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_proformaWhereInput
  }

  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountOrden_trabajoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orden_trabajoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model administrador
   */

  export type AggregateAdministrador = {
    _count: AdministradorCountAggregateOutputType | null
    _avg: AdministradorAvgAggregateOutputType | null
    _sum: AdministradorSumAggregateOutputType | null
    _min: AdministradorMinAggregateOutputType | null
    _max: AdministradorMaxAggregateOutputType | null
  }

  export type AdministradorAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type AdministradorSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type AdministradorMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type AdministradorMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
  }

  export type AdministradorCountAggregateOutputType = {
    id: number
    usuario_id: number
    _all: number
  }


  export type AdministradorAvgAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type AdministradorSumAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type AdministradorMinAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type AdministradorMaxAggregateInputType = {
    id?: true
    usuario_id?: true
  }

  export type AdministradorCountAggregateInputType = {
    id?: true
    usuario_id?: true
    _all?: true
  }

  export type AdministradorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which administrador to aggregate.
     */
    where?: administradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administradors to fetch.
     */
    orderBy?: administradorOrderByWithRelationInput | administradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: administradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administradors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned administradors
    **/
    _count?: true | AdministradorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdministradorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdministradorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministradorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministradorMaxAggregateInputType
  }

  export type GetAdministradorAggregateType<T extends AdministradorAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministrador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministrador[P]>
      : GetScalarType<T[P], AggregateAdministrador[P]>
  }




  export type administradorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: administradorWhereInput
    orderBy?: administradorOrderByWithAggregationInput | administradorOrderByWithAggregationInput[]
    by: AdministradorScalarFieldEnum[] | AdministradorScalarFieldEnum
    having?: administradorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministradorCountAggregateInputType | true
    _avg?: AdministradorAvgAggregateInputType
    _sum?: AdministradorSumAggregateInputType
    _min?: AdministradorMinAggregateInputType
    _max?: AdministradorMaxAggregateInputType
  }

  export type AdministradorGroupByOutputType = {
    id: number
    usuario_id: number
    _count: AdministradorCountAggregateOutputType | null
    _avg: AdministradorAvgAggregateOutputType | null
    _sum: AdministradorSumAggregateOutputType | null
    _min: AdministradorMinAggregateOutputType | null
    _max: AdministradorMaxAggregateOutputType | null
  }

  type GetAdministradorGroupByPayload<T extends administradorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdministradorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdministradorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdministradorGroupByOutputType[P]>
            : GetScalarType<T[P], AdministradorGroupByOutputType[P]>
        }
      >
    >


  export type administradorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    orden_trabajo?: boolean | administrador$orden_trabajoArgs<ExtArgs>
    _count?: boolean | AdministradorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrador"]>

  export type administradorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrador"]>

  export type administradorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrador"]>

  export type administradorSelectScalar = {
    id?: boolean
    usuario_id?: boolean
  }

  export type administradorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id", ExtArgs["result"]["administrador"]>
  export type administradorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    orden_trabajo?: boolean | administrador$orden_trabajoArgs<ExtArgs>
    _count?: boolean | AdministradorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type administradorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }
  export type administradorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }

  export type $administradorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "administrador"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs>
      orden_trabajo: Prisma.$orden_trabajoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number
    }, ExtArgs["result"]["administrador"]>
    composites: {}
  }

  type administradorGetPayload<S extends boolean | null | undefined | administradorDefaultArgs> = $Result.GetResult<Prisma.$administradorPayload, S>

  type administradorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<administradorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdministradorCountAggregateInputType | true
    }

  export interface administradorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['administrador'], meta: { name: 'administrador' } }
    /**
     * Find zero or one Administrador that matches the filter.
     * @param {administradorFindUniqueArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends administradorFindUniqueArgs>(args: SelectSubset<T, administradorFindUniqueArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Administrador that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {administradorFindUniqueOrThrowArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends administradorFindUniqueOrThrowArgs>(args: SelectSubset<T, administradorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Administrador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorFindFirstArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends administradorFindFirstArgs>(args?: SelectSubset<T, administradorFindFirstArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Administrador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorFindFirstOrThrowArgs} args - Arguments to find a Administrador
     * @example
     * // Get one Administrador
     * const administrador = await prisma.administrador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends administradorFindFirstOrThrowArgs>(args?: SelectSubset<T, administradorFindFirstOrThrowArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Administradors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Administradors
     * const administradors = await prisma.administrador.findMany()
     * 
     * // Get first 10 Administradors
     * const administradors = await prisma.administrador.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const administradorWithIdOnly = await prisma.administrador.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends administradorFindManyArgs>(args?: SelectSubset<T, administradorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Administrador.
     * @param {administradorCreateArgs} args - Arguments to create a Administrador.
     * @example
     * // Create one Administrador
     * const Administrador = await prisma.administrador.create({
     *   data: {
     *     // ... data to create a Administrador
     *   }
     * })
     * 
     */
    create<T extends administradorCreateArgs>(args: SelectSubset<T, administradorCreateArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Administradors.
     * @param {administradorCreateManyArgs} args - Arguments to create many Administradors.
     * @example
     * // Create many Administradors
     * const administrador = await prisma.administrador.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends administradorCreateManyArgs>(args?: SelectSubset<T, administradorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Administradors and returns the data saved in the database.
     * @param {administradorCreateManyAndReturnArgs} args - Arguments to create many Administradors.
     * @example
     * // Create many Administradors
     * const administrador = await prisma.administrador.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Administradors and only return the `id`
     * const administradorWithIdOnly = await prisma.administrador.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends administradorCreateManyAndReturnArgs>(args?: SelectSubset<T, administradorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Administrador.
     * @param {administradorDeleteArgs} args - Arguments to delete one Administrador.
     * @example
     * // Delete one Administrador
     * const Administrador = await prisma.administrador.delete({
     *   where: {
     *     // ... filter to delete one Administrador
     *   }
     * })
     * 
     */
    delete<T extends administradorDeleteArgs>(args: SelectSubset<T, administradorDeleteArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Administrador.
     * @param {administradorUpdateArgs} args - Arguments to update one Administrador.
     * @example
     * // Update one Administrador
     * const administrador = await prisma.administrador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends administradorUpdateArgs>(args: SelectSubset<T, administradorUpdateArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Administradors.
     * @param {administradorDeleteManyArgs} args - Arguments to filter Administradors to delete.
     * @example
     * // Delete a few Administradors
     * const { count } = await prisma.administrador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends administradorDeleteManyArgs>(args?: SelectSubset<T, administradorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administradors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Administradors
     * const administrador = await prisma.administrador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends administradorUpdateManyArgs>(args: SelectSubset<T, administradorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administradors and returns the data updated in the database.
     * @param {administradorUpdateManyAndReturnArgs} args - Arguments to update many Administradors.
     * @example
     * // Update many Administradors
     * const administrador = await prisma.administrador.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Administradors and only return the `id`
     * const administradorWithIdOnly = await prisma.administrador.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends administradorUpdateManyAndReturnArgs>(args: SelectSubset<T, administradorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Administrador.
     * @param {administradorUpsertArgs} args - Arguments to update or create a Administrador.
     * @example
     * // Update or create a Administrador
     * const administrador = await prisma.administrador.upsert({
     *   create: {
     *     // ... data to create a Administrador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Administrador we want to update
     *   }
     * })
     */
    upsert<T extends administradorUpsertArgs>(args: SelectSubset<T, administradorUpsertArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Administradors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorCountArgs} args - Arguments to filter Administradors to count.
     * @example
     * // Count the number of Administradors
     * const count = await prisma.administrador.count({
     *   where: {
     *     // ... the filter for the Administradors we want to count
     *   }
     * })
    **/
    count<T extends administradorCountArgs>(
      args?: Subset<T, administradorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministradorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Administrador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministradorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministradorAggregateArgs>(args: Subset<T, AdministradorAggregateArgs>): Prisma.PrismaPromise<GetAdministradorAggregateType<T>>

    /**
     * Group by Administrador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administradorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends administradorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: administradorGroupByArgs['orderBy'] }
        : { orderBy?: administradorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, administradorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministradorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the administrador model
   */
  readonly fields: administradorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for administrador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__administradorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orden_trabajo<T extends administrador$orden_trabajoArgs<ExtArgs> = {}>(args?: Subset<T, administrador$orden_trabajoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the administrador model
   */
  interface administradorFieldRefs {
    readonly id: FieldRef<"administrador", 'Int'>
    readonly usuario_id: FieldRef<"administrador", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * administrador findUnique
   */
  export type administradorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter, which administrador to fetch.
     */
    where: administradorWhereUniqueInput
  }

  /**
   * administrador findUniqueOrThrow
   */
  export type administradorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter, which administrador to fetch.
     */
    where: administradorWhereUniqueInput
  }

  /**
   * administrador findFirst
   */
  export type administradorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter, which administrador to fetch.
     */
    where?: administradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administradors to fetch.
     */
    orderBy?: administradorOrderByWithRelationInput | administradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for administradors.
     */
    cursor?: administradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administradors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of administradors.
     */
    distinct?: AdministradorScalarFieldEnum | AdministradorScalarFieldEnum[]
  }

  /**
   * administrador findFirstOrThrow
   */
  export type administradorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter, which administrador to fetch.
     */
    where?: administradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administradors to fetch.
     */
    orderBy?: administradorOrderByWithRelationInput | administradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for administradors.
     */
    cursor?: administradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administradors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of administradors.
     */
    distinct?: AdministradorScalarFieldEnum | AdministradorScalarFieldEnum[]
  }

  /**
   * administrador findMany
   */
  export type administradorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter, which administradors to fetch.
     */
    where?: administradorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administradors to fetch.
     */
    orderBy?: administradorOrderByWithRelationInput | administradorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing administradors.
     */
    cursor?: administradorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administradors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administradors.
     */
    skip?: number
    distinct?: AdministradorScalarFieldEnum | AdministradorScalarFieldEnum[]
  }

  /**
   * administrador create
   */
  export type administradorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * The data needed to create a administrador.
     */
    data: XOR<administradorCreateInput, administradorUncheckedCreateInput>
  }

  /**
   * administrador createMany
   */
  export type administradorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many administradors.
     */
    data: administradorCreateManyInput | administradorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * administrador createManyAndReturn
   */
  export type administradorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * The data used to create many administradors.
     */
    data: administradorCreateManyInput | administradorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * administrador update
   */
  export type administradorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * The data needed to update a administrador.
     */
    data: XOR<administradorUpdateInput, administradorUncheckedUpdateInput>
    /**
     * Choose, which administrador to update.
     */
    where: administradorWhereUniqueInput
  }

  /**
   * administrador updateMany
   */
  export type administradorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update administradors.
     */
    data: XOR<administradorUpdateManyMutationInput, administradorUncheckedUpdateManyInput>
    /**
     * Filter which administradors to update
     */
    where?: administradorWhereInput
    /**
     * Limit how many administradors to update.
     */
    limit?: number
  }

  /**
   * administrador updateManyAndReturn
   */
  export type administradorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * The data used to update administradors.
     */
    data: XOR<administradorUpdateManyMutationInput, administradorUncheckedUpdateManyInput>
    /**
     * Filter which administradors to update
     */
    where?: administradorWhereInput
    /**
     * Limit how many administradors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * administrador upsert
   */
  export type administradorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * The filter to search for the administrador to update in case it exists.
     */
    where: administradorWhereUniqueInput
    /**
     * In case the administrador found by the `where` argument doesn't exist, create a new administrador with this data.
     */
    create: XOR<administradorCreateInput, administradorUncheckedCreateInput>
    /**
     * In case the administrador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<administradorUpdateInput, administradorUncheckedUpdateInput>
  }

  /**
   * administrador delete
   */
  export type administradorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    /**
     * Filter which administrador to delete.
     */
    where: administradorWhereUniqueInput
  }

  /**
   * administrador deleteMany
   */
  export type administradorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which administradors to delete
     */
    where?: administradorWhereInput
    /**
     * Limit how many administradors to delete.
     */
    limit?: number
  }

  /**
   * administrador.orden_trabajo
   */
  export type administrador$orden_trabajoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    where?: orden_trabajoWhereInput
    orderBy?: orden_trabajoOrderByWithRelationInput | orden_trabajoOrderByWithRelationInput[]
    cursor?: orden_trabajoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Orden_trabajoScalarFieldEnum | Orden_trabajoScalarFieldEnum[]
  }

  /**
   * administrador without action
   */
  export type administradorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
  }


  /**
   * Model categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    id?: true
  }

  export type CategoriaSumAggregateInputType = {
    id?: true
  }

  export type CategoriaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CategoriaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type CategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoria to aggregate.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type categoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriaWhereInput
    orderBy?: categoriaOrderByWithAggregationInput | categoriaOrderByWithAggregationInput[]
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum
    having?: categoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }

  export type CategoriaGroupByOutputType = {
    id: number
    nombre: string
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends categoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type categoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    servicio?: boolean | categoria$servicioArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type categoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["categoria"]>

  export type categoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["categoria"]>

  export type categoriaSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type categoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre", ExtArgs["result"]["categoria"]>
  export type categoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | categoria$servicioArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type categoriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $categoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categoria"
    objects: {
      servicio: Prisma.$servicioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["categoria"]>
    composites: {}
  }

  type categoriaGetPayload<S extends boolean | null | undefined | categoriaDefaultArgs> = $Result.GetResult<Prisma.$categoriaPayload, S>

  type categoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface categoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categoria'], meta: { name: 'categoria' } }
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {categoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriaFindUniqueArgs>(args: SelectSubset<T, categoriaFindUniqueArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriaFindFirstArgs>(args?: SelectSubset<T, categoriaFindFirstArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriaFindManyArgs>(args?: SelectSubset<T, categoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categoria.
     * @param {categoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
     */
    create<T extends categoriaCreateArgs>(args: SelectSubset<T, categoriaCreateArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categorias.
     * @param {categoriaCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriaCreateManyArgs>(args?: SelectSubset<T, categoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categorias and returns the data saved in the database.
     * @param {categoriaCreateManyAndReturnArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categorias and only return the `id`
     * const categoriaWithIdOnly = await prisma.categoria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categoria.
     * @param {categoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
     */
    delete<T extends categoriaDeleteArgs>(args: SelectSubset<T, categoriaDeleteArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categoria.
     * @param {categoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriaUpdateArgs>(args: SelectSubset<T, categoriaUpdateArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categorias.
     * @param {categoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriaDeleteManyArgs>(args?: SelectSubset<T, categoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriaUpdateManyArgs>(args: SelectSubset<T, categoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias and returns the data updated in the database.
     * @param {categoriaUpdateManyAndReturnArgs} args - Arguments to update many Categorias.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categorias and only return the `id`
     * const categoriaWithIdOnly = await prisma.categoria.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categoria.
     * @param {categoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
     */
    upsert<T extends categoriaUpsertArgs>(args: SelectSubset<T, categoriaUpsertArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends categoriaCountArgs>(
      args?: Subset<T, categoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriaGroupByArgs['orderBy'] }
        : { orderBy?: categoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categoria model
   */
  readonly fields: categoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicio<T extends categoria$servicioArgs<ExtArgs> = {}>(args?: Subset<T, categoria$servicioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categoria model
   */
  interface categoriaFieldRefs {
    readonly id: FieldRef<"categoria", 'Int'>
    readonly nombre: FieldRef<"categoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * categoria findUnique
   */
  export type categoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where: categoriaWhereUniqueInput
  }

  /**
   * categoria findUniqueOrThrow
   */
  export type categoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where: categoriaWhereUniqueInput
  }

  /**
   * categoria findFirst
   */
  export type categoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * categoria findFirstOrThrow
   */
  export type categoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * categoria findMany
   */
  export type categoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categorias.
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * categoria create
   */
  export type categoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a categoria.
     */
    data: XOR<categoriaCreateInput, categoriaUncheckedCreateInput>
  }

  /**
   * categoria createMany
   */
  export type categoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categorias.
     */
    data: categoriaCreateManyInput | categoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categoria createManyAndReturn
   */
  export type categoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * The data used to create many categorias.
     */
    data: categoriaCreateManyInput | categoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categoria update
   */
  export type categoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a categoria.
     */
    data: XOR<categoriaUpdateInput, categoriaUncheckedUpdateInput>
    /**
     * Choose, which categoria to update.
     */
    where: categoriaWhereUniqueInput
  }

  /**
   * categoria updateMany
   */
  export type categoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriaUpdateManyMutationInput, categoriaUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriaWhereInput
    /**
     * Limit how many categorias to update.
     */
    limit?: number
  }

  /**
   * categoria updateManyAndReturn
   */
  export type categoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriaUpdateManyMutationInput, categoriaUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriaWhereInput
    /**
     * Limit how many categorias to update.
     */
    limit?: number
  }

  /**
   * categoria upsert
   */
  export type categoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the categoria to update in case it exists.
     */
    where: categoriaWhereUniqueInput
    /**
     * In case the categoria found by the `where` argument doesn't exist, create a new categoria with this data.
     */
    create: XOR<categoriaCreateInput, categoriaUncheckedCreateInput>
    /**
     * In case the categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriaUpdateInput, categoriaUncheckedUpdateInput>
  }

  /**
   * categoria delete
   */
  export type categoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter which categoria to delete.
     */
    where: categoriaWhereUniqueInput
  }

  /**
   * categoria deleteMany
   */
  export type categoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categorias to delete
     */
    where?: categoriaWhereInput
    /**
     * Limit how many categorias to delete.
     */
    limit?: number
  }

  /**
   * categoria.servicio
   */
  export type categoria$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    where?: servicioWhereInput
    orderBy?: servicioOrderByWithRelationInput | servicioOrderByWithRelationInput[]
    cursor?: servicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * categoria without action
   */
  export type categoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoria
     */
    omit?: categoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriaInclude<ExtArgs> | null
  }


  /**
   * Model cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    ci: number | null
  }

  export type ClienteSumAggregateOutputType = {
    ci: number | null
  }

  export type ClienteMinAggregateOutputType = {
    ci: number | null
    nombre: string | null
    telefono: string | null
    direccion: string | null
  }

  export type ClienteMaxAggregateOutputType = {
    ci: number | null
    nombre: string | null
    telefono: string | null
    direccion: string | null
  }

  export type ClienteCountAggregateOutputType = {
    ci: number
    nombre: number
    telefono: number
    direccion: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    ci?: true
  }

  export type ClienteSumAggregateInputType = {
    ci?: true
  }

  export type ClienteMinAggregateInputType = {
    ci?: true
    nombre?: true
    telefono?: true
    direccion?: true
  }

  export type ClienteMaxAggregateInputType = {
    ci?: true
    nombre?: true
    telefono?: true
    direccion?: true
  }

  export type ClienteCountAggregateInputType = {
    ci?: true
    nombre?: true
    telefono?: true
    direccion?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cliente to aggregate.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type clienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clienteWhereInput
    orderBy?: clienteOrderByWithAggregationInput | clienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: clienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    ci: number
    nombre: string
    telefono: string
    direccion: string
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends clienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type clienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ci?: boolean
    nombre?: boolean
    telefono?: boolean
    direccion?: boolean
    factura?: boolean | cliente$facturaArgs<ExtArgs>
    proforma?: boolean | cliente$proformaArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type clienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ci?: boolean
    nombre?: boolean
    telefono?: boolean
    direccion?: boolean
  }, ExtArgs["result"]["cliente"]>

  export type clienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ci?: boolean
    nombre?: boolean
    telefono?: boolean
    direccion?: boolean
  }, ExtArgs["result"]["cliente"]>

  export type clienteSelectScalar = {
    ci?: boolean
    nombre?: boolean
    telefono?: boolean
    direccion?: boolean
  }

  export type clienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ci" | "nombre" | "telefono" | "direccion", ExtArgs["result"]["cliente"]>
  export type clienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    factura?: boolean | cliente$facturaArgs<ExtArgs>
    proforma?: boolean | cliente$proformaArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type clienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $clientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cliente"
    objects: {
      factura: Prisma.$facturaPayload<ExtArgs>[]
      proforma: Prisma.$proformaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ci: number
      nombre: string
      telefono: string
      direccion: string
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type clienteGetPayload<S extends boolean | null | undefined | clienteDefaultArgs> = $Result.GetResult<Prisma.$clientePayload, S>

  type clienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface clienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cliente'], meta: { name: 'cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {clienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clienteFindUniqueArgs>(args: SelectSubset<T, clienteFindUniqueArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clienteFindUniqueOrThrowArgs>(args: SelectSubset<T, clienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clienteFindFirstArgs>(args?: SelectSubset<T, clienteFindFirstArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clienteFindFirstOrThrowArgs>(args?: SelectSubset<T, clienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `ci`
     * const clienteWithCiOnly = await prisma.cliente.findMany({ select: { ci: true } })
     * 
     */
    findMany<T extends clienteFindManyArgs>(args?: SelectSubset<T, clienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cliente.
     * @param {clienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends clienteCreateArgs>(args: SelectSubset<T, clienteCreateArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clientes.
     * @param {clienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clienteCreateManyArgs>(args?: SelectSubset<T, clienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {clienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `ci`
     * const clienteWithCiOnly = await prisma.cliente.createManyAndReturn({
     *   select: { ci: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clienteCreateManyAndReturnArgs>(args?: SelectSubset<T, clienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cliente.
     * @param {clienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends clienteDeleteArgs>(args: SelectSubset<T, clienteDeleteArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cliente.
     * @param {clienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clienteUpdateArgs>(args: SelectSubset<T, clienteUpdateArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clientes.
     * @param {clienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clienteDeleteManyArgs>(args?: SelectSubset<T, clienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clienteUpdateManyArgs>(args: SelectSubset<T, clienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes and returns the data updated in the database.
     * @param {clienteUpdateManyAndReturnArgs} args - Arguments to update many Clientes.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clientes and only return the `ci`
     * const clienteWithCiOnly = await prisma.cliente.updateManyAndReturn({
     *   select: { ci: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clienteUpdateManyAndReturnArgs>(args: SelectSubset<T, clienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cliente.
     * @param {clienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends clienteUpsertArgs>(args: SelectSubset<T, clienteUpsertArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends clienteCountArgs>(
      args?: Subset<T, clienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clienteGroupByArgs['orderBy'] }
        : { orderBy?: clienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cliente model
   */
  readonly fields: clienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    factura<T extends cliente$facturaArgs<ExtArgs> = {}>(args?: Subset<T, cliente$facturaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proforma<T extends cliente$proformaArgs<ExtArgs> = {}>(args?: Subset<T, cliente$proformaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cliente model
   */
  interface clienteFieldRefs {
    readonly ci: FieldRef<"cliente", 'Int'>
    readonly nombre: FieldRef<"cliente", 'String'>
    readonly telefono: FieldRef<"cliente", 'String'>
    readonly direccion: FieldRef<"cliente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cliente findUnique
   */
  export type clienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where: clienteWhereUniqueInput
  }

  /**
   * cliente findUniqueOrThrow
   */
  export type clienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where: clienteWhereUniqueInput
  }

  /**
   * cliente findFirst
   */
  export type clienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * cliente findFirstOrThrow
   */
  export type clienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * cliente findMany
   */
  export type clienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientes.
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * cliente create
   */
  export type clienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * The data needed to create a cliente.
     */
    data: XOR<clienteCreateInput, clienteUncheckedCreateInput>
  }

  /**
   * cliente createMany
   */
  export type clienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clientes.
     */
    data: clienteCreateManyInput | clienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cliente createManyAndReturn
   */
  export type clienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * The data used to create many clientes.
     */
    data: clienteCreateManyInput | clienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cliente update
   */
  export type clienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * The data needed to update a cliente.
     */
    data: XOR<clienteUpdateInput, clienteUncheckedUpdateInput>
    /**
     * Choose, which cliente to update.
     */
    where: clienteWhereUniqueInput
  }

  /**
   * cliente updateMany
   */
  export type clienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clientes.
     */
    data: XOR<clienteUpdateManyMutationInput, clienteUncheckedUpdateManyInput>
    /**
     * Filter which clientes to update
     */
    where?: clienteWhereInput
    /**
     * Limit how many clientes to update.
     */
    limit?: number
  }

  /**
   * cliente updateManyAndReturn
   */
  export type clienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * The data used to update clientes.
     */
    data: XOR<clienteUpdateManyMutationInput, clienteUncheckedUpdateManyInput>
    /**
     * Filter which clientes to update
     */
    where?: clienteWhereInput
    /**
     * Limit how many clientes to update.
     */
    limit?: number
  }

  /**
   * cliente upsert
   */
  export type clienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * The filter to search for the cliente to update in case it exists.
     */
    where: clienteWhereUniqueInput
    /**
     * In case the cliente found by the `where` argument doesn't exist, create a new cliente with this data.
     */
    create: XOR<clienteCreateInput, clienteUncheckedCreateInput>
    /**
     * In case the cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clienteUpdateInput, clienteUncheckedUpdateInput>
  }

  /**
   * cliente delete
   */
  export type clienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter which cliente to delete.
     */
    where: clienteWhereUniqueInput
  }

  /**
   * cliente deleteMany
   */
  export type clienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientes to delete
     */
    where?: clienteWhereInput
    /**
     * Limit how many clientes to delete.
     */
    limit?: number
  }

  /**
   * cliente.factura
   */
  export type cliente$facturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
    where?: facturaWhereInput
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    cursor?: facturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }

  /**
   * cliente.proforma
   */
  export type cliente$proformaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    where?: proformaWhereInput
    orderBy?: proformaOrderByWithRelationInput | proformaOrderByWithRelationInput[]
    cursor?: proformaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProformaScalarFieldEnum | ProformaScalarFieldEnum[]
  }

  /**
   * cliente without action
   */
  export type clienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cliente
     */
    omit?: clienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clienteInclude<ExtArgs> | null
  }


  /**
   * Model comision
   */

  export type AggregateComision = {
    _count: ComisionCountAggregateOutputType | null
    _avg: ComisionAvgAggregateOutputType | null
    _sum: ComisionSumAggregateOutputType | null
    _min: ComisionMinAggregateOutputType | null
    _max: ComisionMaxAggregateOutputType | null
  }

  export type ComisionAvgAggregateOutputType = {
    id: number | null
    orden_id: number | null
    monto: Decimal | null
  }

  export type ComisionSumAggregateOutputType = {
    id: number | null
    orden_id: bigint | null
    monto: Decimal | null
  }

  export type ComisionMinAggregateOutputType = {
    id: number | null
    orden_id: bigint | null
    monto: Decimal | null
    estado_pago: $Enums.estado_pago | null
    fecha_pago: Date | null
  }

  export type ComisionMaxAggregateOutputType = {
    id: number | null
    orden_id: bigint | null
    monto: Decimal | null
    estado_pago: $Enums.estado_pago | null
    fecha_pago: Date | null
  }

  export type ComisionCountAggregateOutputType = {
    id: number
    orden_id: number
    monto: number
    estado_pago: number
    fecha_pago: number
    _all: number
  }


  export type ComisionAvgAggregateInputType = {
    id?: true
    orden_id?: true
    monto?: true
  }

  export type ComisionSumAggregateInputType = {
    id?: true
    orden_id?: true
    monto?: true
  }

  export type ComisionMinAggregateInputType = {
    id?: true
    orden_id?: true
    monto?: true
    estado_pago?: true
    fecha_pago?: true
  }

  export type ComisionMaxAggregateInputType = {
    id?: true
    orden_id?: true
    monto?: true
    estado_pago?: true
    fecha_pago?: true
  }

  export type ComisionCountAggregateInputType = {
    id?: true
    orden_id?: true
    monto?: true
    estado_pago?: true
    fecha_pago?: true
    _all?: true
  }

  export type ComisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comision to aggregate.
     */
    where?: comisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comisions to fetch.
     */
    orderBy?: comisionOrderByWithRelationInput | comisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comisions
    **/
    _count?: true | ComisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComisionMaxAggregateInputType
  }

  export type GetComisionAggregateType<T extends ComisionAggregateArgs> = {
        [P in keyof T & keyof AggregateComision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComision[P]>
      : GetScalarType<T[P], AggregateComision[P]>
  }




  export type comisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comisionWhereInput
    orderBy?: comisionOrderByWithAggregationInput | comisionOrderByWithAggregationInput[]
    by: ComisionScalarFieldEnum[] | ComisionScalarFieldEnum
    having?: comisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComisionCountAggregateInputType | true
    _avg?: ComisionAvgAggregateInputType
    _sum?: ComisionSumAggregateInputType
    _min?: ComisionMinAggregateInputType
    _max?: ComisionMaxAggregateInputType
  }

  export type ComisionGroupByOutputType = {
    id: number
    orden_id: bigint | null
    monto: Decimal
    estado_pago: $Enums.estado_pago
    fecha_pago: Date | null
    _count: ComisionCountAggregateOutputType | null
    _avg: ComisionAvgAggregateOutputType | null
    _sum: ComisionSumAggregateOutputType | null
    _min: ComisionMinAggregateOutputType | null
    _max: ComisionMaxAggregateOutputType | null
  }

  type GetComisionGroupByPayload<T extends comisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComisionGroupByOutputType[P]>
            : GetScalarType<T[P], ComisionGroupByOutputType[P]>
        }
      >
    >


  export type comisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orden_id?: boolean
    monto?: boolean
    estado_pago?: boolean
    fecha_pago?: boolean
    orden_trabajo?: boolean | comision$orden_trabajoArgs<ExtArgs>
  }, ExtArgs["result"]["comision"]>

  export type comisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orden_id?: boolean
    monto?: boolean
    estado_pago?: boolean
    fecha_pago?: boolean
    orden_trabajo?: boolean | comision$orden_trabajoArgs<ExtArgs>
  }, ExtArgs["result"]["comision"]>

  export type comisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orden_id?: boolean
    monto?: boolean
    estado_pago?: boolean
    fecha_pago?: boolean
    orden_trabajo?: boolean | comision$orden_trabajoArgs<ExtArgs>
  }, ExtArgs["result"]["comision"]>

  export type comisionSelectScalar = {
    id?: boolean
    orden_id?: boolean
    monto?: boolean
    estado_pago?: boolean
    fecha_pago?: boolean
  }

  export type comisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orden_id" | "monto" | "estado_pago" | "fecha_pago", ExtArgs["result"]["comision"]>
  export type comisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden_trabajo?: boolean | comision$orden_trabajoArgs<ExtArgs>
  }
  export type comisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden_trabajo?: boolean | comision$orden_trabajoArgs<ExtArgs>
  }
  export type comisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orden_trabajo?: boolean | comision$orden_trabajoArgs<ExtArgs>
  }

  export type $comisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comision"
    objects: {
      orden_trabajo: Prisma.$orden_trabajoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orden_id: bigint | null
      monto: Prisma.Decimal
      estado_pago: $Enums.estado_pago
      fecha_pago: Date | null
    }, ExtArgs["result"]["comision"]>
    composites: {}
  }

  type comisionGetPayload<S extends boolean | null | undefined | comisionDefaultArgs> = $Result.GetResult<Prisma.$comisionPayload, S>

  type comisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<comisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComisionCountAggregateInputType | true
    }

  export interface comisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comision'], meta: { name: 'comision' } }
    /**
     * Find zero or one Comision that matches the filter.
     * @param {comisionFindUniqueArgs} args - Arguments to find a Comision
     * @example
     * // Get one Comision
     * const comision = await prisma.comision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comisionFindUniqueArgs>(args: SelectSubset<T, comisionFindUniqueArgs<ExtArgs>>): Prisma__comisionClient<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {comisionFindUniqueOrThrowArgs} args - Arguments to find a Comision
     * @example
     * // Get one Comision
     * const comision = await prisma.comision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comisionFindUniqueOrThrowArgs>(args: SelectSubset<T, comisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comisionClient<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comisionFindFirstArgs} args - Arguments to find a Comision
     * @example
     * // Get one Comision
     * const comision = await prisma.comision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comisionFindFirstArgs>(args?: SelectSubset<T, comisionFindFirstArgs<ExtArgs>>): Prisma__comisionClient<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comisionFindFirstOrThrowArgs} args - Arguments to find a Comision
     * @example
     * // Get one Comision
     * const comision = await prisma.comision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comisionFindFirstOrThrowArgs>(args?: SelectSubset<T, comisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__comisionClient<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comisions
     * const comisions = await prisma.comision.findMany()
     * 
     * // Get first 10 Comisions
     * const comisions = await prisma.comision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comisionWithIdOnly = await prisma.comision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends comisionFindManyArgs>(args?: SelectSubset<T, comisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comision.
     * @param {comisionCreateArgs} args - Arguments to create a Comision.
     * @example
     * // Create one Comision
     * const Comision = await prisma.comision.create({
     *   data: {
     *     // ... data to create a Comision
     *   }
     * })
     * 
     */
    create<T extends comisionCreateArgs>(args: SelectSubset<T, comisionCreateArgs<ExtArgs>>): Prisma__comisionClient<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comisions.
     * @param {comisionCreateManyArgs} args - Arguments to create many Comisions.
     * @example
     * // Create many Comisions
     * const comision = await prisma.comision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comisionCreateManyArgs>(args?: SelectSubset<T, comisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comisions and returns the data saved in the database.
     * @param {comisionCreateManyAndReturnArgs} args - Arguments to create many Comisions.
     * @example
     * // Create many Comisions
     * const comision = await prisma.comision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comisions and only return the `id`
     * const comisionWithIdOnly = await prisma.comision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends comisionCreateManyAndReturnArgs>(args?: SelectSubset<T, comisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comision.
     * @param {comisionDeleteArgs} args - Arguments to delete one Comision.
     * @example
     * // Delete one Comision
     * const Comision = await prisma.comision.delete({
     *   where: {
     *     // ... filter to delete one Comision
     *   }
     * })
     * 
     */
    delete<T extends comisionDeleteArgs>(args: SelectSubset<T, comisionDeleteArgs<ExtArgs>>): Prisma__comisionClient<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comision.
     * @param {comisionUpdateArgs} args - Arguments to update one Comision.
     * @example
     * // Update one Comision
     * const comision = await prisma.comision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comisionUpdateArgs>(args: SelectSubset<T, comisionUpdateArgs<ExtArgs>>): Prisma__comisionClient<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comisions.
     * @param {comisionDeleteManyArgs} args - Arguments to filter Comisions to delete.
     * @example
     * // Delete a few Comisions
     * const { count } = await prisma.comision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comisionDeleteManyArgs>(args?: SelectSubset<T, comisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comisions
     * const comision = await prisma.comision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comisionUpdateManyArgs>(args: SelectSubset<T, comisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comisions and returns the data updated in the database.
     * @param {comisionUpdateManyAndReturnArgs} args - Arguments to update many Comisions.
     * @example
     * // Update many Comisions
     * const comision = await prisma.comision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comisions and only return the `id`
     * const comisionWithIdOnly = await prisma.comision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends comisionUpdateManyAndReturnArgs>(args: SelectSubset<T, comisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comision.
     * @param {comisionUpsertArgs} args - Arguments to update or create a Comision.
     * @example
     * // Update or create a Comision
     * const comision = await prisma.comision.upsert({
     *   create: {
     *     // ... data to create a Comision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comision we want to update
     *   }
     * })
     */
    upsert<T extends comisionUpsertArgs>(args: SelectSubset<T, comisionUpsertArgs<ExtArgs>>): Prisma__comisionClient<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comisionCountArgs} args - Arguments to filter Comisions to count.
     * @example
     * // Count the number of Comisions
     * const count = await prisma.comision.count({
     *   where: {
     *     // ... the filter for the Comisions we want to count
     *   }
     * })
    **/
    count<T extends comisionCountArgs>(
      args?: Subset<T, comisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComisionAggregateArgs>(args: Subset<T, ComisionAggregateArgs>): Prisma.PrismaPromise<GetComisionAggregateType<T>>

    /**
     * Group by Comision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comisionGroupByArgs['orderBy'] }
        : { orderBy?: comisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comision model
   */
  readonly fields: comisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orden_trabajo<T extends comision$orden_trabajoArgs<ExtArgs> = {}>(args?: Subset<T, comision$orden_trabajoArgs<ExtArgs>>): Prisma__orden_trabajoClient<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comision model
   */
  interface comisionFieldRefs {
    readonly id: FieldRef<"comision", 'Int'>
    readonly orden_id: FieldRef<"comision", 'BigInt'>
    readonly monto: FieldRef<"comision", 'Decimal'>
    readonly estado_pago: FieldRef<"comision", 'estado_pago'>
    readonly fecha_pago: FieldRef<"comision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * comision findUnique
   */
  export type comisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
    /**
     * Filter, which comision to fetch.
     */
    where: comisionWhereUniqueInput
  }

  /**
   * comision findUniqueOrThrow
   */
  export type comisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
    /**
     * Filter, which comision to fetch.
     */
    where: comisionWhereUniqueInput
  }

  /**
   * comision findFirst
   */
  export type comisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
    /**
     * Filter, which comision to fetch.
     */
    where?: comisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comisions to fetch.
     */
    orderBy?: comisionOrderByWithRelationInput | comisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comisions.
     */
    cursor?: comisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comisions.
     */
    distinct?: ComisionScalarFieldEnum | ComisionScalarFieldEnum[]
  }

  /**
   * comision findFirstOrThrow
   */
  export type comisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
    /**
     * Filter, which comision to fetch.
     */
    where?: comisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comisions to fetch.
     */
    orderBy?: comisionOrderByWithRelationInput | comisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comisions.
     */
    cursor?: comisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comisions.
     */
    distinct?: ComisionScalarFieldEnum | ComisionScalarFieldEnum[]
  }

  /**
   * comision findMany
   */
  export type comisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
    /**
     * Filter, which comisions to fetch.
     */
    where?: comisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comisions to fetch.
     */
    orderBy?: comisionOrderByWithRelationInput | comisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comisions.
     */
    cursor?: comisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comisions.
     */
    skip?: number
    distinct?: ComisionScalarFieldEnum | ComisionScalarFieldEnum[]
  }

  /**
   * comision create
   */
  export type comisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
    /**
     * The data needed to create a comision.
     */
    data: XOR<comisionCreateInput, comisionUncheckedCreateInput>
  }

  /**
   * comision createMany
   */
  export type comisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comisions.
     */
    data: comisionCreateManyInput | comisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comision createManyAndReturn
   */
  export type comisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * The data used to create many comisions.
     */
    data: comisionCreateManyInput | comisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comision update
   */
  export type comisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
    /**
     * The data needed to update a comision.
     */
    data: XOR<comisionUpdateInput, comisionUncheckedUpdateInput>
    /**
     * Choose, which comision to update.
     */
    where: comisionWhereUniqueInput
  }

  /**
   * comision updateMany
   */
  export type comisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comisions.
     */
    data: XOR<comisionUpdateManyMutationInput, comisionUncheckedUpdateManyInput>
    /**
     * Filter which comisions to update
     */
    where?: comisionWhereInput
    /**
     * Limit how many comisions to update.
     */
    limit?: number
  }

  /**
   * comision updateManyAndReturn
   */
  export type comisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * The data used to update comisions.
     */
    data: XOR<comisionUpdateManyMutationInput, comisionUncheckedUpdateManyInput>
    /**
     * Filter which comisions to update
     */
    where?: comisionWhereInput
    /**
     * Limit how many comisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * comision upsert
   */
  export type comisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
    /**
     * The filter to search for the comision to update in case it exists.
     */
    where: comisionWhereUniqueInput
    /**
     * In case the comision found by the `where` argument doesn't exist, create a new comision with this data.
     */
    create: XOR<comisionCreateInput, comisionUncheckedCreateInput>
    /**
     * In case the comision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comisionUpdateInput, comisionUncheckedUpdateInput>
  }

  /**
   * comision delete
   */
  export type comisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
    /**
     * Filter which comision to delete.
     */
    where: comisionWhereUniqueInput
  }

  /**
   * comision deleteMany
   */
  export type comisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comisions to delete
     */
    where?: comisionWhereInput
    /**
     * Limit how many comisions to delete.
     */
    limit?: number
  }

  /**
   * comision.orden_trabajo
   */
  export type comision$orden_trabajoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    where?: orden_trabajoWhereInput
  }

  /**
   * comision without action
   */
  export type comisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
  }


  /**
   * Model detalle_diagnostico
   */

  export type AggregateDetalle_diagnostico = {
    _count: Detalle_diagnosticoCountAggregateOutputType | null
    _avg: Detalle_diagnosticoAvgAggregateOutputType | null
    _sum: Detalle_diagnosticoSumAggregateOutputType | null
    _min: Detalle_diagnosticoMinAggregateOutputType | null
    _max: Detalle_diagnosticoMaxAggregateOutputType | null
  }

  export type Detalle_diagnosticoAvgAggregateOutputType = {
    id: number | null
    diagnostico_id: number | null
  }

  export type Detalle_diagnosticoSumAggregateOutputType = {
    id: bigint | null
    diagnostico_id: bigint | null
  }

  export type Detalle_diagnosticoMinAggregateOutputType = {
    id: bigint | null
    diagnostico_id: bigint | null
    descripcion: string | null
  }

  export type Detalle_diagnosticoMaxAggregateOutputType = {
    id: bigint | null
    diagnostico_id: bigint | null
    descripcion: string | null
  }

  export type Detalle_diagnosticoCountAggregateOutputType = {
    id: number
    diagnostico_id: number
    descripcion: number
    _all: number
  }


  export type Detalle_diagnosticoAvgAggregateInputType = {
    id?: true
    diagnostico_id?: true
  }

  export type Detalle_diagnosticoSumAggregateInputType = {
    id?: true
    diagnostico_id?: true
  }

  export type Detalle_diagnosticoMinAggregateInputType = {
    id?: true
    diagnostico_id?: true
    descripcion?: true
  }

  export type Detalle_diagnosticoMaxAggregateInputType = {
    id?: true
    diagnostico_id?: true
    descripcion?: true
  }

  export type Detalle_diagnosticoCountAggregateInputType = {
    id?: true
    diagnostico_id?: true
    descripcion?: true
    _all?: true
  }

  export type Detalle_diagnosticoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_diagnostico to aggregate.
     */
    where?: detalle_diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_diagnosticos to fetch.
     */
    orderBy?: detalle_diagnosticoOrderByWithRelationInput | detalle_diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detalle_diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_diagnosticos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detalle_diagnosticos
    **/
    _count?: true | Detalle_diagnosticoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detalle_diagnosticoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detalle_diagnosticoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detalle_diagnosticoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detalle_diagnosticoMaxAggregateInputType
  }

  export type GetDetalle_diagnosticoAggregateType<T extends Detalle_diagnosticoAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalle_diagnostico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalle_diagnostico[P]>
      : GetScalarType<T[P], AggregateDetalle_diagnostico[P]>
  }




  export type detalle_diagnosticoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_diagnosticoWhereInput
    orderBy?: detalle_diagnosticoOrderByWithAggregationInput | detalle_diagnosticoOrderByWithAggregationInput[]
    by: Detalle_diagnosticoScalarFieldEnum[] | Detalle_diagnosticoScalarFieldEnum
    having?: detalle_diagnosticoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detalle_diagnosticoCountAggregateInputType | true
    _avg?: Detalle_diagnosticoAvgAggregateInputType
    _sum?: Detalle_diagnosticoSumAggregateInputType
    _min?: Detalle_diagnosticoMinAggregateInputType
    _max?: Detalle_diagnosticoMaxAggregateInputType
  }

  export type Detalle_diagnosticoGroupByOutputType = {
    id: bigint
    diagnostico_id: bigint
    descripcion: string
    _count: Detalle_diagnosticoCountAggregateOutputType | null
    _avg: Detalle_diagnosticoAvgAggregateOutputType | null
    _sum: Detalle_diagnosticoSumAggregateOutputType | null
    _min: Detalle_diagnosticoMinAggregateOutputType | null
    _max: Detalle_diagnosticoMaxAggregateOutputType | null
  }

  type GetDetalle_diagnosticoGroupByPayload<T extends detalle_diagnosticoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detalle_diagnosticoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detalle_diagnosticoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detalle_diagnosticoGroupByOutputType[P]>
            : GetScalarType<T[P], Detalle_diagnosticoGroupByOutputType[P]>
        }
      >
    >


  export type detalle_diagnosticoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnostico_id?: boolean
    descripcion?: boolean
    diagnostico?: boolean | diagnosticoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_diagnostico"]>

  export type detalle_diagnosticoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnostico_id?: boolean
    descripcion?: boolean
    diagnostico?: boolean | diagnosticoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_diagnostico"]>

  export type detalle_diagnosticoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnostico_id?: boolean
    descripcion?: boolean
    diagnostico?: boolean | diagnosticoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_diagnostico"]>

  export type detalle_diagnosticoSelectScalar = {
    id?: boolean
    diagnostico_id?: boolean
    descripcion?: boolean
  }

  export type detalle_diagnosticoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "diagnostico_id" | "descripcion", ExtArgs["result"]["detalle_diagnostico"]>
  export type detalle_diagnosticoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostico?: boolean | diagnosticoDefaultArgs<ExtArgs>
  }
  export type detalle_diagnosticoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostico?: boolean | diagnosticoDefaultArgs<ExtArgs>
  }
  export type detalle_diagnosticoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostico?: boolean | diagnosticoDefaultArgs<ExtArgs>
  }

  export type $detalle_diagnosticoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "detalle_diagnostico"
    objects: {
      diagnostico: Prisma.$diagnosticoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      diagnostico_id: bigint
      descripcion: string
    }, ExtArgs["result"]["detalle_diagnostico"]>
    composites: {}
  }

  type detalle_diagnosticoGetPayload<S extends boolean | null | undefined | detalle_diagnosticoDefaultArgs> = $Result.GetResult<Prisma.$detalle_diagnosticoPayload, S>

  type detalle_diagnosticoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<detalle_diagnosticoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Detalle_diagnosticoCountAggregateInputType | true
    }

  export interface detalle_diagnosticoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detalle_diagnostico'], meta: { name: 'detalle_diagnostico' } }
    /**
     * Find zero or one Detalle_diagnostico that matches the filter.
     * @param {detalle_diagnosticoFindUniqueArgs} args - Arguments to find a Detalle_diagnostico
     * @example
     * // Get one Detalle_diagnostico
     * const detalle_diagnostico = await prisma.detalle_diagnostico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends detalle_diagnosticoFindUniqueArgs>(args: SelectSubset<T, detalle_diagnosticoFindUniqueArgs<ExtArgs>>): Prisma__detalle_diagnosticoClient<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Detalle_diagnostico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {detalle_diagnosticoFindUniqueOrThrowArgs} args - Arguments to find a Detalle_diagnostico
     * @example
     * // Get one Detalle_diagnostico
     * const detalle_diagnostico = await prisma.detalle_diagnostico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends detalle_diagnosticoFindUniqueOrThrowArgs>(args: SelectSubset<T, detalle_diagnosticoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__detalle_diagnosticoClient<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Detalle_diagnostico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_diagnosticoFindFirstArgs} args - Arguments to find a Detalle_diagnostico
     * @example
     * // Get one Detalle_diagnostico
     * const detalle_diagnostico = await prisma.detalle_diagnostico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends detalle_diagnosticoFindFirstArgs>(args?: SelectSubset<T, detalle_diagnosticoFindFirstArgs<ExtArgs>>): Prisma__detalle_diagnosticoClient<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Detalle_diagnostico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_diagnosticoFindFirstOrThrowArgs} args - Arguments to find a Detalle_diagnostico
     * @example
     * // Get one Detalle_diagnostico
     * const detalle_diagnostico = await prisma.detalle_diagnostico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends detalle_diagnosticoFindFirstOrThrowArgs>(args?: SelectSubset<T, detalle_diagnosticoFindFirstOrThrowArgs<ExtArgs>>): Prisma__detalle_diagnosticoClient<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Detalle_diagnosticos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_diagnosticoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detalle_diagnosticos
     * const detalle_diagnosticos = await prisma.detalle_diagnostico.findMany()
     * 
     * // Get first 10 Detalle_diagnosticos
     * const detalle_diagnosticos = await prisma.detalle_diagnostico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detalle_diagnosticoWithIdOnly = await prisma.detalle_diagnostico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends detalle_diagnosticoFindManyArgs>(args?: SelectSubset<T, detalle_diagnosticoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Detalle_diagnostico.
     * @param {detalle_diagnosticoCreateArgs} args - Arguments to create a Detalle_diagnostico.
     * @example
     * // Create one Detalle_diagnostico
     * const Detalle_diagnostico = await prisma.detalle_diagnostico.create({
     *   data: {
     *     // ... data to create a Detalle_diagnostico
     *   }
     * })
     * 
     */
    create<T extends detalle_diagnosticoCreateArgs>(args: SelectSubset<T, detalle_diagnosticoCreateArgs<ExtArgs>>): Prisma__detalle_diagnosticoClient<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Detalle_diagnosticos.
     * @param {detalle_diagnosticoCreateManyArgs} args - Arguments to create many Detalle_diagnosticos.
     * @example
     * // Create many Detalle_diagnosticos
     * const detalle_diagnostico = await prisma.detalle_diagnostico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends detalle_diagnosticoCreateManyArgs>(args?: SelectSubset<T, detalle_diagnosticoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Detalle_diagnosticos and returns the data saved in the database.
     * @param {detalle_diagnosticoCreateManyAndReturnArgs} args - Arguments to create many Detalle_diagnosticos.
     * @example
     * // Create many Detalle_diagnosticos
     * const detalle_diagnostico = await prisma.detalle_diagnostico.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Detalle_diagnosticos and only return the `id`
     * const detalle_diagnosticoWithIdOnly = await prisma.detalle_diagnostico.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends detalle_diagnosticoCreateManyAndReturnArgs>(args?: SelectSubset<T, detalle_diagnosticoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Detalle_diagnostico.
     * @param {detalle_diagnosticoDeleteArgs} args - Arguments to delete one Detalle_diagnostico.
     * @example
     * // Delete one Detalle_diagnostico
     * const Detalle_diagnostico = await prisma.detalle_diagnostico.delete({
     *   where: {
     *     // ... filter to delete one Detalle_diagnostico
     *   }
     * })
     * 
     */
    delete<T extends detalle_diagnosticoDeleteArgs>(args: SelectSubset<T, detalle_diagnosticoDeleteArgs<ExtArgs>>): Prisma__detalle_diagnosticoClient<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Detalle_diagnostico.
     * @param {detalle_diagnosticoUpdateArgs} args - Arguments to update one Detalle_diagnostico.
     * @example
     * // Update one Detalle_diagnostico
     * const detalle_diagnostico = await prisma.detalle_diagnostico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends detalle_diagnosticoUpdateArgs>(args: SelectSubset<T, detalle_diagnosticoUpdateArgs<ExtArgs>>): Prisma__detalle_diagnosticoClient<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Detalle_diagnosticos.
     * @param {detalle_diagnosticoDeleteManyArgs} args - Arguments to filter Detalle_diagnosticos to delete.
     * @example
     * // Delete a few Detalle_diagnosticos
     * const { count } = await prisma.detalle_diagnostico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends detalle_diagnosticoDeleteManyArgs>(args?: SelectSubset<T, detalle_diagnosticoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detalle_diagnosticos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_diagnosticoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detalle_diagnosticos
     * const detalle_diagnostico = await prisma.detalle_diagnostico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends detalle_diagnosticoUpdateManyArgs>(args: SelectSubset<T, detalle_diagnosticoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detalle_diagnosticos and returns the data updated in the database.
     * @param {detalle_diagnosticoUpdateManyAndReturnArgs} args - Arguments to update many Detalle_diagnosticos.
     * @example
     * // Update many Detalle_diagnosticos
     * const detalle_diagnostico = await prisma.detalle_diagnostico.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Detalle_diagnosticos and only return the `id`
     * const detalle_diagnosticoWithIdOnly = await prisma.detalle_diagnostico.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends detalle_diagnosticoUpdateManyAndReturnArgs>(args: SelectSubset<T, detalle_diagnosticoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Detalle_diagnostico.
     * @param {detalle_diagnosticoUpsertArgs} args - Arguments to update or create a Detalle_diagnostico.
     * @example
     * // Update or create a Detalle_diagnostico
     * const detalle_diagnostico = await prisma.detalle_diagnostico.upsert({
     *   create: {
     *     // ... data to create a Detalle_diagnostico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detalle_diagnostico we want to update
     *   }
     * })
     */
    upsert<T extends detalle_diagnosticoUpsertArgs>(args: SelectSubset<T, detalle_diagnosticoUpsertArgs<ExtArgs>>): Prisma__detalle_diagnosticoClient<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Detalle_diagnosticos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_diagnosticoCountArgs} args - Arguments to filter Detalle_diagnosticos to count.
     * @example
     * // Count the number of Detalle_diagnosticos
     * const count = await prisma.detalle_diagnostico.count({
     *   where: {
     *     // ... the filter for the Detalle_diagnosticos we want to count
     *   }
     * })
    **/
    count<T extends detalle_diagnosticoCountArgs>(
      args?: Subset<T, detalle_diagnosticoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detalle_diagnosticoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detalle_diagnostico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detalle_diagnosticoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detalle_diagnosticoAggregateArgs>(args: Subset<T, Detalle_diagnosticoAggregateArgs>): Prisma.PrismaPromise<GetDetalle_diagnosticoAggregateType<T>>

    /**
     * Group by Detalle_diagnostico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_diagnosticoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detalle_diagnosticoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detalle_diagnosticoGroupByArgs['orderBy'] }
        : { orderBy?: detalle_diagnosticoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detalle_diagnosticoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalle_diagnosticoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detalle_diagnostico model
   */
  readonly fields: detalle_diagnosticoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detalle_diagnostico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detalle_diagnosticoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diagnostico<T extends diagnosticoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, diagnosticoDefaultArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the detalle_diagnostico model
   */
  interface detalle_diagnosticoFieldRefs {
    readonly id: FieldRef<"detalle_diagnostico", 'BigInt'>
    readonly diagnostico_id: FieldRef<"detalle_diagnostico", 'BigInt'>
    readonly descripcion: FieldRef<"detalle_diagnostico", 'String'>
  }
    

  // Custom InputTypes
  /**
   * detalle_diagnostico findUnique
   */
  export type detalle_diagnosticoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which detalle_diagnostico to fetch.
     */
    where: detalle_diagnosticoWhereUniqueInput
  }

  /**
   * detalle_diagnostico findUniqueOrThrow
   */
  export type detalle_diagnosticoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which detalle_diagnostico to fetch.
     */
    where: detalle_diagnosticoWhereUniqueInput
  }

  /**
   * detalle_diagnostico findFirst
   */
  export type detalle_diagnosticoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which detalle_diagnostico to fetch.
     */
    where?: detalle_diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_diagnosticos to fetch.
     */
    orderBy?: detalle_diagnosticoOrderByWithRelationInput | detalle_diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_diagnosticos.
     */
    cursor?: detalle_diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_diagnosticos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_diagnosticos.
     */
    distinct?: Detalle_diagnosticoScalarFieldEnum | Detalle_diagnosticoScalarFieldEnum[]
  }

  /**
   * detalle_diagnostico findFirstOrThrow
   */
  export type detalle_diagnosticoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which detalle_diagnostico to fetch.
     */
    where?: detalle_diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_diagnosticos to fetch.
     */
    orderBy?: detalle_diagnosticoOrderByWithRelationInput | detalle_diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_diagnosticos.
     */
    cursor?: detalle_diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_diagnosticos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_diagnosticos.
     */
    distinct?: Detalle_diagnosticoScalarFieldEnum | Detalle_diagnosticoScalarFieldEnum[]
  }

  /**
   * detalle_diagnostico findMany
   */
  export type detalle_diagnosticoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which detalle_diagnosticos to fetch.
     */
    where?: detalle_diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_diagnosticos to fetch.
     */
    orderBy?: detalle_diagnosticoOrderByWithRelationInput | detalle_diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detalle_diagnosticos.
     */
    cursor?: detalle_diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_diagnosticos.
     */
    skip?: number
    distinct?: Detalle_diagnosticoScalarFieldEnum | Detalle_diagnosticoScalarFieldEnum[]
  }

  /**
   * detalle_diagnostico create
   */
  export type detalle_diagnosticoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
    /**
     * The data needed to create a detalle_diagnostico.
     */
    data: XOR<detalle_diagnosticoCreateInput, detalle_diagnosticoUncheckedCreateInput>
  }

  /**
   * detalle_diagnostico createMany
   */
  export type detalle_diagnosticoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detalle_diagnosticos.
     */
    data: detalle_diagnosticoCreateManyInput | detalle_diagnosticoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * detalle_diagnostico createManyAndReturn
   */
  export type detalle_diagnosticoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * The data used to create many detalle_diagnosticos.
     */
    data: detalle_diagnosticoCreateManyInput | detalle_diagnosticoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * detalle_diagnostico update
   */
  export type detalle_diagnosticoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
    /**
     * The data needed to update a detalle_diagnostico.
     */
    data: XOR<detalle_diagnosticoUpdateInput, detalle_diagnosticoUncheckedUpdateInput>
    /**
     * Choose, which detalle_diagnostico to update.
     */
    where: detalle_diagnosticoWhereUniqueInput
  }

  /**
   * detalle_diagnostico updateMany
   */
  export type detalle_diagnosticoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detalle_diagnosticos.
     */
    data: XOR<detalle_diagnosticoUpdateManyMutationInput, detalle_diagnosticoUncheckedUpdateManyInput>
    /**
     * Filter which detalle_diagnosticos to update
     */
    where?: detalle_diagnosticoWhereInput
    /**
     * Limit how many detalle_diagnosticos to update.
     */
    limit?: number
  }

  /**
   * detalle_diagnostico updateManyAndReturn
   */
  export type detalle_diagnosticoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * The data used to update detalle_diagnosticos.
     */
    data: XOR<detalle_diagnosticoUpdateManyMutationInput, detalle_diagnosticoUncheckedUpdateManyInput>
    /**
     * Filter which detalle_diagnosticos to update
     */
    where?: detalle_diagnosticoWhereInput
    /**
     * Limit how many detalle_diagnosticos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * detalle_diagnostico upsert
   */
  export type detalle_diagnosticoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
    /**
     * The filter to search for the detalle_diagnostico to update in case it exists.
     */
    where: detalle_diagnosticoWhereUniqueInput
    /**
     * In case the detalle_diagnostico found by the `where` argument doesn't exist, create a new detalle_diagnostico with this data.
     */
    create: XOR<detalle_diagnosticoCreateInput, detalle_diagnosticoUncheckedCreateInput>
    /**
     * In case the detalle_diagnostico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detalle_diagnosticoUpdateInput, detalle_diagnosticoUncheckedUpdateInput>
  }

  /**
   * detalle_diagnostico delete
   */
  export type detalle_diagnosticoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
    /**
     * Filter which detalle_diagnostico to delete.
     */
    where: detalle_diagnosticoWhereUniqueInput
  }

  /**
   * detalle_diagnostico deleteMany
   */
  export type detalle_diagnosticoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_diagnosticos to delete
     */
    where?: detalle_diagnosticoWhereInput
    /**
     * Limit how many detalle_diagnosticos to delete.
     */
    limit?: number
  }

  /**
   * detalle_diagnostico without action
   */
  export type detalle_diagnosticoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
  }


  /**
   * Model detalle_proforma
   */

  export type AggregateDetalle_proforma = {
    _count: Detalle_proformaCountAggregateOutputType | null
    _avg: Detalle_proformaAvgAggregateOutputType | null
    _sum: Detalle_proformaSumAggregateOutputType | null
    _min: Detalle_proformaMinAggregateOutputType | null
    _max: Detalle_proformaMaxAggregateOutputType | null
  }

  export type Detalle_proformaAvgAggregateOutputType = {
    id: number | null
    proforma_id: number | null
    servicio_id: number | null
    cantidad: Decimal | null
    precio_unit: Decimal | null
    subtotal: Decimal | null
  }

  export type Detalle_proformaSumAggregateOutputType = {
    id: bigint | null
    proforma_id: bigint | null
    servicio_id: number | null
    cantidad: Decimal | null
    precio_unit: Decimal | null
    subtotal: Decimal | null
  }

  export type Detalle_proformaMinAggregateOutputType = {
    id: bigint | null
    proforma_id: bigint | null
    servicio_id: number | null
    descripcion: string | null
    cantidad: Decimal | null
    precio_unit: Decimal | null
    subtotal: Decimal | null
  }

  export type Detalle_proformaMaxAggregateOutputType = {
    id: bigint | null
    proforma_id: bigint | null
    servicio_id: number | null
    descripcion: string | null
    cantidad: Decimal | null
    precio_unit: Decimal | null
    subtotal: Decimal | null
  }

  export type Detalle_proformaCountAggregateOutputType = {
    id: number
    proforma_id: number
    servicio_id: number
    descripcion: number
    cantidad: number
    precio_unit: number
    subtotal: number
    _all: number
  }


  export type Detalle_proformaAvgAggregateInputType = {
    id?: true
    proforma_id?: true
    servicio_id?: true
    cantidad?: true
    precio_unit?: true
    subtotal?: true
  }

  export type Detalle_proformaSumAggregateInputType = {
    id?: true
    proforma_id?: true
    servicio_id?: true
    cantidad?: true
    precio_unit?: true
    subtotal?: true
  }

  export type Detalle_proformaMinAggregateInputType = {
    id?: true
    proforma_id?: true
    servicio_id?: true
    descripcion?: true
    cantidad?: true
    precio_unit?: true
    subtotal?: true
  }

  export type Detalle_proformaMaxAggregateInputType = {
    id?: true
    proforma_id?: true
    servicio_id?: true
    descripcion?: true
    cantidad?: true
    precio_unit?: true
    subtotal?: true
  }

  export type Detalle_proformaCountAggregateInputType = {
    id?: true
    proforma_id?: true
    servicio_id?: true
    descripcion?: true
    cantidad?: true
    precio_unit?: true
    subtotal?: true
    _all?: true
  }

  export type Detalle_proformaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_proforma to aggregate.
     */
    where?: detalle_proformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_proformas to fetch.
     */
    orderBy?: detalle_proformaOrderByWithRelationInput | detalle_proformaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detalle_proformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_proformas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_proformas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detalle_proformas
    **/
    _count?: true | Detalle_proformaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detalle_proformaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detalle_proformaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detalle_proformaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detalle_proformaMaxAggregateInputType
  }

  export type GetDetalle_proformaAggregateType<T extends Detalle_proformaAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalle_proforma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalle_proforma[P]>
      : GetScalarType<T[P], AggregateDetalle_proforma[P]>
  }




  export type detalle_proformaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_proformaWhereInput
    orderBy?: detalle_proformaOrderByWithAggregationInput | detalle_proformaOrderByWithAggregationInput[]
    by: Detalle_proformaScalarFieldEnum[] | Detalle_proformaScalarFieldEnum
    having?: detalle_proformaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detalle_proformaCountAggregateInputType | true
    _avg?: Detalle_proformaAvgAggregateInputType
    _sum?: Detalle_proformaSumAggregateInputType
    _min?: Detalle_proformaMinAggregateInputType
    _max?: Detalle_proformaMaxAggregateInputType
  }

  export type Detalle_proformaGroupByOutputType = {
    id: bigint
    proforma_id: bigint
    servicio_id: number | null
    descripcion: string
    cantidad: Decimal
    precio_unit: Decimal
    subtotal: Decimal | null
    _count: Detalle_proformaCountAggregateOutputType | null
    _avg: Detalle_proformaAvgAggregateOutputType | null
    _sum: Detalle_proformaSumAggregateOutputType | null
    _min: Detalle_proformaMinAggregateOutputType | null
    _max: Detalle_proformaMaxAggregateOutputType | null
  }

  type GetDetalle_proformaGroupByPayload<T extends detalle_proformaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detalle_proformaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detalle_proformaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detalle_proformaGroupByOutputType[P]>
            : GetScalarType<T[P], Detalle_proformaGroupByOutputType[P]>
        }
      >
    >


  export type detalle_proformaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proforma_id?: boolean
    servicio_id?: boolean
    descripcion?: boolean
    cantidad?: boolean
    precio_unit?: boolean
    subtotal?: boolean
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
    servicio?: boolean | detalle_proforma$servicioArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_proforma"]>

  export type detalle_proformaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proforma_id?: boolean
    servicio_id?: boolean
    descripcion?: boolean
    cantidad?: boolean
    precio_unit?: boolean
    subtotal?: boolean
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
    servicio?: boolean | detalle_proforma$servicioArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_proforma"]>

  export type detalle_proformaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proforma_id?: boolean
    servicio_id?: boolean
    descripcion?: boolean
    cantidad?: boolean
    precio_unit?: boolean
    subtotal?: boolean
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
    servicio?: boolean | detalle_proforma$servicioArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_proforma"]>

  export type detalle_proformaSelectScalar = {
    id?: boolean
    proforma_id?: boolean
    servicio_id?: boolean
    descripcion?: boolean
    cantidad?: boolean
    precio_unit?: boolean
    subtotal?: boolean
  }

  export type detalle_proformaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "proforma_id" | "servicio_id" | "descripcion" | "cantidad" | "precio_unit" | "subtotal", ExtArgs["result"]["detalle_proforma"]>
  export type detalle_proformaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
    servicio?: boolean | detalle_proforma$servicioArgs<ExtArgs>
  }
  export type detalle_proformaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
    servicio?: boolean | detalle_proforma$servicioArgs<ExtArgs>
  }
  export type detalle_proformaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
    servicio?: boolean | detalle_proforma$servicioArgs<ExtArgs>
  }

  export type $detalle_proformaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "detalle_proforma"
    objects: {
      proforma: Prisma.$proformaPayload<ExtArgs>
      servicio: Prisma.$servicioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      proforma_id: bigint
      servicio_id: number | null
      descripcion: string
      cantidad: Prisma.Decimal
      precio_unit: Prisma.Decimal
      subtotal: Prisma.Decimal | null
    }, ExtArgs["result"]["detalle_proforma"]>
    composites: {}
  }

  type detalle_proformaGetPayload<S extends boolean | null | undefined | detalle_proformaDefaultArgs> = $Result.GetResult<Prisma.$detalle_proformaPayload, S>

  type detalle_proformaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<detalle_proformaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Detalle_proformaCountAggregateInputType | true
    }

  export interface detalle_proformaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detalle_proforma'], meta: { name: 'detalle_proforma' } }
    /**
     * Find zero or one Detalle_proforma that matches the filter.
     * @param {detalle_proformaFindUniqueArgs} args - Arguments to find a Detalle_proforma
     * @example
     * // Get one Detalle_proforma
     * const detalle_proforma = await prisma.detalle_proforma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends detalle_proformaFindUniqueArgs>(args: SelectSubset<T, detalle_proformaFindUniqueArgs<ExtArgs>>): Prisma__detalle_proformaClient<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Detalle_proforma that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {detalle_proformaFindUniqueOrThrowArgs} args - Arguments to find a Detalle_proforma
     * @example
     * // Get one Detalle_proforma
     * const detalle_proforma = await prisma.detalle_proforma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends detalle_proformaFindUniqueOrThrowArgs>(args: SelectSubset<T, detalle_proformaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__detalle_proformaClient<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Detalle_proforma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_proformaFindFirstArgs} args - Arguments to find a Detalle_proforma
     * @example
     * // Get one Detalle_proforma
     * const detalle_proforma = await prisma.detalle_proforma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends detalle_proformaFindFirstArgs>(args?: SelectSubset<T, detalle_proformaFindFirstArgs<ExtArgs>>): Prisma__detalle_proformaClient<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Detalle_proforma that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_proformaFindFirstOrThrowArgs} args - Arguments to find a Detalle_proforma
     * @example
     * // Get one Detalle_proforma
     * const detalle_proforma = await prisma.detalle_proforma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends detalle_proformaFindFirstOrThrowArgs>(args?: SelectSubset<T, detalle_proformaFindFirstOrThrowArgs<ExtArgs>>): Prisma__detalle_proformaClient<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Detalle_proformas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_proformaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detalle_proformas
     * const detalle_proformas = await prisma.detalle_proforma.findMany()
     * 
     * // Get first 10 Detalle_proformas
     * const detalle_proformas = await prisma.detalle_proforma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detalle_proformaWithIdOnly = await prisma.detalle_proforma.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends detalle_proformaFindManyArgs>(args?: SelectSubset<T, detalle_proformaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Detalle_proforma.
     * @param {detalle_proformaCreateArgs} args - Arguments to create a Detalle_proforma.
     * @example
     * // Create one Detalle_proforma
     * const Detalle_proforma = await prisma.detalle_proforma.create({
     *   data: {
     *     // ... data to create a Detalle_proforma
     *   }
     * })
     * 
     */
    create<T extends detalle_proformaCreateArgs>(args: SelectSubset<T, detalle_proformaCreateArgs<ExtArgs>>): Prisma__detalle_proformaClient<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Detalle_proformas.
     * @param {detalle_proformaCreateManyArgs} args - Arguments to create many Detalle_proformas.
     * @example
     * // Create many Detalle_proformas
     * const detalle_proforma = await prisma.detalle_proforma.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends detalle_proformaCreateManyArgs>(args?: SelectSubset<T, detalle_proformaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Detalle_proformas and returns the data saved in the database.
     * @param {detalle_proformaCreateManyAndReturnArgs} args - Arguments to create many Detalle_proformas.
     * @example
     * // Create many Detalle_proformas
     * const detalle_proforma = await prisma.detalle_proforma.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Detalle_proformas and only return the `id`
     * const detalle_proformaWithIdOnly = await prisma.detalle_proforma.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends detalle_proformaCreateManyAndReturnArgs>(args?: SelectSubset<T, detalle_proformaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Detalle_proforma.
     * @param {detalle_proformaDeleteArgs} args - Arguments to delete one Detalle_proforma.
     * @example
     * // Delete one Detalle_proforma
     * const Detalle_proforma = await prisma.detalle_proforma.delete({
     *   where: {
     *     // ... filter to delete one Detalle_proforma
     *   }
     * })
     * 
     */
    delete<T extends detalle_proformaDeleteArgs>(args: SelectSubset<T, detalle_proformaDeleteArgs<ExtArgs>>): Prisma__detalle_proformaClient<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Detalle_proforma.
     * @param {detalle_proformaUpdateArgs} args - Arguments to update one Detalle_proforma.
     * @example
     * // Update one Detalle_proforma
     * const detalle_proforma = await prisma.detalle_proforma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends detalle_proformaUpdateArgs>(args: SelectSubset<T, detalle_proformaUpdateArgs<ExtArgs>>): Prisma__detalle_proformaClient<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Detalle_proformas.
     * @param {detalle_proformaDeleteManyArgs} args - Arguments to filter Detalle_proformas to delete.
     * @example
     * // Delete a few Detalle_proformas
     * const { count } = await prisma.detalle_proforma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends detalle_proformaDeleteManyArgs>(args?: SelectSubset<T, detalle_proformaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detalle_proformas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_proformaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detalle_proformas
     * const detalle_proforma = await prisma.detalle_proforma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends detalle_proformaUpdateManyArgs>(args: SelectSubset<T, detalle_proformaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detalle_proformas and returns the data updated in the database.
     * @param {detalle_proformaUpdateManyAndReturnArgs} args - Arguments to update many Detalle_proformas.
     * @example
     * // Update many Detalle_proformas
     * const detalle_proforma = await prisma.detalle_proforma.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Detalle_proformas and only return the `id`
     * const detalle_proformaWithIdOnly = await prisma.detalle_proforma.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends detalle_proformaUpdateManyAndReturnArgs>(args: SelectSubset<T, detalle_proformaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Detalle_proforma.
     * @param {detalle_proformaUpsertArgs} args - Arguments to update or create a Detalle_proforma.
     * @example
     * // Update or create a Detalle_proforma
     * const detalle_proforma = await prisma.detalle_proforma.upsert({
     *   create: {
     *     // ... data to create a Detalle_proforma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detalle_proforma we want to update
     *   }
     * })
     */
    upsert<T extends detalle_proformaUpsertArgs>(args: SelectSubset<T, detalle_proformaUpsertArgs<ExtArgs>>): Prisma__detalle_proformaClient<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Detalle_proformas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_proformaCountArgs} args - Arguments to filter Detalle_proformas to count.
     * @example
     * // Count the number of Detalle_proformas
     * const count = await prisma.detalle_proforma.count({
     *   where: {
     *     // ... the filter for the Detalle_proformas we want to count
     *   }
     * })
    **/
    count<T extends detalle_proformaCountArgs>(
      args?: Subset<T, detalle_proformaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detalle_proformaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detalle_proforma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detalle_proformaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detalle_proformaAggregateArgs>(args: Subset<T, Detalle_proformaAggregateArgs>): Prisma.PrismaPromise<GetDetalle_proformaAggregateType<T>>

    /**
     * Group by Detalle_proforma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_proformaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detalle_proformaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detalle_proformaGroupByArgs['orderBy'] }
        : { orderBy?: detalle_proformaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detalle_proformaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalle_proformaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detalle_proforma model
   */
  readonly fields: detalle_proformaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detalle_proforma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detalle_proformaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proforma<T extends proformaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, proformaDefaultArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    servicio<T extends detalle_proforma$servicioArgs<ExtArgs> = {}>(args?: Subset<T, detalle_proforma$servicioArgs<ExtArgs>>): Prisma__servicioClient<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the detalle_proforma model
   */
  interface detalle_proformaFieldRefs {
    readonly id: FieldRef<"detalle_proforma", 'BigInt'>
    readonly proforma_id: FieldRef<"detalle_proforma", 'BigInt'>
    readonly servicio_id: FieldRef<"detalle_proforma", 'Int'>
    readonly descripcion: FieldRef<"detalle_proforma", 'String'>
    readonly cantidad: FieldRef<"detalle_proforma", 'Decimal'>
    readonly precio_unit: FieldRef<"detalle_proforma", 'Decimal'>
    readonly subtotal: FieldRef<"detalle_proforma", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * detalle_proforma findUnique
   */
  export type detalle_proformaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    /**
     * Filter, which detalle_proforma to fetch.
     */
    where: detalle_proformaWhereUniqueInput
  }

  /**
   * detalle_proforma findUniqueOrThrow
   */
  export type detalle_proformaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    /**
     * Filter, which detalle_proforma to fetch.
     */
    where: detalle_proformaWhereUniqueInput
  }

  /**
   * detalle_proforma findFirst
   */
  export type detalle_proformaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    /**
     * Filter, which detalle_proforma to fetch.
     */
    where?: detalle_proformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_proformas to fetch.
     */
    orderBy?: detalle_proformaOrderByWithRelationInput | detalle_proformaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_proformas.
     */
    cursor?: detalle_proformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_proformas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_proformas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_proformas.
     */
    distinct?: Detalle_proformaScalarFieldEnum | Detalle_proformaScalarFieldEnum[]
  }

  /**
   * detalle_proforma findFirstOrThrow
   */
  export type detalle_proformaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    /**
     * Filter, which detalle_proforma to fetch.
     */
    where?: detalle_proformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_proformas to fetch.
     */
    orderBy?: detalle_proformaOrderByWithRelationInput | detalle_proformaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_proformas.
     */
    cursor?: detalle_proformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_proformas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_proformas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_proformas.
     */
    distinct?: Detalle_proformaScalarFieldEnum | Detalle_proformaScalarFieldEnum[]
  }

  /**
   * detalle_proforma findMany
   */
  export type detalle_proformaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    /**
     * Filter, which detalle_proformas to fetch.
     */
    where?: detalle_proformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_proformas to fetch.
     */
    orderBy?: detalle_proformaOrderByWithRelationInput | detalle_proformaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detalle_proformas.
     */
    cursor?: detalle_proformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_proformas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_proformas.
     */
    skip?: number
    distinct?: Detalle_proformaScalarFieldEnum | Detalle_proformaScalarFieldEnum[]
  }

  /**
   * detalle_proforma create
   */
  export type detalle_proformaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    /**
     * The data needed to create a detalle_proforma.
     */
    data: XOR<detalle_proformaCreateInput, detalle_proformaUncheckedCreateInput>
  }

  /**
   * detalle_proforma createMany
   */
  export type detalle_proformaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detalle_proformas.
     */
    data: detalle_proformaCreateManyInput | detalle_proformaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * detalle_proforma createManyAndReturn
   */
  export type detalle_proformaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * The data used to create many detalle_proformas.
     */
    data: detalle_proformaCreateManyInput | detalle_proformaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * detalle_proforma update
   */
  export type detalle_proformaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    /**
     * The data needed to update a detalle_proforma.
     */
    data: XOR<detalle_proformaUpdateInput, detalle_proformaUncheckedUpdateInput>
    /**
     * Choose, which detalle_proforma to update.
     */
    where: detalle_proformaWhereUniqueInput
  }

  /**
   * detalle_proforma updateMany
   */
  export type detalle_proformaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detalle_proformas.
     */
    data: XOR<detalle_proformaUpdateManyMutationInput, detalle_proformaUncheckedUpdateManyInput>
    /**
     * Filter which detalle_proformas to update
     */
    where?: detalle_proformaWhereInput
    /**
     * Limit how many detalle_proformas to update.
     */
    limit?: number
  }

  /**
   * detalle_proforma updateManyAndReturn
   */
  export type detalle_proformaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * The data used to update detalle_proformas.
     */
    data: XOR<detalle_proformaUpdateManyMutationInput, detalle_proformaUncheckedUpdateManyInput>
    /**
     * Filter which detalle_proformas to update
     */
    where?: detalle_proformaWhereInput
    /**
     * Limit how many detalle_proformas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * detalle_proforma upsert
   */
  export type detalle_proformaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    /**
     * The filter to search for the detalle_proforma to update in case it exists.
     */
    where: detalle_proformaWhereUniqueInput
    /**
     * In case the detalle_proforma found by the `where` argument doesn't exist, create a new detalle_proforma with this data.
     */
    create: XOR<detalle_proformaCreateInput, detalle_proformaUncheckedCreateInput>
    /**
     * In case the detalle_proforma was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detalle_proformaUpdateInput, detalle_proformaUncheckedUpdateInput>
  }

  /**
   * detalle_proforma delete
   */
  export type detalle_proformaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    /**
     * Filter which detalle_proforma to delete.
     */
    where: detalle_proformaWhereUniqueInput
  }

  /**
   * detalle_proforma deleteMany
   */
  export type detalle_proformaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_proformas to delete
     */
    where?: detalle_proformaWhereInput
    /**
     * Limit how many detalle_proformas to delete.
     */
    limit?: number
  }

  /**
   * detalle_proforma.servicio
   */
  export type detalle_proforma$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    where?: servicioWhereInput
  }

  /**
   * detalle_proforma without action
   */
  export type detalle_proformaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
  }


  /**
   * Model diagnostico
   */

  export type AggregateDiagnostico = {
    _count: DiagnosticoCountAggregateOutputType | null
    _avg: DiagnosticoAvgAggregateOutputType | null
    _sum: DiagnosticoSumAggregateOutputType | null
    _min: DiagnosticoMinAggregateOutputType | null
    _max: DiagnosticoMaxAggregateOutputType | null
  }

  export type DiagnosticoAvgAggregateOutputType = {
    nro: number | null
    empleado_ci: number | null
  }

  export type DiagnosticoSumAggregateOutputType = {
    nro: bigint | null
    empleado_ci: number | null
  }

  export type DiagnosticoMinAggregateOutputType = {
    nro: bigint | null
    fecha: Date | null
    hora: Date | null
    placa_moto: string | null
    empleado_ci: number | null
  }

  export type DiagnosticoMaxAggregateOutputType = {
    nro: bigint | null
    fecha: Date | null
    hora: Date | null
    placa_moto: string | null
    empleado_ci: number | null
  }

  export type DiagnosticoCountAggregateOutputType = {
    nro: number
    fecha: number
    hora: number
    placa_moto: number
    empleado_ci: number
    _all: number
  }


  export type DiagnosticoAvgAggregateInputType = {
    nro?: true
    empleado_ci?: true
  }

  export type DiagnosticoSumAggregateInputType = {
    nro?: true
    empleado_ci?: true
  }

  export type DiagnosticoMinAggregateInputType = {
    nro?: true
    fecha?: true
    hora?: true
    placa_moto?: true
    empleado_ci?: true
  }

  export type DiagnosticoMaxAggregateInputType = {
    nro?: true
    fecha?: true
    hora?: true
    placa_moto?: true
    empleado_ci?: true
  }

  export type DiagnosticoCountAggregateInputType = {
    nro?: true
    fecha?: true
    hora?: true
    placa_moto?: true
    empleado_ci?: true
    _all?: true
  }

  export type DiagnosticoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diagnostico to aggregate.
     */
    where?: diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosticos to fetch.
     */
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosticos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned diagnosticos
    **/
    _count?: true | DiagnosticoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiagnosticoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiagnosticoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosticoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosticoMaxAggregateInputType
  }

  export type GetDiagnosticoAggregateType<T extends DiagnosticoAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnostico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnostico[P]>
      : GetScalarType<T[P], AggregateDiagnostico[P]>
  }




  export type diagnosticoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnosticoWhereInput
    orderBy?: diagnosticoOrderByWithAggregationInput | diagnosticoOrderByWithAggregationInput[]
    by: DiagnosticoScalarFieldEnum[] | DiagnosticoScalarFieldEnum
    having?: diagnosticoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosticoCountAggregateInputType | true
    _avg?: DiagnosticoAvgAggregateInputType
    _sum?: DiagnosticoSumAggregateInputType
    _min?: DiagnosticoMinAggregateInputType
    _max?: DiagnosticoMaxAggregateInputType
  }

  export type DiagnosticoGroupByOutputType = {
    nro: bigint
    fecha: Date
    hora: Date
    placa_moto: string
    empleado_ci: number
    _count: DiagnosticoCountAggregateOutputType | null
    _avg: DiagnosticoAvgAggregateOutputType | null
    _sum: DiagnosticoSumAggregateOutputType | null
    _min: DiagnosticoMinAggregateOutputType | null
    _max: DiagnosticoMaxAggregateOutputType | null
  }

  type GetDiagnosticoGroupByPayload<T extends diagnosticoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosticoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosticoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosticoGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosticoGroupByOutputType[P]>
        }
      >
    >


  export type diagnosticoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nro?: boolean
    fecha?: boolean
    hora?: boolean
    placa_moto?: boolean
    empleado_ci?: boolean
    detalle_diagnostico?: boolean | diagnostico$detalle_diagnosticoArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    moto?: boolean | motoDefaultArgs<ExtArgs>
    proforma?: boolean | diagnostico$proformaArgs<ExtArgs>
    _count?: boolean | DiagnosticoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnostico"]>

  export type diagnosticoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nro?: boolean
    fecha?: boolean
    hora?: boolean
    placa_moto?: boolean
    empleado_ci?: boolean
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    moto?: boolean | motoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnostico"]>

  export type diagnosticoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nro?: boolean
    fecha?: boolean
    hora?: boolean
    placa_moto?: boolean
    empleado_ci?: boolean
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    moto?: boolean | motoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnostico"]>

  export type diagnosticoSelectScalar = {
    nro?: boolean
    fecha?: boolean
    hora?: boolean
    placa_moto?: boolean
    empleado_ci?: boolean
  }

  export type diagnosticoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"nro" | "fecha" | "hora" | "placa_moto" | "empleado_ci", ExtArgs["result"]["diagnostico"]>
  export type diagnosticoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_diagnostico?: boolean | diagnostico$detalle_diagnosticoArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    moto?: boolean | motoDefaultArgs<ExtArgs>
    proforma?: boolean | diagnostico$proformaArgs<ExtArgs>
    _count?: boolean | DiagnosticoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type diagnosticoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    moto?: boolean | motoDefaultArgs<ExtArgs>
  }
  export type diagnosticoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    moto?: boolean | motoDefaultArgs<ExtArgs>
  }

  export type $diagnosticoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "diagnostico"
    objects: {
      detalle_diagnostico: Prisma.$detalle_diagnosticoPayload<ExtArgs>[]
      empleado: Prisma.$empleadoPayload<ExtArgs>
      moto: Prisma.$motoPayload<ExtArgs>
      proforma: Prisma.$proformaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      nro: bigint
      fecha: Date
      hora: Date
      placa_moto: string
      empleado_ci: number
    }, ExtArgs["result"]["diagnostico"]>
    composites: {}
  }

  type diagnosticoGetPayload<S extends boolean | null | undefined | diagnosticoDefaultArgs> = $Result.GetResult<Prisma.$diagnosticoPayload, S>

  type diagnosticoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<diagnosticoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiagnosticoCountAggregateInputType | true
    }

  export interface diagnosticoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['diagnostico'], meta: { name: 'diagnostico' } }
    /**
     * Find zero or one Diagnostico that matches the filter.
     * @param {diagnosticoFindUniqueArgs} args - Arguments to find a Diagnostico
     * @example
     * // Get one Diagnostico
     * const diagnostico = await prisma.diagnostico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends diagnosticoFindUniqueArgs>(args: SelectSubset<T, diagnosticoFindUniqueArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Diagnostico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {diagnosticoFindUniqueOrThrowArgs} args - Arguments to find a Diagnostico
     * @example
     * // Get one Diagnostico
     * const diagnostico = await prisma.diagnostico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends diagnosticoFindUniqueOrThrowArgs>(args: SelectSubset<T, diagnosticoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diagnostico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoFindFirstArgs} args - Arguments to find a Diagnostico
     * @example
     * // Get one Diagnostico
     * const diagnostico = await prisma.diagnostico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends diagnosticoFindFirstArgs>(args?: SelectSubset<T, diagnosticoFindFirstArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diagnostico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoFindFirstOrThrowArgs} args - Arguments to find a Diagnostico
     * @example
     * // Get one Diagnostico
     * const diagnostico = await prisma.diagnostico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends diagnosticoFindFirstOrThrowArgs>(args?: SelectSubset<T, diagnosticoFindFirstOrThrowArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Diagnosticos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnosticos
     * const diagnosticos = await prisma.diagnostico.findMany()
     * 
     * // Get first 10 Diagnosticos
     * const diagnosticos = await prisma.diagnostico.findMany({ take: 10 })
     * 
     * // Only select the `nro`
     * const diagnosticoWithNroOnly = await prisma.diagnostico.findMany({ select: { nro: true } })
     * 
     */
    findMany<T extends diagnosticoFindManyArgs>(args?: SelectSubset<T, diagnosticoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Diagnostico.
     * @param {diagnosticoCreateArgs} args - Arguments to create a Diagnostico.
     * @example
     * // Create one Diagnostico
     * const Diagnostico = await prisma.diagnostico.create({
     *   data: {
     *     // ... data to create a Diagnostico
     *   }
     * })
     * 
     */
    create<T extends diagnosticoCreateArgs>(args: SelectSubset<T, diagnosticoCreateArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Diagnosticos.
     * @param {diagnosticoCreateManyArgs} args - Arguments to create many Diagnosticos.
     * @example
     * // Create many Diagnosticos
     * const diagnostico = await prisma.diagnostico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends diagnosticoCreateManyArgs>(args?: SelectSubset<T, diagnosticoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnosticos and returns the data saved in the database.
     * @param {diagnosticoCreateManyAndReturnArgs} args - Arguments to create many Diagnosticos.
     * @example
     * // Create many Diagnosticos
     * const diagnostico = await prisma.diagnostico.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnosticos and only return the `nro`
     * const diagnosticoWithNroOnly = await prisma.diagnostico.createManyAndReturn({
     *   select: { nro: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends diagnosticoCreateManyAndReturnArgs>(args?: SelectSubset<T, diagnosticoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Diagnostico.
     * @param {diagnosticoDeleteArgs} args - Arguments to delete one Diagnostico.
     * @example
     * // Delete one Diagnostico
     * const Diagnostico = await prisma.diagnostico.delete({
     *   where: {
     *     // ... filter to delete one Diagnostico
     *   }
     * })
     * 
     */
    delete<T extends diagnosticoDeleteArgs>(args: SelectSubset<T, diagnosticoDeleteArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Diagnostico.
     * @param {diagnosticoUpdateArgs} args - Arguments to update one Diagnostico.
     * @example
     * // Update one Diagnostico
     * const diagnostico = await prisma.diagnostico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends diagnosticoUpdateArgs>(args: SelectSubset<T, diagnosticoUpdateArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Diagnosticos.
     * @param {diagnosticoDeleteManyArgs} args - Arguments to filter Diagnosticos to delete.
     * @example
     * // Delete a few Diagnosticos
     * const { count } = await prisma.diagnostico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends diagnosticoDeleteManyArgs>(args?: SelectSubset<T, diagnosticoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnosticos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnosticos
     * const diagnostico = await prisma.diagnostico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends diagnosticoUpdateManyArgs>(args: SelectSubset<T, diagnosticoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnosticos and returns the data updated in the database.
     * @param {diagnosticoUpdateManyAndReturnArgs} args - Arguments to update many Diagnosticos.
     * @example
     * // Update many Diagnosticos
     * const diagnostico = await prisma.diagnostico.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Diagnosticos and only return the `nro`
     * const diagnosticoWithNroOnly = await prisma.diagnostico.updateManyAndReturn({
     *   select: { nro: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends diagnosticoUpdateManyAndReturnArgs>(args: SelectSubset<T, diagnosticoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Diagnostico.
     * @param {diagnosticoUpsertArgs} args - Arguments to update or create a Diagnostico.
     * @example
     * // Update or create a Diagnostico
     * const diagnostico = await prisma.diagnostico.upsert({
     *   create: {
     *     // ... data to create a Diagnostico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnostico we want to update
     *   }
     * })
     */
    upsert<T extends diagnosticoUpsertArgs>(args: SelectSubset<T, diagnosticoUpsertArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Diagnosticos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoCountArgs} args - Arguments to filter Diagnosticos to count.
     * @example
     * // Count the number of Diagnosticos
     * const count = await prisma.diagnostico.count({
     *   where: {
     *     // ... the filter for the Diagnosticos we want to count
     *   }
     * })
    **/
    count<T extends diagnosticoCountArgs>(
      args?: Subset<T, diagnosticoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosticoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnostico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosticoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosticoAggregateArgs>(args: Subset<T, DiagnosticoAggregateArgs>): Prisma.PrismaPromise<GetDiagnosticoAggregateType<T>>

    /**
     * Group by Diagnostico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnosticoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends diagnosticoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: diagnosticoGroupByArgs['orderBy'] }
        : { orderBy?: diagnosticoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, diagnosticoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosticoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the diagnostico model
   */
  readonly fields: diagnosticoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for diagnostico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__diagnosticoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detalle_diagnostico<T extends diagnostico$detalle_diagnosticoArgs<ExtArgs> = {}>(args?: Subset<T, diagnostico$detalle_diagnosticoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_diagnosticoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    empleado<T extends empleadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, empleadoDefaultArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    moto<T extends motoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, motoDefaultArgs<ExtArgs>>): Prisma__motoClient<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proforma<T extends diagnostico$proformaArgs<ExtArgs> = {}>(args?: Subset<T, diagnostico$proformaArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the diagnostico model
   */
  interface diagnosticoFieldRefs {
    readonly nro: FieldRef<"diagnostico", 'BigInt'>
    readonly fecha: FieldRef<"diagnostico", 'DateTime'>
    readonly hora: FieldRef<"diagnostico", 'DateTime'>
    readonly placa_moto: FieldRef<"diagnostico", 'String'>
    readonly empleado_ci: FieldRef<"diagnostico", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * diagnostico findUnique
   */
  export type diagnosticoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which diagnostico to fetch.
     */
    where: diagnosticoWhereUniqueInput
  }

  /**
   * diagnostico findUniqueOrThrow
   */
  export type diagnosticoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which diagnostico to fetch.
     */
    where: diagnosticoWhereUniqueInput
  }

  /**
   * diagnostico findFirst
   */
  export type diagnosticoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which diagnostico to fetch.
     */
    where?: diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosticos to fetch.
     */
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diagnosticos.
     */
    cursor?: diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosticos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diagnosticos.
     */
    distinct?: DiagnosticoScalarFieldEnum | DiagnosticoScalarFieldEnum[]
  }

  /**
   * diagnostico findFirstOrThrow
   */
  export type diagnosticoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which diagnostico to fetch.
     */
    where?: diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosticos to fetch.
     */
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diagnosticos.
     */
    cursor?: diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosticos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diagnosticos.
     */
    distinct?: DiagnosticoScalarFieldEnum | DiagnosticoScalarFieldEnum[]
  }

  /**
   * diagnostico findMany
   */
  export type diagnosticoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter, which diagnosticos to fetch.
     */
    where?: diagnosticoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnosticos to fetch.
     */
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing diagnosticos.
     */
    cursor?: diagnosticoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnosticos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnosticos.
     */
    skip?: number
    distinct?: DiagnosticoScalarFieldEnum | DiagnosticoScalarFieldEnum[]
  }

  /**
   * diagnostico create
   */
  export type diagnosticoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * The data needed to create a diagnostico.
     */
    data: XOR<diagnosticoCreateInput, diagnosticoUncheckedCreateInput>
  }

  /**
   * diagnostico createMany
   */
  export type diagnosticoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many diagnosticos.
     */
    data: diagnosticoCreateManyInput | diagnosticoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * diagnostico createManyAndReturn
   */
  export type diagnosticoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * The data used to create many diagnosticos.
     */
    data: diagnosticoCreateManyInput | diagnosticoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * diagnostico update
   */
  export type diagnosticoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * The data needed to update a diagnostico.
     */
    data: XOR<diagnosticoUpdateInput, diagnosticoUncheckedUpdateInput>
    /**
     * Choose, which diagnostico to update.
     */
    where: diagnosticoWhereUniqueInput
  }

  /**
   * diagnostico updateMany
   */
  export type diagnosticoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update diagnosticos.
     */
    data: XOR<diagnosticoUpdateManyMutationInput, diagnosticoUncheckedUpdateManyInput>
    /**
     * Filter which diagnosticos to update
     */
    where?: diagnosticoWhereInput
    /**
     * Limit how many diagnosticos to update.
     */
    limit?: number
  }

  /**
   * diagnostico updateManyAndReturn
   */
  export type diagnosticoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * The data used to update diagnosticos.
     */
    data: XOR<diagnosticoUpdateManyMutationInput, diagnosticoUncheckedUpdateManyInput>
    /**
     * Filter which diagnosticos to update
     */
    where?: diagnosticoWhereInput
    /**
     * Limit how many diagnosticos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * diagnostico upsert
   */
  export type diagnosticoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * The filter to search for the diagnostico to update in case it exists.
     */
    where: diagnosticoWhereUniqueInput
    /**
     * In case the diagnostico found by the `where` argument doesn't exist, create a new diagnostico with this data.
     */
    create: XOR<diagnosticoCreateInput, diagnosticoUncheckedCreateInput>
    /**
     * In case the diagnostico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<diagnosticoUpdateInput, diagnosticoUncheckedUpdateInput>
  }

  /**
   * diagnostico delete
   */
  export type diagnosticoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    /**
     * Filter which diagnostico to delete.
     */
    where: diagnosticoWhereUniqueInput
  }

  /**
   * diagnostico deleteMany
   */
  export type diagnosticoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diagnosticos to delete
     */
    where?: diagnosticoWhereInput
    /**
     * Limit how many diagnosticos to delete.
     */
    limit?: number
  }

  /**
   * diagnostico.detalle_diagnostico
   */
  export type diagnostico$detalle_diagnosticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_diagnostico
     */
    select?: detalle_diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_diagnostico
     */
    omit?: detalle_diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_diagnosticoInclude<ExtArgs> | null
    where?: detalle_diagnosticoWhereInput
    orderBy?: detalle_diagnosticoOrderByWithRelationInput | detalle_diagnosticoOrderByWithRelationInput[]
    cursor?: detalle_diagnosticoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detalle_diagnosticoScalarFieldEnum | Detalle_diagnosticoScalarFieldEnum[]
  }

  /**
   * diagnostico.proforma
   */
  export type diagnostico$proformaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    where?: proformaWhereInput
  }

  /**
   * diagnostico without action
   */
  export type diagnosticoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
  }


  /**
   * Model empleado
   */

  export type AggregateEmpleado = {
    _count: EmpleadoCountAggregateOutputType | null
    _avg: EmpleadoAvgAggregateOutputType | null
    _sum: EmpleadoSumAggregateOutputType | null
    _min: EmpleadoMinAggregateOutputType | null
    _max: EmpleadoMaxAggregateOutputType | null
  }

  export type EmpleadoAvgAggregateOutputType = {
    ci: number | null
    telefono: number | null
  }

  export type EmpleadoSumAggregateOutputType = {
    ci: number | null
    telefono: number | null
  }

  export type EmpleadoMinAggregateOutputType = {
    ci: number | null
    nombre: string | null
    fechanac: Date | null
    direccion: string | null
    telefono: number | null
  }

  export type EmpleadoMaxAggregateOutputType = {
    ci: number | null
    nombre: string | null
    fechanac: Date | null
    direccion: string | null
    telefono: number | null
  }

  export type EmpleadoCountAggregateOutputType = {
    ci: number
    nombre: number
    fechanac: number
    direccion: number
    telefono: number
    _all: number
  }


  export type EmpleadoAvgAggregateInputType = {
    ci?: true
    telefono?: true
  }

  export type EmpleadoSumAggregateInputType = {
    ci?: true
    telefono?: true
  }

  export type EmpleadoMinAggregateInputType = {
    ci?: true
    nombre?: true
    fechanac?: true
    direccion?: true
    telefono?: true
  }

  export type EmpleadoMaxAggregateInputType = {
    ci?: true
    nombre?: true
    fechanac?: true
    direccion?: true
    telefono?: true
  }

  export type EmpleadoCountAggregateInputType = {
    ci?: true
    nombre?: true
    fechanac?: true
    direccion?: true
    telefono?: true
    _all?: true
  }

  export type EmpleadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empleado to aggregate.
     */
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadoOrderByWithRelationInput | empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empleados
    **/
    _count?: true | EmpleadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpleadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpleadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadoMaxAggregateInputType
  }

  export type GetEmpleadoAggregateType<T extends EmpleadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleado[P]>
      : GetScalarType<T[P], AggregateEmpleado[P]>
  }




  export type empleadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empleadoWhereInput
    orderBy?: empleadoOrderByWithAggregationInput | empleadoOrderByWithAggregationInput[]
    by: EmpleadoScalarFieldEnum[] | EmpleadoScalarFieldEnum
    having?: empleadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadoCountAggregateInputType | true
    _avg?: EmpleadoAvgAggregateInputType
    _sum?: EmpleadoSumAggregateInputType
    _min?: EmpleadoMinAggregateInputType
    _max?: EmpleadoMaxAggregateInputType
  }

  export type EmpleadoGroupByOutputType = {
    ci: number
    nombre: string
    fechanac: Date
    direccion: string
    telefono: number
    _count: EmpleadoCountAggregateOutputType | null
    _avg: EmpleadoAvgAggregateOutputType | null
    _sum: EmpleadoSumAggregateOutputType | null
    _min: EmpleadoMinAggregateOutputType | null
    _max: EmpleadoMaxAggregateOutputType | null
  }

  type GetEmpleadoGroupByPayload<T extends empleadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpleadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpleadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpleadoGroupByOutputType[P]>
            : GetScalarType<T[P], EmpleadoGroupByOutputType[P]>
        }
      >
    >


  export type empleadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ci?: boolean
    nombre?: boolean
    fechanac?: boolean
    direccion?: boolean
    telefono?: boolean
    diagnostico?: boolean | empleado$diagnosticoArgs<ExtArgs>
    horario_empleado?: boolean | empleado$horario_empleadoArgs<ExtArgs>
    orden_trabajo?: boolean | empleado$orden_trabajoArgs<ExtArgs>
    usuario?: boolean | empleado$usuarioArgs<ExtArgs>
    _count?: boolean | EmpleadoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empleado"]>

  export type empleadoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ci?: boolean
    nombre?: boolean
    fechanac?: boolean
    direccion?: boolean
    telefono?: boolean
  }, ExtArgs["result"]["empleado"]>

  export type empleadoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ci?: boolean
    nombre?: boolean
    fechanac?: boolean
    direccion?: boolean
    telefono?: boolean
  }, ExtArgs["result"]["empleado"]>

  export type empleadoSelectScalar = {
    ci?: boolean
    nombre?: boolean
    fechanac?: boolean
    direccion?: boolean
    telefono?: boolean
  }

  export type empleadoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ci" | "nombre" | "fechanac" | "direccion" | "telefono", ExtArgs["result"]["empleado"]>
  export type empleadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostico?: boolean | empleado$diagnosticoArgs<ExtArgs>
    horario_empleado?: boolean | empleado$horario_empleadoArgs<ExtArgs>
    orden_trabajo?: boolean | empleado$orden_trabajoArgs<ExtArgs>
    usuario?: boolean | empleado$usuarioArgs<ExtArgs>
    _count?: boolean | EmpleadoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type empleadoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type empleadoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $empleadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "empleado"
    objects: {
      diagnostico: Prisma.$diagnosticoPayload<ExtArgs>[]
      horario_empleado: Prisma.$horario_empleadoPayload<ExtArgs>[]
      orden_trabajo: Prisma.$orden_trabajoPayload<ExtArgs>[]
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ci: number
      nombre: string
      fechanac: Date
      direccion: string
      telefono: number
    }, ExtArgs["result"]["empleado"]>
    composites: {}
  }

  type empleadoGetPayload<S extends boolean | null | undefined | empleadoDefaultArgs> = $Result.GetResult<Prisma.$empleadoPayload, S>

  type empleadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<empleadoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmpleadoCountAggregateInputType | true
    }

  export interface empleadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['empleado'], meta: { name: 'empleado' } }
    /**
     * Find zero or one Empleado that matches the filter.
     * @param {empleadoFindUniqueArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends empleadoFindUniqueArgs>(args: SelectSubset<T, empleadoFindUniqueArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Empleado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {empleadoFindUniqueOrThrowArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends empleadoFindUniqueOrThrowArgs>(args: SelectSubset<T, empleadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Empleado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoFindFirstArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends empleadoFindFirstArgs>(args?: SelectSubset<T, empleadoFindFirstArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Empleado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoFindFirstOrThrowArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends empleadoFindFirstOrThrowArgs>(args?: SelectSubset<T, empleadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleados
     * const empleados = await prisma.empleado.findMany()
     * 
     * // Get first 10 Empleados
     * const empleados = await prisma.empleado.findMany({ take: 10 })
     * 
     * // Only select the `ci`
     * const empleadoWithCiOnly = await prisma.empleado.findMany({ select: { ci: true } })
     * 
     */
    findMany<T extends empleadoFindManyArgs>(args?: SelectSubset<T, empleadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Empleado.
     * @param {empleadoCreateArgs} args - Arguments to create a Empleado.
     * @example
     * // Create one Empleado
     * const Empleado = await prisma.empleado.create({
     *   data: {
     *     // ... data to create a Empleado
     *   }
     * })
     * 
     */
    create<T extends empleadoCreateArgs>(args: SelectSubset<T, empleadoCreateArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Empleados.
     * @param {empleadoCreateManyArgs} args - Arguments to create many Empleados.
     * @example
     * // Create many Empleados
     * const empleado = await prisma.empleado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends empleadoCreateManyArgs>(args?: SelectSubset<T, empleadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Empleados and returns the data saved in the database.
     * @param {empleadoCreateManyAndReturnArgs} args - Arguments to create many Empleados.
     * @example
     * // Create many Empleados
     * const empleado = await prisma.empleado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Empleados and only return the `ci`
     * const empleadoWithCiOnly = await prisma.empleado.createManyAndReturn({
     *   select: { ci: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends empleadoCreateManyAndReturnArgs>(args?: SelectSubset<T, empleadoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Empleado.
     * @param {empleadoDeleteArgs} args - Arguments to delete one Empleado.
     * @example
     * // Delete one Empleado
     * const Empleado = await prisma.empleado.delete({
     *   where: {
     *     // ... filter to delete one Empleado
     *   }
     * })
     * 
     */
    delete<T extends empleadoDeleteArgs>(args: SelectSubset<T, empleadoDeleteArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Empleado.
     * @param {empleadoUpdateArgs} args - Arguments to update one Empleado.
     * @example
     * // Update one Empleado
     * const empleado = await prisma.empleado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends empleadoUpdateArgs>(args: SelectSubset<T, empleadoUpdateArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Empleados.
     * @param {empleadoDeleteManyArgs} args - Arguments to filter Empleados to delete.
     * @example
     * // Delete a few Empleados
     * const { count } = await prisma.empleado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends empleadoDeleteManyArgs>(args?: SelectSubset<T, empleadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleados
     * const empleado = await prisma.empleado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends empleadoUpdateManyArgs>(args: SelectSubset<T, empleadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleados and returns the data updated in the database.
     * @param {empleadoUpdateManyAndReturnArgs} args - Arguments to update many Empleados.
     * @example
     * // Update many Empleados
     * const empleado = await prisma.empleado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Empleados and only return the `ci`
     * const empleadoWithCiOnly = await prisma.empleado.updateManyAndReturn({
     *   select: { ci: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends empleadoUpdateManyAndReturnArgs>(args: SelectSubset<T, empleadoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Empleado.
     * @param {empleadoUpsertArgs} args - Arguments to update or create a Empleado.
     * @example
     * // Update or create a Empleado
     * const empleado = await prisma.empleado.upsert({
     *   create: {
     *     // ... data to create a Empleado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleado we want to update
     *   }
     * })
     */
    upsert<T extends empleadoUpsertArgs>(args: SelectSubset<T, empleadoUpsertArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoCountArgs} args - Arguments to filter Empleados to count.
     * @example
     * // Count the number of Empleados
     * const count = await prisma.empleado.count({
     *   where: {
     *     // ... the filter for the Empleados we want to count
     *   }
     * })
    **/
    count<T extends empleadoCountArgs>(
      args?: Subset<T, empleadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadoAggregateArgs>(args: Subset<T, EmpleadoAggregateArgs>): Prisma.PrismaPromise<GetEmpleadoAggregateType<T>>

    /**
     * Group by Empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends empleadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: empleadoGroupByArgs['orderBy'] }
        : { orderBy?: empleadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, empleadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the empleado model
   */
  readonly fields: empleadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for empleado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__empleadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diagnostico<T extends empleado$diagnosticoArgs<ExtArgs> = {}>(args?: Subset<T, empleado$diagnosticoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    horario_empleado<T extends empleado$horario_empleadoArgs<ExtArgs> = {}>(args?: Subset<T, empleado$horario_empleadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orden_trabajo<T extends empleado$orden_trabajoArgs<ExtArgs> = {}>(args?: Subset<T, empleado$orden_trabajoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuario<T extends empleado$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, empleado$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the empleado model
   */
  interface empleadoFieldRefs {
    readonly ci: FieldRef<"empleado", 'Int'>
    readonly nombre: FieldRef<"empleado", 'String'>
    readonly fechanac: FieldRef<"empleado", 'DateTime'>
    readonly direccion: FieldRef<"empleado", 'String'>
    readonly telefono: FieldRef<"empleado", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * empleado findUnique
   */
  export type empleadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter, which empleado to fetch.
     */
    where: empleadoWhereUniqueInput
  }

  /**
   * empleado findUniqueOrThrow
   */
  export type empleadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter, which empleado to fetch.
     */
    where: empleadoWhereUniqueInput
  }

  /**
   * empleado findFirst
   */
  export type empleadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter, which empleado to fetch.
     */
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadoOrderByWithRelationInput | empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleados.
     */
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleados.
     */
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }

  /**
   * empleado findFirstOrThrow
   */
  export type empleadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter, which empleado to fetch.
     */
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadoOrderByWithRelationInput | empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleados.
     */
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleados.
     */
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }

  /**
   * empleado findMany
   */
  export type empleadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter, which empleados to fetch.
     */
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadoOrderByWithRelationInput | empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empleados.
     */
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }

  /**
   * empleado create
   */
  export type empleadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * The data needed to create a empleado.
     */
    data: XOR<empleadoCreateInput, empleadoUncheckedCreateInput>
  }

  /**
   * empleado createMany
   */
  export type empleadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many empleados.
     */
    data: empleadoCreateManyInput | empleadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * empleado createManyAndReturn
   */
  export type empleadoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * The data used to create many empleados.
     */
    data: empleadoCreateManyInput | empleadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * empleado update
   */
  export type empleadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * The data needed to update a empleado.
     */
    data: XOR<empleadoUpdateInput, empleadoUncheckedUpdateInput>
    /**
     * Choose, which empleado to update.
     */
    where: empleadoWhereUniqueInput
  }

  /**
   * empleado updateMany
   */
  export type empleadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update empleados.
     */
    data: XOR<empleadoUpdateManyMutationInput, empleadoUncheckedUpdateManyInput>
    /**
     * Filter which empleados to update
     */
    where?: empleadoWhereInput
    /**
     * Limit how many empleados to update.
     */
    limit?: number
  }

  /**
   * empleado updateManyAndReturn
   */
  export type empleadoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * The data used to update empleados.
     */
    data: XOR<empleadoUpdateManyMutationInput, empleadoUncheckedUpdateManyInput>
    /**
     * Filter which empleados to update
     */
    where?: empleadoWhereInput
    /**
     * Limit how many empleados to update.
     */
    limit?: number
  }

  /**
   * empleado upsert
   */
  export type empleadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * The filter to search for the empleado to update in case it exists.
     */
    where: empleadoWhereUniqueInput
    /**
     * In case the empleado found by the `where` argument doesn't exist, create a new empleado with this data.
     */
    create: XOR<empleadoCreateInput, empleadoUncheckedCreateInput>
    /**
     * In case the empleado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<empleadoUpdateInput, empleadoUncheckedUpdateInput>
  }

  /**
   * empleado delete
   */
  export type empleadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter which empleado to delete.
     */
    where: empleadoWhereUniqueInput
  }

  /**
   * empleado deleteMany
   */
  export type empleadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empleados to delete
     */
    where?: empleadoWhereInput
    /**
     * Limit how many empleados to delete.
     */
    limit?: number
  }

  /**
   * empleado.diagnostico
   */
  export type empleado$diagnosticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    where?: diagnosticoWhereInput
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    cursor?: diagnosticoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosticoScalarFieldEnum | DiagnosticoScalarFieldEnum[]
  }

  /**
   * empleado.horario_empleado
   */
  export type empleado$horario_empleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    where?: horario_empleadoWhereInput
    orderBy?: horario_empleadoOrderByWithRelationInput | horario_empleadoOrderByWithRelationInput[]
    cursor?: horario_empleadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Horario_empleadoScalarFieldEnum | Horario_empleadoScalarFieldEnum[]
  }

  /**
   * empleado.orden_trabajo
   */
  export type empleado$orden_trabajoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    where?: orden_trabajoWhereInput
    orderBy?: orden_trabajoOrderByWithRelationInput | orden_trabajoOrderByWithRelationInput[]
    cursor?: orden_trabajoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Orden_trabajoScalarFieldEnum | Orden_trabajoScalarFieldEnum[]
  }

  /**
   * empleado.usuario
   */
  export type empleado$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }

  /**
   * empleado without action
   */
  export type empleadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the empleado
     */
    omit?: empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: empleadoInclude<ExtArgs> | null
  }


  /**
   * Model factura
   */

  export type AggregateFactura = {
    _count: FacturaCountAggregateOutputType | null
    _avg: FacturaAvgAggregateOutputType | null
    _sum: FacturaSumAggregateOutputType | null
    _min: FacturaMinAggregateOutputType | null
    _max: FacturaMaxAggregateOutputType | null
  }

  export type FacturaAvgAggregateOutputType = {
    id: number | null
    monto: Decimal | null
    cliente_ci: number | null
  }

  export type FacturaSumAggregateOutputType = {
    id: bigint | null
    monto: Decimal | null
    cliente_ci: number | null
  }

  export type FacturaMinAggregateOutputType = {
    id: bigint | null
    monto: Decimal | null
    fecha: Date | null
    cliente_ci: number | null
  }

  export type FacturaMaxAggregateOutputType = {
    id: bigint | null
    monto: Decimal | null
    fecha: Date | null
    cliente_ci: number | null
  }

  export type FacturaCountAggregateOutputType = {
    id: number
    monto: number
    fecha: number
    cliente_ci: number
    _all: number
  }


  export type FacturaAvgAggregateInputType = {
    id?: true
    monto?: true
    cliente_ci?: true
  }

  export type FacturaSumAggregateInputType = {
    id?: true
    monto?: true
    cliente_ci?: true
  }

  export type FacturaMinAggregateInputType = {
    id?: true
    monto?: true
    fecha?: true
    cliente_ci?: true
  }

  export type FacturaMaxAggregateInputType = {
    id?: true
    monto?: true
    fecha?: true
    cliente_ci?: true
  }

  export type FacturaCountAggregateInputType = {
    id?: true
    monto?: true
    fecha?: true
    cliente_ci?: true
    _all?: true
  }

  export type FacturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which factura to aggregate.
     */
    where?: facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned facturas
    **/
    _count?: true | FacturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacturaMaxAggregateInputType
  }

  export type GetFacturaAggregateType<T extends FacturaAggregateArgs> = {
        [P in keyof T & keyof AggregateFactura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactura[P]>
      : GetScalarType<T[P], AggregateFactura[P]>
  }




  export type facturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facturaWhereInput
    orderBy?: facturaOrderByWithAggregationInput | facturaOrderByWithAggregationInput[]
    by: FacturaScalarFieldEnum[] | FacturaScalarFieldEnum
    having?: facturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacturaCountAggregateInputType | true
    _avg?: FacturaAvgAggregateInputType
    _sum?: FacturaSumAggregateInputType
    _min?: FacturaMinAggregateInputType
    _max?: FacturaMaxAggregateInputType
  }

  export type FacturaGroupByOutputType = {
    id: bigint
    monto: Decimal
    fecha: Date
    cliente_ci: number
    _count: FacturaCountAggregateOutputType | null
    _avg: FacturaAvgAggregateOutputType | null
    _sum: FacturaSumAggregateOutputType | null
    _min: FacturaMinAggregateOutputType | null
    _max: FacturaMaxAggregateOutputType | null
  }

  type GetFacturaGroupByPayload<T extends facturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacturaGroupByOutputType[P]>
            : GetScalarType<T[P], FacturaGroupByOutputType[P]>
        }
      >
    >


  export type facturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monto?: boolean
    fecha?: boolean
    cliente_ci?: boolean
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factura"]>

  export type facturaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monto?: boolean
    fecha?: boolean
    cliente_ci?: boolean
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factura"]>

  export type facturaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monto?: boolean
    fecha?: boolean
    cliente_ci?: boolean
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["factura"]>

  export type facturaSelectScalar = {
    id?: boolean
    monto?: boolean
    fecha?: boolean
    cliente_ci?: boolean
  }

  export type facturaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "monto" | "fecha" | "cliente_ci", ExtArgs["result"]["factura"]>
  export type facturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
  }
  export type facturaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
  }
  export type facturaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
  }

  export type $facturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "factura"
    objects: {
      cliente: Prisma.$clientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      monto: Prisma.Decimal
      fecha: Date
      cliente_ci: number
    }, ExtArgs["result"]["factura"]>
    composites: {}
  }

  type facturaGetPayload<S extends boolean | null | undefined | facturaDefaultArgs> = $Result.GetResult<Prisma.$facturaPayload, S>

  type facturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<facturaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacturaCountAggregateInputType | true
    }

  export interface facturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['factura'], meta: { name: 'factura' } }
    /**
     * Find zero or one Factura that matches the filter.
     * @param {facturaFindUniqueArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends facturaFindUniqueArgs>(args: SelectSubset<T, facturaFindUniqueArgs<ExtArgs>>): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Factura that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {facturaFindUniqueOrThrowArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends facturaFindUniqueOrThrowArgs>(args: SelectSubset<T, facturaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Factura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaFindFirstArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends facturaFindFirstArgs>(args?: SelectSubset<T, facturaFindFirstArgs<ExtArgs>>): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Factura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaFindFirstOrThrowArgs} args - Arguments to find a Factura
     * @example
     * // Get one Factura
     * const factura = await prisma.factura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends facturaFindFirstOrThrowArgs>(args?: SelectSubset<T, facturaFindFirstOrThrowArgs<ExtArgs>>): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Facturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facturas
     * const facturas = await prisma.factura.findMany()
     * 
     * // Get first 10 Facturas
     * const facturas = await prisma.factura.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facturaWithIdOnly = await prisma.factura.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends facturaFindManyArgs>(args?: SelectSubset<T, facturaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Factura.
     * @param {facturaCreateArgs} args - Arguments to create a Factura.
     * @example
     * // Create one Factura
     * const Factura = await prisma.factura.create({
     *   data: {
     *     // ... data to create a Factura
     *   }
     * })
     * 
     */
    create<T extends facturaCreateArgs>(args: SelectSubset<T, facturaCreateArgs<ExtArgs>>): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Facturas.
     * @param {facturaCreateManyArgs} args - Arguments to create many Facturas.
     * @example
     * // Create many Facturas
     * const factura = await prisma.factura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends facturaCreateManyArgs>(args?: SelectSubset<T, facturaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facturas and returns the data saved in the database.
     * @param {facturaCreateManyAndReturnArgs} args - Arguments to create many Facturas.
     * @example
     * // Create many Facturas
     * const factura = await prisma.factura.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facturas and only return the `id`
     * const facturaWithIdOnly = await prisma.factura.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends facturaCreateManyAndReturnArgs>(args?: SelectSubset<T, facturaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Factura.
     * @param {facturaDeleteArgs} args - Arguments to delete one Factura.
     * @example
     * // Delete one Factura
     * const Factura = await prisma.factura.delete({
     *   where: {
     *     // ... filter to delete one Factura
     *   }
     * })
     * 
     */
    delete<T extends facturaDeleteArgs>(args: SelectSubset<T, facturaDeleteArgs<ExtArgs>>): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Factura.
     * @param {facturaUpdateArgs} args - Arguments to update one Factura.
     * @example
     * // Update one Factura
     * const factura = await prisma.factura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends facturaUpdateArgs>(args: SelectSubset<T, facturaUpdateArgs<ExtArgs>>): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Facturas.
     * @param {facturaDeleteManyArgs} args - Arguments to filter Facturas to delete.
     * @example
     * // Delete a few Facturas
     * const { count } = await prisma.factura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends facturaDeleteManyArgs>(args?: SelectSubset<T, facturaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facturas
     * const factura = await prisma.factura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends facturaUpdateManyArgs>(args: SelectSubset<T, facturaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facturas and returns the data updated in the database.
     * @param {facturaUpdateManyAndReturnArgs} args - Arguments to update many Facturas.
     * @example
     * // Update many Facturas
     * const factura = await prisma.factura.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Facturas and only return the `id`
     * const facturaWithIdOnly = await prisma.factura.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends facturaUpdateManyAndReturnArgs>(args: SelectSubset<T, facturaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Factura.
     * @param {facturaUpsertArgs} args - Arguments to update or create a Factura.
     * @example
     * // Update or create a Factura
     * const factura = await prisma.factura.upsert({
     *   create: {
     *     // ... data to create a Factura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Factura we want to update
     *   }
     * })
     */
    upsert<T extends facturaUpsertArgs>(args: SelectSubset<T, facturaUpsertArgs<ExtArgs>>): Prisma__facturaClient<$Result.GetResult<Prisma.$facturaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Facturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaCountArgs} args - Arguments to filter Facturas to count.
     * @example
     * // Count the number of Facturas
     * const count = await prisma.factura.count({
     *   where: {
     *     // ... the filter for the Facturas we want to count
     *   }
     * })
    **/
    count<T extends facturaCountArgs>(
      args?: Subset<T, facturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Factura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacturaAggregateArgs>(args: Subset<T, FacturaAggregateArgs>): Prisma.PrismaPromise<GetFacturaAggregateType<T>>

    /**
     * Group by Factura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends facturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: facturaGroupByArgs['orderBy'] }
        : { orderBy?: facturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, facturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the factura model
   */
  readonly fields: facturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for factura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__facturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends clienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clienteDefaultArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the factura model
   */
  interface facturaFieldRefs {
    readonly id: FieldRef<"factura", 'BigInt'>
    readonly monto: FieldRef<"factura", 'Decimal'>
    readonly fecha: FieldRef<"factura", 'DateTime'>
    readonly cliente_ci: FieldRef<"factura", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * factura findUnique
   */
  export type facturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter, which factura to fetch.
     */
    where: facturaWhereUniqueInput
  }

  /**
   * factura findUniqueOrThrow
   */
  export type facturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter, which factura to fetch.
     */
    where: facturaWhereUniqueInput
  }

  /**
   * factura findFirst
   */
  export type facturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter, which factura to fetch.
     */
    where?: facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for facturas.
     */
    cursor?: facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of facturas.
     */
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }

  /**
   * factura findFirstOrThrow
   */
  export type facturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter, which factura to fetch.
     */
    where?: facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for facturas.
     */
    cursor?: facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of facturas.
     */
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }

  /**
   * factura findMany
   */
  export type facturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter, which facturas to fetch.
     */
    where?: facturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of facturas to fetch.
     */
    orderBy?: facturaOrderByWithRelationInput | facturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing facturas.
     */
    cursor?: facturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` facturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` facturas.
     */
    skip?: number
    distinct?: FacturaScalarFieldEnum | FacturaScalarFieldEnum[]
  }

  /**
   * factura create
   */
  export type facturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * The data needed to create a factura.
     */
    data: XOR<facturaCreateInput, facturaUncheckedCreateInput>
  }

  /**
   * factura createMany
   */
  export type facturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many facturas.
     */
    data: facturaCreateManyInput | facturaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * factura createManyAndReturn
   */
  export type facturaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * The data used to create many facturas.
     */
    data: facturaCreateManyInput | facturaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * factura update
   */
  export type facturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * The data needed to update a factura.
     */
    data: XOR<facturaUpdateInput, facturaUncheckedUpdateInput>
    /**
     * Choose, which factura to update.
     */
    where: facturaWhereUniqueInput
  }

  /**
   * factura updateMany
   */
  export type facturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update facturas.
     */
    data: XOR<facturaUpdateManyMutationInput, facturaUncheckedUpdateManyInput>
    /**
     * Filter which facturas to update
     */
    where?: facturaWhereInput
    /**
     * Limit how many facturas to update.
     */
    limit?: number
  }

  /**
   * factura updateManyAndReturn
   */
  export type facturaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * The data used to update facturas.
     */
    data: XOR<facturaUpdateManyMutationInput, facturaUncheckedUpdateManyInput>
    /**
     * Filter which facturas to update
     */
    where?: facturaWhereInput
    /**
     * Limit how many facturas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * factura upsert
   */
  export type facturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * The filter to search for the factura to update in case it exists.
     */
    where: facturaWhereUniqueInput
    /**
     * In case the factura found by the `where` argument doesn't exist, create a new factura with this data.
     */
    create: XOR<facturaCreateInput, facturaUncheckedCreateInput>
    /**
     * In case the factura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<facturaUpdateInput, facturaUncheckedUpdateInput>
  }

  /**
   * factura delete
   */
  export type facturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
    /**
     * Filter which factura to delete.
     */
    where: facturaWhereUniqueInput
  }

  /**
   * factura deleteMany
   */
  export type facturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which facturas to delete
     */
    where?: facturaWhereInput
    /**
     * Limit how many facturas to delete.
     */
    limit?: number
  }

  /**
   * factura without action
   */
  export type facturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factura
     */
    select?: facturaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factura
     */
    omit?: facturaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facturaInclude<ExtArgs> | null
  }


  /**
   * Model herramienta
   */

  export type AggregateHerramienta = {
    _count: HerramientaCountAggregateOutputType | null
    _avg: HerramientaAvgAggregateOutputType | null
    _sum: HerramientaSumAggregateOutputType | null
    _min: HerramientaMinAggregateOutputType | null
    _max: HerramientaMaxAggregateOutputType | null
  }

  export type HerramientaAvgAggregateOutputType = {
    id: number | null
    marca_id: number | null
  }

  export type HerramientaSumAggregateOutputType = {
    id: number | null
    marca_id: number | null
  }

  export type HerramientaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    marca_id: number | null
  }

  export type HerramientaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    marca_id: number | null
  }

  export type HerramientaCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    marca_id: number
    _all: number
  }


  export type HerramientaAvgAggregateInputType = {
    id?: true
    marca_id?: true
  }

  export type HerramientaSumAggregateInputType = {
    id?: true
    marca_id?: true
  }

  export type HerramientaMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    marca_id?: true
  }

  export type HerramientaMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    marca_id?: true
  }

  export type HerramientaCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    marca_id?: true
    _all?: true
  }

  export type HerramientaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which herramienta to aggregate.
     */
    where?: herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of herramientas to fetch.
     */
    orderBy?: herramientaOrderByWithRelationInput | herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` herramientas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned herramientas
    **/
    _count?: true | HerramientaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HerramientaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HerramientaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HerramientaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HerramientaMaxAggregateInputType
  }

  export type GetHerramientaAggregateType<T extends HerramientaAggregateArgs> = {
        [P in keyof T & keyof AggregateHerramienta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHerramienta[P]>
      : GetScalarType<T[P], AggregateHerramienta[P]>
  }




  export type herramientaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: herramientaWhereInput
    orderBy?: herramientaOrderByWithAggregationInput | herramientaOrderByWithAggregationInput[]
    by: HerramientaScalarFieldEnum[] | HerramientaScalarFieldEnum
    having?: herramientaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HerramientaCountAggregateInputType | true
    _avg?: HerramientaAvgAggregateInputType
    _sum?: HerramientaSumAggregateInputType
    _min?: HerramientaMinAggregateInputType
    _max?: HerramientaMaxAggregateInputType
  }

  export type HerramientaGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    marca_id: number
    _count: HerramientaCountAggregateOutputType | null
    _avg: HerramientaAvgAggregateOutputType | null
    _sum: HerramientaSumAggregateOutputType | null
    _min: HerramientaMinAggregateOutputType | null
    _max: HerramientaMaxAggregateOutputType | null
  }

  type GetHerramientaGroupByPayload<T extends herramientaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HerramientaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HerramientaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HerramientaGroupByOutputType[P]>
            : GetScalarType<T[P], HerramientaGroupByOutputType[P]>
        }
      >
    >


  export type herramientaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    marca_id?: boolean
    marca_herramienta?: boolean | marca_herramientaDefaultArgs<ExtArgs>
    movimiento_herramienta?: boolean | herramienta$movimiento_herramientaArgs<ExtArgs>
    _count?: boolean | HerramientaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["herramienta"]>

  export type herramientaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    marca_id?: boolean
    marca_herramienta?: boolean | marca_herramientaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["herramienta"]>

  export type herramientaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    marca_id?: boolean
    marca_herramienta?: boolean | marca_herramientaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["herramienta"]>

  export type herramientaSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    marca_id?: boolean
  }

  export type herramientaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "marca_id", ExtArgs["result"]["herramienta"]>
  export type herramientaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marca_herramienta?: boolean | marca_herramientaDefaultArgs<ExtArgs>
    movimiento_herramienta?: boolean | herramienta$movimiento_herramientaArgs<ExtArgs>
    _count?: boolean | HerramientaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type herramientaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marca_herramienta?: boolean | marca_herramientaDefaultArgs<ExtArgs>
  }
  export type herramientaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marca_herramienta?: boolean | marca_herramientaDefaultArgs<ExtArgs>
  }

  export type $herramientaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "herramienta"
    objects: {
      marca_herramienta: Prisma.$marca_herramientaPayload<ExtArgs>
      movimiento_herramienta: Prisma.$movimiento_herramientaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      marca_id: number
    }, ExtArgs["result"]["herramienta"]>
    composites: {}
  }

  type herramientaGetPayload<S extends boolean | null | undefined | herramientaDefaultArgs> = $Result.GetResult<Prisma.$herramientaPayload, S>

  type herramientaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<herramientaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HerramientaCountAggregateInputType | true
    }

  export interface herramientaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['herramienta'], meta: { name: 'herramienta' } }
    /**
     * Find zero or one Herramienta that matches the filter.
     * @param {herramientaFindUniqueArgs} args - Arguments to find a Herramienta
     * @example
     * // Get one Herramienta
     * const herramienta = await prisma.herramienta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends herramientaFindUniqueArgs>(args: SelectSubset<T, herramientaFindUniqueArgs<ExtArgs>>): Prisma__herramientaClient<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Herramienta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {herramientaFindUniqueOrThrowArgs} args - Arguments to find a Herramienta
     * @example
     * // Get one Herramienta
     * const herramienta = await prisma.herramienta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends herramientaFindUniqueOrThrowArgs>(args: SelectSubset<T, herramientaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__herramientaClient<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Herramienta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {herramientaFindFirstArgs} args - Arguments to find a Herramienta
     * @example
     * // Get one Herramienta
     * const herramienta = await prisma.herramienta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends herramientaFindFirstArgs>(args?: SelectSubset<T, herramientaFindFirstArgs<ExtArgs>>): Prisma__herramientaClient<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Herramienta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {herramientaFindFirstOrThrowArgs} args - Arguments to find a Herramienta
     * @example
     * // Get one Herramienta
     * const herramienta = await prisma.herramienta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends herramientaFindFirstOrThrowArgs>(args?: SelectSubset<T, herramientaFindFirstOrThrowArgs<ExtArgs>>): Prisma__herramientaClient<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Herramientas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {herramientaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Herramientas
     * const herramientas = await prisma.herramienta.findMany()
     * 
     * // Get first 10 Herramientas
     * const herramientas = await prisma.herramienta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const herramientaWithIdOnly = await prisma.herramienta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends herramientaFindManyArgs>(args?: SelectSubset<T, herramientaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Herramienta.
     * @param {herramientaCreateArgs} args - Arguments to create a Herramienta.
     * @example
     * // Create one Herramienta
     * const Herramienta = await prisma.herramienta.create({
     *   data: {
     *     // ... data to create a Herramienta
     *   }
     * })
     * 
     */
    create<T extends herramientaCreateArgs>(args: SelectSubset<T, herramientaCreateArgs<ExtArgs>>): Prisma__herramientaClient<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Herramientas.
     * @param {herramientaCreateManyArgs} args - Arguments to create many Herramientas.
     * @example
     * // Create many Herramientas
     * const herramienta = await prisma.herramienta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends herramientaCreateManyArgs>(args?: SelectSubset<T, herramientaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Herramientas and returns the data saved in the database.
     * @param {herramientaCreateManyAndReturnArgs} args - Arguments to create many Herramientas.
     * @example
     * // Create many Herramientas
     * const herramienta = await prisma.herramienta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Herramientas and only return the `id`
     * const herramientaWithIdOnly = await prisma.herramienta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends herramientaCreateManyAndReturnArgs>(args?: SelectSubset<T, herramientaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Herramienta.
     * @param {herramientaDeleteArgs} args - Arguments to delete one Herramienta.
     * @example
     * // Delete one Herramienta
     * const Herramienta = await prisma.herramienta.delete({
     *   where: {
     *     // ... filter to delete one Herramienta
     *   }
     * })
     * 
     */
    delete<T extends herramientaDeleteArgs>(args: SelectSubset<T, herramientaDeleteArgs<ExtArgs>>): Prisma__herramientaClient<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Herramienta.
     * @param {herramientaUpdateArgs} args - Arguments to update one Herramienta.
     * @example
     * // Update one Herramienta
     * const herramienta = await prisma.herramienta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends herramientaUpdateArgs>(args: SelectSubset<T, herramientaUpdateArgs<ExtArgs>>): Prisma__herramientaClient<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Herramientas.
     * @param {herramientaDeleteManyArgs} args - Arguments to filter Herramientas to delete.
     * @example
     * // Delete a few Herramientas
     * const { count } = await prisma.herramienta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends herramientaDeleteManyArgs>(args?: SelectSubset<T, herramientaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Herramientas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {herramientaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Herramientas
     * const herramienta = await prisma.herramienta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends herramientaUpdateManyArgs>(args: SelectSubset<T, herramientaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Herramientas and returns the data updated in the database.
     * @param {herramientaUpdateManyAndReturnArgs} args - Arguments to update many Herramientas.
     * @example
     * // Update many Herramientas
     * const herramienta = await prisma.herramienta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Herramientas and only return the `id`
     * const herramientaWithIdOnly = await prisma.herramienta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends herramientaUpdateManyAndReturnArgs>(args: SelectSubset<T, herramientaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Herramienta.
     * @param {herramientaUpsertArgs} args - Arguments to update or create a Herramienta.
     * @example
     * // Update or create a Herramienta
     * const herramienta = await prisma.herramienta.upsert({
     *   create: {
     *     // ... data to create a Herramienta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Herramienta we want to update
     *   }
     * })
     */
    upsert<T extends herramientaUpsertArgs>(args: SelectSubset<T, herramientaUpsertArgs<ExtArgs>>): Prisma__herramientaClient<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Herramientas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {herramientaCountArgs} args - Arguments to filter Herramientas to count.
     * @example
     * // Count the number of Herramientas
     * const count = await prisma.herramienta.count({
     *   where: {
     *     // ... the filter for the Herramientas we want to count
     *   }
     * })
    **/
    count<T extends herramientaCountArgs>(
      args?: Subset<T, herramientaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HerramientaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Herramienta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HerramientaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HerramientaAggregateArgs>(args: Subset<T, HerramientaAggregateArgs>): Prisma.PrismaPromise<GetHerramientaAggregateType<T>>

    /**
     * Group by Herramienta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {herramientaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends herramientaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: herramientaGroupByArgs['orderBy'] }
        : { orderBy?: herramientaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, herramientaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHerramientaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the herramienta model
   */
  readonly fields: herramientaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for herramienta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__herramientaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marca_herramienta<T extends marca_herramientaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, marca_herramientaDefaultArgs<ExtArgs>>): Prisma__marca_herramientaClient<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    movimiento_herramienta<T extends herramienta$movimiento_herramientaArgs<ExtArgs> = {}>(args?: Subset<T, herramienta$movimiento_herramientaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the herramienta model
   */
  interface herramientaFieldRefs {
    readonly id: FieldRef<"herramienta", 'Int'>
    readonly nombre: FieldRef<"herramienta", 'String'>
    readonly descripcion: FieldRef<"herramienta", 'String'>
    readonly marca_id: FieldRef<"herramienta", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * herramienta findUnique
   */
  export type herramientaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
    /**
     * Filter, which herramienta to fetch.
     */
    where: herramientaWhereUniqueInput
  }

  /**
   * herramienta findUniqueOrThrow
   */
  export type herramientaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
    /**
     * Filter, which herramienta to fetch.
     */
    where: herramientaWhereUniqueInput
  }

  /**
   * herramienta findFirst
   */
  export type herramientaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
    /**
     * Filter, which herramienta to fetch.
     */
    where?: herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of herramientas to fetch.
     */
    orderBy?: herramientaOrderByWithRelationInput | herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for herramientas.
     */
    cursor?: herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` herramientas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of herramientas.
     */
    distinct?: HerramientaScalarFieldEnum | HerramientaScalarFieldEnum[]
  }

  /**
   * herramienta findFirstOrThrow
   */
  export type herramientaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
    /**
     * Filter, which herramienta to fetch.
     */
    where?: herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of herramientas to fetch.
     */
    orderBy?: herramientaOrderByWithRelationInput | herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for herramientas.
     */
    cursor?: herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` herramientas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of herramientas.
     */
    distinct?: HerramientaScalarFieldEnum | HerramientaScalarFieldEnum[]
  }

  /**
   * herramienta findMany
   */
  export type herramientaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
    /**
     * Filter, which herramientas to fetch.
     */
    where?: herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of herramientas to fetch.
     */
    orderBy?: herramientaOrderByWithRelationInput | herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing herramientas.
     */
    cursor?: herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` herramientas.
     */
    skip?: number
    distinct?: HerramientaScalarFieldEnum | HerramientaScalarFieldEnum[]
  }

  /**
   * herramienta create
   */
  export type herramientaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
    /**
     * The data needed to create a herramienta.
     */
    data: XOR<herramientaCreateInput, herramientaUncheckedCreateInput>
  }

  /**
   * herramienta createMany
   */
  export type herramientaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many herramientas.
     */
    data: herramientaCreateManyInput | herramientaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * herramienta createManyAndReturn
   */
  export type herramientaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * The data used to create many herramientas.
     */
    data: herramientaCreateManyInput | herramientaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * herramienta update
   */
  export type herramientaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
    /**
     * The data needed to update a herramienta.
     */
    data: XOR<herramientaUpdateInput, herramientaUncheckedUpdateInput>
    /**
     * Choose, which herramienta to update.
     */
    where: herramientaWhereUniqueInput
  }

  /**
   * herramienta updateMany
   */
  export type herramientaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update herramientas.
     */
    data: XOR<herramientaUpdateManyMutationInput, herramientaUncheckedUpdateManyInput>
    /**
     * Filter which herramientas to update
     */
    where?: herramientaWhereInput
    /**
     * Limit how many herramientas to update.
     */
    limit?: number
  }

  /**
   * herramienta updateManyAndReturn
   */
  export type herramientaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * The data used to update herramientas.
     */
    data: XOR<herramientaUpdateManyMutationInput, herramientaUncheckedUpdateManyInput>
    /**
     * Filter which herramientas to update
     */
    where?: herramientaWhereInput
    /**
     * Limit how many herramientas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * herramienta upsert
   */
  export type herramientaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
    /**
     * The filter to search for the herramienta to update in case it exists.
     */
    where: herramientaWhereUniqueInput
    /**
     * In case the herramienta found by the `where` argument doesn't exist, create a new herramienta with this data.
     */
    create: XOR<herramientaCreateInput, herramientaUncheckedCreateInput>
    /**
     * In case the herramienta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<herramientaUpdateInput, herramientaUncheckedUpdateInput>
  }

  /**
   * herramienta delete
   */
  export type herramientaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
    /**
     * Filter which herramienta to delete.
     */
    where: herramientaWhereUniqueInput
  }

  /**
   * herramienta deleteMany
   */
  export type herramientaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which herramientas to delete
     */
    where?: herramientaWhereInput
    /**
     * Limit how many herramientas to delete.
     */
    limit?: number
  }

  /**
   * herramienta.movimiento_herramienta
   */
  export type herramienta$movimiento_herramientaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    where?: movimiento_herramientaWhereInput
    orderBy?: movimiento_herramientaOrderByWithRelationInput | movimiento_herramientaOrderByWithRelationInput[]
    cursor?: movimiento_herramientaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Movimiento_herramientaScalarFieldEnum | Movimiento_herramientaScalarFieldEnum[]
  }

  /**
   * herramienta without action
   */
  export type herramientaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
  }


  /**
   * Model horario
   */

  export type AggregateHorario = {
    _count: HorarioCountAggregateOutputType | null
    _avg: HorarioAvgAggregateOutputType | null
    _sum: HorarioSumAggregateOutputType | null
    _min: HorarioMinAggregateOutputType | null
    _max: HorarioMaxAggregateOutputType | null
  }

  export type HorarioAvgAggregateOutputType = {
    id: number | null
  }

  export type HorarioSumAggregateOutputType = {
    id: number | null
  }

  export type HorarioMinAggregateOutputType = {
    id: number | null
    hora_inicio: Date | null
    hora_fin: Date | null
  }

  export type HorarioMaxAggregateOutputType = {
    id: number | null
    hora_inicio: Date | null
    hora_fin: Date | null
  }

  export type HorarioCountAggregateOutputType = {
    id: number
    hora_inicio: number
    hora_fin: number
    _all: number
  }


  export type HorarioAvgAggregateInputType = {
    id?: true
  }

  export type HorarioSumAggregateInputType = {
    id?: true
  }

  export type HorarioMinAggregateInputType = {
    id?: true
    hora_inicio?: true
    hora_fin?: true
  }

  export type HorarioMaxAggregateInputType = {
    id?: true
    hora_inicio?: true
    hora_fin?: true
  }

  export type HorarioCountAggregateInputType = {
    id?: true
    hora_inicio?: true
    hora_fin?: true
    _all?: true
  }

  export type HorarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which horario to aggregate.
     */
    where?: horarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horarios to fetch.
     */
    orderBy?: horarioOrderByWithRelationInput | horarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: horarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned horarios
    **/
    _count?: true | HorarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HorarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HorarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HorarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HorarioMaxAggregateInputType
  }

  export type GetHorarioAggregateType<T extends HorarioAggregateArgs> = {
        [P in keyof T & keyof AggregateHorario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHorario[P]>
      : GetScalarType<T[P], AggregateHorario[P]>
  }




  export type horarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: horarioWhereInput
    orderBy?: horarioOrderByWithAggregationInput | horarioOrderByWithAggregationInput[]
    by: HorarioScalarFieldEnum[] | HorarioScalarFieldEnum
    having?: horarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HorarioCountAggregateInputType | true
    _avg?: HorarioAvgAggregateInputType
    _sum?: HorarioSumAggregateInputType
    _min?: HorarioMinAggregateInputType
    _max?: HorarioMaxAggregateInputType
  }

  export type HorarioGroupByOutputType = {
    id: number
    hora_inicio: Date
    hora_fin: Date
    _count: HorarioCountAggregateOutputType | null
    _avg: HorarioAvgAggregateOutputType | null
    _sum: HorarioSumAggregateOutputType | null
    _min: HorarioMinAggregateOutputType | null
    _max: HorarioMaxAggregateOutputType | null
  }

  type GetHorarioGroupByPayload<T extends horarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HorarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HorarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HorarioGroupByOutputType[P]>
            : GetScalarType<T[P], HorarioGroupByOutputType[P]>
        }
      >
    >


  export type horarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
    horario_empleado?: boolean | horario$horario_empleadoArgs<ExtArgs>
    _count?: boolean | HorarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horario"]>

  export type horarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
  }, ExtArgs["result"]["horario"]>

  export type horarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
  }, ExtArgs["result"]["horario"]>

  export type horarioSelectScalar = {
    id?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
  }

  export type horarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hora_inicio" | "hora_fin", ExtArgs["result"]["horario"]>
  export type horarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    horario_empleado?: boolean | horario$horario_empleadoArgs<ExtArgs>
    _count?: boolean | HorarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type horarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type horarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $horarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "horario"
    objects: {
      horario_empleado: Prisma.$horario_empleadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hora_inicio: Date
      hora_fin: Date
    }, ExtArgs["result"]["horario"]>
    composites: {}
  }

  type horarioGetPayload<S extends boolean | null | undefined | horarioDefaultArgs> = $Result.GetResult<Prisma.$horarioPayload, S>

  type horarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<horarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HorarioCountAggregateInputType | true
    }

  export interface horarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['horario'], meta: { name: 'horario' } }
    /**
     * Find zero or one Horario that matches the filter.
     * @param {horarioFindUniqueArgs} args - Arguments to find a Horario
     * @example
     * // Get one Horario
     * const horario = await prisma.horario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends horarioFindUniqueArgs>(args: SelectSubset<T, horarioFindUniqueArgs<ExtArgs>>): Prisma__horarioClient<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Horario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {horarioFindUniqueOrThrowArgs} args - Arguments to find a Horario
     * @example
     * // Get one Horario
     * const horario = await prisma.horario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends horarioFindUniqueOrThrowArgs>(args: SelectSubset<T, horarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__horarioClient<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Horario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horarioFindFirstArgs} args - Arguments to find a Horario
     * @example
     * // Get one Horario
     * const horario = await prisma.horario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends horarioFindFirstArgs>(args?: SelectSubset<T, horarioFindFirstArgs<ExtArgs>>): Prisma__horarioClient<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Horario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horarioFindFirstOrThrowArgs} args - Arguments to find a Horario
     * @example
     * // Get one Horario
     * const horario = await prisma.horario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends horarioFindFirstOrThrowArgs>(args?: SelectSubset<T, horarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__horarioClient<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Horarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Horarios
     * const horarios = await prisma.horario.findMany()
     * 
     * // Get first 10 Horarios
     * const horarios = await prisma.horario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const horarioWithIdOnly = await prisma.horario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends horarioFindManyArgs>(args?: SelectSubset<T, horarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Horario.
     * @param {horarioCreateArgs} args - Arguments to create a Horario.
     * @example
     * // Create one Horario
     * const Horario = await prisma.horario.create({
     *   data: {
     *     // ... data to create a Horario
     *   }
     * })
     * 
     */
    create<T extends horarioCreateArgs>(args: SelectSubset<T, horarioCreateArgs<ExtArgs>>): Prisma__horarioClient<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Horarios.
     * @param {horarioCreateManyArgs} args - Arguments to create many Horarios.
     * @example
     * // Create many Horarios
     * const horario = await prisma.horario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends horarioCreateManyArgs>(args?: SelectSubset<T, horarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Horarios and returns the data saved in the database.
     * @param {horarioCreateManyAndReturnArgs} args - Arguments to create many Horarios.
     * @example
     * // Create many Horarios
     * const horario = await prisma.horario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Horarios and only return the `id`
     * const horarioWithIdOnly = await prisma.horario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends horarioCreateManyAndReturnArgs>(args?: SelectSubset<T, horarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Horario.
     * @param {horarioDeleteArgs} args - Arguments to delete one Horario.
     * @example
     * // Delete one Horario
     * const Horario = await prisma.horario.delete({
     *   where: {
     *     // ... filter to delete one Horario
     *   }
     * })
     * 
     */
    delete<T extends horarioDeleteArgs>(args: SelectSubset<T, horarioDeleteArgs<ExtArgs>>): Prisma__horarioClient<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Horario.
     * @param {horarioUpdateArgs} args - Arguments to update one Horario.
     * @example
     * // Update one Horario
     * const horario = await prisma.horario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends horarioUpdateArgs>(args: SelectSubset<T, horarioUpdateArgs<ExtArgs>>): Prisma__horarioClient<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Horarios.
     * @param {horarioDeleteManyArgs} args - Arguments to filter Horarios to delete.
     * @example
     * // Delete a few Horarios
     * const { count } = await prisma.horario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends horarioDeleteManyArgs>(args?: SelectSubset<T, horarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Horarios
     * const horario = await prisma.horario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends horarioUpdateManyArgs>(args: SelectSubset<T, horarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Horarios and returns the data updated in the database.
     * @param {horarioUpdateManyAndReturnArgs} args - Arguments to update many Horarios.
     * @example
     * // Update many Horarios
     * const horario = await prisma.horario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Horarios and only return the `id`
     * const horarioWithIdOnly = await prisma.horario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends horarioUpdateManyAndReturnArgs>(args: SelectSubset<T, horarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Horario.
     * @param {horarioUpsertArgs} args - Arguments to update or create a Horario.
     * @example
     * // Update or create a Horario
     * const horario = await prisma.horario.upsert({
     *   create: {
     *     // ... data to create a Horario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Horario we want to update
     *   }
     * })
     */
    upsert<T extends horarioUpsertArgs>(args: SelectSubset<T, horarioUpsertArgs<ExtArgs>>): Prisma__horarioClient<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Horarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horarioCountArgs} args - Arguments to filter Horarios to count.
     * @example
     * // Count the number of Horarios
     * const count = await prisma.horario.count({
     *   where: {
     *     // ... the filter for the Horarios we want to count
     *   }
     * })
    **/
    count<T extends horarioCountArgs>(
      args?: Subset<T, horarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HorarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Horario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HorarioAggregateArgs>(args: Subset<T, HorarioAggregateArgs>): Prisma.PrismaPromise<GetHorarioAggregateType<T>>

    /**
     * Group by Horario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends horarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: horarioGroupByArgs['orderBy'] }
        : { orderBy?: horarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, horarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHorarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the horario model
   */
  readonly fields: horarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for horario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__horarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    horario_empleado<T extends horario$horario_empleadoArgs<ExtArgs> = {}>(args?: Subset<T, horario$horario_empleadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the horario model
   */
  interface horarioFieldRefs {
    readonly id: FieldRef<"horario", 'Int'>
    readonly hora_inicio: FieldRef<"horario", 'DateTime'>
    readonly hora_fin: FieldRef<"horario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * horario findUnique
   */
  export type horarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horarioInclude<ExtArgs> | null
    /**
     * Filter, which horario to fetch.
     */
    where: horarioWhereUniqueInput
  }

  /**
   * horario findUniqueOrThrow
   */
  export type horarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horarioInclude<ExtArgs> | null
    /**
     * Filter, which horario to fetch.
     */
    where: horarioWhereUniqueInput
  }

  /**
   * horario findFirst
   */
  export type horarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horarioInclude<ExtArgs> | null
    /**
     * Filter, which horario to fetch.
     */
    where?: horarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horarios to fetch.
     */
    orderBy?: horarioOrderByWithRelationInput | horarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for horarios.
     */
    cursor?: horarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of horarios.
     */
    distinct?: HorarioScalarFieldEnum | HorarioScalarFieldEnum[]
  }

  /**
   * horario findFirstOrThrow
   */
  export type horarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horarioInclude<ExtArgs> | null
    /**
     * Filter, which horario to fetch.
     */
    where?: horarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horarios to fetch.
     */
    orderBy?: horarioOrderByWithRelationInput | horarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for horarios.
     */
    cursor?: horarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of horarios.
     */
    distinct?: HorarioScalarFieldEnum | HorarioScalarFieldEnum[]
  }

  /**
   * horario findMany
   */
  export type horarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horarioInclude<ExtArgs> | null
    /**
     * Filter, which horarios to fetch.
     */
    where?: horarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horarios to fetch.
     */
    orderBy?: horarioOrderByWithRelationInput | horarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing horarios.
     */
    cursor?: horarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horarios.
     */
    skip?: number
    distinct?: HorarioScalarFieldEnum | HorarioScalarFieldEnum[]
  }

  /**
   * horario create
   */
  export type horarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horarioInclude<ExtArgs> | null
    /**
     * The data needed to create a horario.
     */
    data: XOR<horarioCreateInput, horarioUncheckedCreateInput>
  }

  /**
   * horario createMany
   */
  export type horarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many horarios.
     */
    data: horarioCreateManyInput | horarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * horario createManyAndReturn
   */
  export type horarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * The data used to create many horarios.
     */
    data: horarioCreateManyInput | horarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * horario update
   */
  export type horarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horarioInclude<ExtArgs> | null
    /**
     * The data needed to update a horario.
     */
    data: XOR<horarioUpdateInput, horarioUncheckedUpdateInput>
    /**
     * Choose, which horario to update.
     */
    where: horarioWhereUniqueInput
  }

  /**
   * horario updateMany
   */
  export type horarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update horarios.
     */
    data: XOR<horarioUpdateManyMutationInput, horarioUncheckedUpdateManyInput>
    /**
     * Filter which horarios to update
     */
    where?: horarioWhereInput
    /**
     * Limit how many horarios to update.
     */
    limit?: number
  }

  /**
   * horario updateManyAndReturn
   */
  export type horarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * The data used to update horarios.
     */
    data: XOR<horarioUpdateManyMutationInput, horarioUncheckedUpdateManyInput>
    /**
     * Filter which horarios to update
     */
    where?: horarioWhereInput
    /**
     * Limit how many horarios to update.
     */
    limit?: number
  }

  /**
   * horario upsert
   */
  export type horarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horarioInclude<ExtArgs> | null
    /**
     * The filter to search for the horario to update in case it exists.
     */
    where: horarioWhereUniqueInput
    /**
     * In case the horario found by the `where` argument doesn't exist, create a new horario with this data.
     */
    create: XOR<horarioCreateInput, horarioUncheckedCreateInput>
    /**
     * In case the horario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<horarioUpdateInput, horarioUncheckedUpdateInput>
  }

  /**
   * horario delete
   */
  export type horarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horarioInclude<ExtArgs> | null
    /**
     * Filter which horario to delete.
     */
    where: horarioWhereUniqueInput
  }

  /**
   * horario deleteMany
   */
  export type horarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which horarios to delete
     */
    where?: horarioWhereInput
    /**
     * Limit how many horarios to delete.
     */
    limit?: number
  }

  /**
   * horario.horario_empleado
   */
  export type horario$horario_empleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    where?: horario_empleadoWhereInput
    orderBy?: horario_empleadoOrderByWithRelationInput | horario_empleadoOrderByWithRelationInput[]
    cursor?: horario_empleadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Horario_empleadoScalarFieldEnum | Horario_empleadoScalarFieldEnum[]
  }

  /**
   * horario without action
   */
  export type horarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario
     */
    select?: horarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario
     */
    omit?: horarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horarioInclude<ExtArgs> | null
  }


  /**
   * Model horario_empleado
   */

  export type AggregateHorario_empleado = {
    _count: Horario_empleadoCountAggregateOutputType | null
    _avg: Horario_empleadoAvgAggregateOutputType | null
    _sum: Horario_empleadoSumAggregateOutputType | null
    _min: Horario_empleadoMinAggregateOutputType | null
    _max: Horario_empleadoMaxAggregateOutputType | null
  }

  export type Horario_empleadoAvgAggregateOutputType = {
    empleado_ci: number | null
    horario_id: number | null
  }

  export type Horario_empleadoSumAggregateOutputType = {
    empleado_ci: number | null
    horario_id: number | null
  }

  export type Horario_empleadoMinAggregateOutputType = {
    empleado_ci: number | null
    horario_id: number | null
    fecha: Date | null
  }

  export type Horario_empleadoMaxAggregateOutputType = {
    empleado_ci: number | null
    horario_id: number | null
    fecha: Date | null
  }

  export type Horario_empleadoCountAggregateOutputType = {
    empleado_ci: number
    horario_id: number
    fecha: number
    _all: number
  }


  export type Horario_empleadoAvgAggregateInputType = {
    empleado_ci?: true
    horario_id?: true
  }

  export type Horario_empleadoSumAggregateInputType = {
    empleado_ci?: true
    horario_id?: true
  }

  export type Horario_empleadoMinAggregateInputType = {
    empleado_ci?: true
    horario_id?: true
    fecha?: true
  }

  export type Horario_empleadoMaxAggregateInputType = {
    empleado_ci?: true
    horario_id?: true
    fecha?: true
  }

  export type Horario_empleadoCountAggregateInputType = {
    empleado_ci?: true
    horario_id?: true
    fecha?: true
    _all?: true
  }

  export type Horario_empleadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which horario_empleado to aggregate.
     */
    where?: horario_empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horario_empleados to fetch.
     */
    orderBy?: horario_empleadoOrderByWithRelationInput | horario_empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: horario_empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horario_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horario_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned horario_empleados
    **/
    _count?: true | Horario_empleadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Horario_empleadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Horario_empleadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Horario_empleadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Horario_empleadoMaxAggregateInputType
  }

  export type GetHorario_empleadoAggregateType<T extends Horario_empleadoAggregateArgs> = {
        [P in keyof T & keyof AggregateHorario_empleado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHorario_empleado[P]>
      : GetScalarType<T[P], AggregateHorario_empleado[P]>
  }




  export type horario_empleadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: horario_empleadoWhereInput
    orderBy?: horario_empleadoOrderByWithAggregationInput | horario_empleadoOrderByWithAggregationInput[]
    by: Horario_empleadoScalarFieldEnum[] | Horario_empleadoScalarFieldEnum
    having?: horario_empleadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Horario_empleadoCountAggregateInputType | true
    _avg?: Horario_empleadoAvgAggregateInputType
    _sum?: Horario_empleadoSumAggregateInputType
    _min?: Horario_empleadoMinAggregateInputType
    _max?: Horario_empleadoMaxAggregateInputType
  }

  export type Horario_empleadoGroupByOutputType = {
    empleado_ci: number
    horario_id: number
    fecha: Date
    _count: Horario_empleadoCountAggregateOutputType | null
    _avg: Horario_empleadoAvgAggregateOutputType | null
    _sum: Horario_empleadoSumAggregateOutputType | null
    _min: Horario_empleadoMinAggregateOutputType | null
    _max: Horario_empleadoMaxAggregateOutputType | null
  }

  type GetHorario_empleadoGroupByPayload<T extends horario_empleadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Horario_empleadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Horario_empleadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Horario_empleadoGroupByOutputType[P]>
            : GetScalarType<T[P], Horario_empleadoGroupByOutputType[P]>
        }
      >
    >


  export type horario_empleadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    empleado_ci?: boolean
    horario_id?: boolean
    fecha?: boolean
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    horario?: boolean | horarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horario_empleado"]>

  export type horario_empleadoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    empleado_ci?: boolean
    horario_id?: boolean
    fecha?: boolean
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    horario?: boolean | horarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horario_empleado"]>

  export type horario_empleadoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    empleado_ci?: boolean
    horario_id?: boolean
    fecha?: boolean
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    horario?: boolean | horarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horario_empleado"]>

  export type horario_empleadoSelectScalar = {
    empleado_ci?: boolean
    horario_id?: boolean
    fecha?: boolean
  }

  export type horario_empleadoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"empleado_ci" | "horario_id" | "fecha", ExtArgs["result"]["horario_empleado"]>
  export type horario_empleadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    horario?: boolean | horarioDefaultArgs<ExtArgs>
  }
  export type horario_empleadoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    horario?: boolean | horarioDefaultArgs<ExtArgs>
  }
  export type horario_empleadoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    horario?: boolean | horarioDefaultArgs<ExtArgs>
  }

  export type $horario_empleadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "horario_empleado"
    objects: {
      empleado: Prisma.$empleadoPayload<ExtArgs>
      horario: Prisma.$horarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      empleado_ci: number
      horario_id: number
      fecha: Date
    }, ExtArgs["result"]["horario_empleado"]>
    composites: {}
  }

  type horario_empleadoGetPayload<S extends boolean | null | undefined | horario_empleadoDefaultArgs> = $Result.GetResult<Prisma.$horario_empleadoPayload, S>

  type horario_empleadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<horario_empleadoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Horario_empleadoCountAggregateInputType | true
    }

  export interface horario_empleadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['horario_empleado'], meta: { name: 'horario_empleado' } }
    /**
     * Find zero or one Horario_empleado that matches the filter.
     * @param {horario_empleadoFindUniqueArgs} args - Arguments to find a Horario_empleado
     * @example
     * // Get one Horario_empleado
     * const horario_empleado = await prisma.horario_empleado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends horario_empleadoFindUniqueArgs>(args: SelectSubset<T, horario_empleadoFindUniqueArgs<ExtArgs>>): Prisma__horario_empleadoClient<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Horario_empleado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {horario_empleadoFindUniqueOrThrowArgs} args - Arguments to find a Horario_empleado
     * @example
     * // Get one Horario_empleado
     * const horario_empleado = await prisma.horario_empleado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends horario_empleadoFindUniqueOrThrowArgs>(args: SelectSubset<T, horario_empleadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__horario_empleadoClient<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Horario_empleado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horario_empleadoFindFirstArgs} args - Arguments to find a Horario_empleado
     * @example
     * // Get one Horario_empleado
     * const horario_empleado = await prisma.horario_empleado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends horario_empleadoFindFirstArgs>(args?: SelectSubset<T, horario_empleadoFindFirstArgs<ExtArgs>>): Prisma__horario_empleadoClient<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Horario_empleado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horario_empleadoFindFirstOrThrowArgs} args - Arguments to find a Horario_empleado
     * @example
     * // Get one Horario_empleado
     * const horario_empleado = await prisma.horario_empleado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends horario_empleadoFindFirstOrThrowArgs>(args?: SelectSubset<T, horario_empleadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__horario_empleadoClient<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Horario_empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horario_empleadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Horario_empleados
     * const horario_empleados = await prisma.horario_empleado.findMany()
     * 
     * // Get first 10 Horario_empleados
     * const horario_empleados = await prisma.horario_empleado.findMany({ take: 10 })
     * 
     * // Only select the `empleado_ci`
     * const horario_empleadoWithEmpleado_ciOnly = await prisma.horario_empleado.findMany({ select: { empleado_ci: true } })
     * 
     */
    findMany<T extends horario_empleadoFindManyArgs>(args?: SelectSubset<T, horario_empleadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Horario_empleado.
     * @param {horario_empleadoCreateArgs} args - Arguments to create a Horario_empleado.
     * @example
     * // Create one Horario_empleado
     * const Horario_empleado = await prisma.horario_empleado.create({
     *   data: {
     *     // ... data to create a Horario_empleado
     *   }
     * })
     * 
     */
    create<T extends horario_empleadoCreateArgs>(args: SelectSubset<T, horario_empleadoCreateArgs<ExtArgs>>): Prisma__horario_empleadoClient<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Horario_empleados.
     * @param {horario_empleadoCreateManyArgs} args - Arguments to create many Horario_empleados.
     * @example
     * // Create many Horario_empleados
     * const horario_empleado = await prisma.horario_empleado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends horario_empleadoCreateManyArgs>(args?: SelectSubset<T, horario_empleadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Horario_empleados and returns the data saved in the database.
     * @param {horario_empleadoCreateManyAndReturnArgs} args - Arguments to create many Horario_empleados.
     * @example
     * // Create many Horario_empleados
     * const horario_empleado = await prisma.horario_empleado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Horario_empleados and only return the `empleado_ci`
     * const horario_empleadoWithEmpleado_ciOnly = await prisma.horario_empleado.createManyAndReturn({
     *   select: { empleado_ci: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends horario_empleadoCreateManyAndReturnArgs>(args?: SelectSubset<T, horario_empleadoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Horario_empleado.
     * @param {horario_empleadoDeleteArgs} args - Arguments to delete one Horario_empleado.
     * @example
     * // Delete one Horario_empleado
     * const Horario_empleado = await prisma.horario_empleado.delete({
     *   where: {
     *     // ... filter to delete one Horario_empleado
     *   }
     * })
     * 
     */
    delete<T extends horario_empleadoDeleteArgs>(args: SelectSubset<T, horario_empleadoDeleteArgs<ExtArgs>>): Prisma__horario_empleadoClient<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Horario_empleado.
     * @param {horario_empleadoUpdateArgs} args - Arguments to update one Horario_empleado.
     * @example
     * // Update one Horario_empleado
     * const horario_empleado = await prisma.horario_empleado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends horario_empleadoUpdateArgs>(args: SelectSubset<T, horario_empleadoUpdateArgs<ExtArgs>>): Prisma__horario_empleadoClient<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Horario_empleados.
     * @param {horario_empleadoDeleteManyArgs} args - Arguments to filter Horario_empleados to delete.
     * @example
     * // Delete a few Horario_empleados
     * const { count } = await prisma.horario_empleado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends horario_empleadoDeleteManyArgs>(args?: SelectSubset<T, horario_empleadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Horario_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horario_empleadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Horario_empleados
     * const horario_empleado = await prisma.horario_empleado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends horario_empleadoUpdateManyArgs>(args: SelectSubset<T, horario_empleadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Horario_empleados and returns the data updated in the database.
     * @param {horario_empleadoUpdateManyAndReturnArgs} args - Arguments to update many Horario_empleados.
     * @example
     * // Update many Horario_empleados
     * const horario_empleado = await prisma.horario_empleado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Horario_empleados and only return the `empleado_ci`
     * const horario_empleadoWithEmpleado_ciOnly = await prisma.horario_empleado.updateManyAndReturn({
     *   select: { empleado_ci: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends horario_empleadoUpdateManyAndReturnArgs>(args: SelectSubset<T, horario_empleadoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Horario_empleado.
     * @param {horario_empleadoUpsertArgs} args - Arguments to update or create a Horario_empleado.
     * @example
     * // Update or create a Horario_empleado
     * const horario_empleado = await prisma.horario_empleado.upsert({
     *   create: {
     *     // ... data to create a Horario_empleado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Horario_empleado we want to update
     *   }
     * })
     */
    upsert<T extends horario_empleadoUpsertArgs>(args: SelectSubset<T, horario_empleadoUpsertArgs<ExtArgs>>): Prisma__horario_empleadoClient<$Result.GetResult<Prisma.$horario_empleadoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Horario_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horario_empleadoCountArgs} args - Arguments to filter Horario_empleados to count.
     * @example
     * // Count the number of Horario_empleados
     * const count = await prisma.horario_empleado.count({
     *   where: {
     *     // ... the filter for the Horario_empleados we want to count
     *   }
     * })
    **/
    count<T extends horario_empleadoCountArgs>(
      args?: Subset<T, horario_empleadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Horario_empleadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Horario_empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Horario_empleadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Horario_empleadoAggregateArgs>(args: Subset<T, Horario_empleadoAggregateArgs>): Prisma.PrismaPromise<GetHorario_empleadoAggregateType<T>>

    /**
     * Group by Horario_empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {horario_empleadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends horario_empleadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: horario_empleadoGroupByArgs['orderBy'] }
        : { orderBy?: horario_empleadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, horario_empleadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHorario_empleadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the horario_empleado model
   */
  readonly fields: horario_empleadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for horario_empleado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__horario_empleadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empleado<T extends empleadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, empleadoDefaultArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    horario<T extends horarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, horarioDefaultArgs<ExtArgs>>): Prisma__horarioClient<$Result.GetResult<Prisma.$horarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the horario_empleado model
   */
  interface horario_empleadoFieldRefs {
    readonly empleado_ci: FieldRef<"horario_empleado", 'Int'>
    readonly horario_id: FieldRef<"horario_empleado", 'Int'>
    readonly fecha: FieldRef<"horario_empleado", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * horario_empleado findUnique
   */
  export type horario_empleadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    /**
     * Filter, which horario_empleado to fetch.
     */
    where: horario_empleadoWhereUniqueInput
  }

  /**
   * horario_empleado findUniqueOrThrow
   */
  export type horario_empleadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    /**
     * Filter, which horario_empleado to fetch.
     */
    where: horario_empleadoWhereUniqueInput
  }

  /**
   * horario_empleado findFirst
   */
  export type horario_empleadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    /**
     * Filter, which horario_empleado to fetch.
     */
    where?: horario_empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horario_empleados to fetch.
     */
    orderBy?: horario_empleadoOrderByWithRelationInput | horario_empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for horario_empleados.
     */
    cursor?: horario_empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horario_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horario_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of horario_empleados.
     */
    distinct?: Horario_empleadoScalarFieldEnum | Horario_empleadoScalarFieldEnum[]
  }

  /**
   * horario_empleado findFirstOrThrow
   */
  export type horario_empleadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    /**
     * Filter, which horario_empleado to fetch.
     */
    where?: horario_empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horario_empleados to fetch.
     */
    orderBy?: horario_empleadoOrderByWithRelationInput | horario_empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for horario_empleados.
     */
    cursor?: horario_empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horario_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horario_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of horario_empleados.
     */
    distinct?: Horario_empleadoScalarFieldEnum | Horario_empleadoScalarFieldEnum[]
  }

  /**
   * horario_empleado findMany
   */
  export type horario_empleadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    /**
     * Filter, which horario_empleados to fetch.
     */
    where?: horario_empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of horario_empleados to fetch.
     */
    orderBy?: horario_empleadoOrderByWithRelationInput | horario_empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing horario_empleados.
     */
    cursor?: horario_empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` horario_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` horario_empleados.
     */
    skip?: number
    distinct?: Horario_empleadoScalarFieldEnum | Horario_empleadoScalarFieldEnum[]
  }

  /**
   * horario_empleado create
   */
  export type horario_empleadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    /**
     * The data needed to create a horario_empleado.
     */
    data: XOR<horario_empleadoCreateInput, horario_empleadoUncheckedCreateInput>
  }

  /**
   * horario_empleado createMany
   */
  export type horario_empleadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many horario_empleados.
     */
    data: horario_empleadoCreateManyInput | horario_empleadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * horario_empleado createManyAndReturn
   */
  export type horario_empleadoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * The data used to create many horario_empleados.
     */
    data: horario_empleadoCreateManyInput | horario_empleadoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * horario_empleado update
   */
  export type horario_empleadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    /**
     * The data needed to update a horario_empleado.
     */
    data: XOR<horario_empleadoUpdateInput, horario_empleadoUncheckedUpdateInput>
    /**
     * Choose, which horario_empleado to update.
     */
    where: horario_empleadoWhereUniqueInput
  }

  /**
   * horario_empleado updateMany
   */
  export type horario_empleadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update horario_empleados.
     */
    data: XOR<horario_empleadoUpdateManyMutationInput, horario_empleadoUncheckedUpdateManyInput>
    /**
     * Filter which horario_empleados to update
     */
    where?: horario_empleadoWhereInput
    /**
     * Limit how many horario_empleados to update.
     */
    limit?: number
  }

  /**
   * horario_empleado updateManyAndReturn
   */
  export type horario_empleadoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * The data used to update horario_empleados.
     */
    data: XOR<horario_empleadoUpdateManyMutationInput, horario_empleadoUncheckedUpdateManyInput>
    /**
     * Filter which horario_empleados to update
     */
    where?: horario_empleadoWhereInput
    /**
     * Limit how many horario_empleados to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * horario_empleado upsert
   */
  export type horario_empleadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    /**
     * The filter to search for the horario_empleado to update in case it exists.
     */
    where: horario_empleadoWhereUniqueInput
    /**
     * In case the horario_empleado found by the `where` argument doesn't exist, create a new horario_empleado with this data.
     */
    create: XOR<horario_empleadoCreateInput, horario_empleadoUncheckedCreateInput>
    /**
     * In case the horario_empleado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<horario_empleadoUpdateInput, horario_empleadoUncheckedUpdateInput>
  }

  /**
   * horario_empleado delete
   */
  export type horario_empleadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
    /**
     * Filter which horario_empleado to delete.
     */
    where: horario_empleadoWhereUniqueInput
  }

  /**
   * horario_empleado deleteMany
   */
  export type horario_empleadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which horario_empleados to delete
     */
    where?: horario_empleadoWhereInput
    /**
     * Limit how many horario_empleados to delete.
     */
    limit?: number
  }

  /**
   * horario_empleado without action
   */
  export type horario_empleadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the horario_empleado
     */
    select?: horario_empleadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the horario_empleado
     */
    omit?: horario_empleadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: horario_empleadoInclude<ExtArgs> | null
  }


  /**
   * Model marca_herramienta
   */

  export type AggregateMarca_herramienta = {
    _count: Marca_herramientaCountAggregateOutputType | null
    _avg: Marca_herramientaAvgAggregateOutputType | null
    _sum: Marca_herramientaSumAggregateOutputType | null
    _min: Marca_herramientaMinAggregateOutputType | null
    _max: Marca_herramientaMaxAggregateOutputType | null
  }

  export type Marca_herramientaAvgAggregateOutputType = {
    id: number | null
  }

  export type Marca_herramientaSumAggregateOutputType = {
    id: number | null
  }

  export type Marca_herramientaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type Marca_herramientaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type Marca_herramientaCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type Marca_herramientaAvgAggregateInputType = {
    id?: true
  }

  export type Marca_herramientaSumAggregateInputType = {
    id?: true
  }

  export type Marca_herramientaMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type Marca_herramientaMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type Marca_herramientaCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type Marca_herramientaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marca_herramienta to aggregate.
     */
    where?: marca_herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marca_herramientas to fetch.
     */
    orderBy?: marca_herramientaOrderByWithRelationInput | marca_herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: marca_herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marca_herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marca_herramientas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned marca_herramientas
    **/
    _count?: true | Marca_herramientaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Marca_herramientaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Marca_herramientaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Marca_herramientaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Marca_herramientaMaxAggregateInputType
  }

  export type GetMarca_herramientaAggregateType<T extends Marca_herramientaAggregateArgs> = {
        [P in keyof T & keyof AggregateMarca_herramienta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarca_herramienta[P]>
      : GetScalarType<T[P], AggregateMarca_herramienta[P]>
  }




  export type marca_herramientaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: marca_herramientaWhereInput
    orderBy?: marca_herramientaOrderByWithAggregationInput | marca_herramientaOrderByWithAggregationInput[]
    by: Marca_herramientaScalarFieldEnum[] | Marca_herramientaScalarFieldEnum
    having?: marca_herramientaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Marca_herramientaCountAggregateInputType | true
    _avg?: Marca_herramientaAvgAggregateInputType
    _sum?: Marca_herramientaSumAggregateInputType
    _min?: Marca_herramientaMinAggregateInputType
    _max?: Marca_herramientaMaxAggregateInputType
  }

  export type Marca_herramientaGroupByOutputType = {
    id: number
    nombre: string
    _count: Marca_herramientaCountAggregateOutputType | null
    _avg: Marca_herramientaAvgAggregateOutputType | null
    _sum: Marca_herramientaSumAggregateOutputType | null
    _min: Marca_herramientaMinAggregateOutputType | null
    _max: Marca_herramientaMaxAggregateOutputType | null
  }

  type GetMarca_herramientaGroupByPayload<T extends marca_herramientaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Marca_herramientaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Marca_herramientaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Marca_herramientaGroupByOutputType[P]>
            : GetScalarType<T[P], Marca_herramientaGroupByOutputType[P]>
        }
      >
    >


  export type marca_herramientaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    herramienta?: boolean | marca_herramienta$herramientaArgs<ExtArgs>
    _count?: boolean | Marca_herramientaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marca_herramienta"]>

  export type marca_herramientaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["marca_herramienta"]>

  export type marca_herramientaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["marca_herramienta"]>

  export type marca_herramientaSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type marca_herramientaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre", ExtArgs["result"]["marca_herramienta"]>
  export type marca_herramientaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    herramienta?: boolean | marca_herramienta$herramientaArgs<ExtArgs>
    _count?: boolean | Marca_herramientaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type marca_herramientaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type marca_herramientaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $marca_herramientaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "marca_herramienta"
    objects: {
      herramienta: Prisma.$herramientaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["marca_herramienta"]>
    composites: {}
  }

  type marca_herramientaGetPayload<S extends boolean | null | undefined | marca_herramientaDefaultArgs> = $Result.GetResult<Prisma.$marca_herramientaPayload, S>

  type marca_herramientaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<marca_herramientaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Marca_herramientaCountAggregateInputType | true
    }

  export interface marca_herramientaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['marca_herramienta'], meta: { name: 'marca_herramienta' } }
    /**
     * Find zero or one Marca_herramienta that matches the filter.
     * @param {marca_herramientaFindUniqueArgs} args - Arguments to find a Marca_herramienta
     * @example
     * // Get one Marca_herramienta
     * const marca_herramienta = await prisma.marca_herramienta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends marca_herramientaFindUniqueArgs>(args: SelectSubset<T, marca_herramientaFindUniqueArgs<ExtArgs>>): Prisma__marca_herramientaClient<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Marca_herramienta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {marca_herramientaFindUniqueOrThrowArgs} args - Arguments to find a Marca_herramienta
     * @example
     * // Get one Marca_herramienta
     * const marca_herramienta = await prisma.marca_herramienta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends marca_herramientaFindUniqueOrThrowArgs>(args: SelectSubset<T, marca_herramientaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__marca_herramientaClient<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marca_herramienta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_herramientaFindFirstArgs} args - Arguments to find a Marca_herramienta
     * @example
     * // Get one Marca_herramienta
     * const marca_herramienta = await prisma.marca_herramienta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends marca_herramientaFindFirstArgs>(args?: SelectSubset<T, marca_herramientaFindFirstArgs<ExtArgs>>): Prisma__marca_herramientaClient<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marca_herramienta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_herramientaFindFirstOrThrowArgs} args - Arguments to find a Marca_herramienta
     * @example
     * // Get one Marca_herramienta
     * const marca_herramienta = await prisma.marca_herramienta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends marca_herramientaFindFirstOrThrowArgs>(args?: SelectSubset<T, marca_herramientaFindFirstOrThrowArgs<ExtArgs>>): Prisma__marca_herramientaClient<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Marca_herramientas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_herramientaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marca_herramientas
     * const marca_herramientas = await prisma.marca_herramienta.findMany()
     * 
     * // Get first 10 Marca_herramientas
     * const marca_herramientas = await prisma.marca_herramienta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marca_herramientaWithIdOnly = await prisma.marca_herramienta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends marca_herramientaFindManyArgs>(args?: SelectSubset<T, marca_herramientaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Marca_herramienta.
     * @param {marca_herramientaCreateArgs} args - Arguments to create a Marca_herramienta.
     * @example
     * // Create one Marca_herramienta
     * const Marca_herramienta = await prisma.marca_herramienta.create({
     *   data: {
     *     // ... data to create a Marca_herramienta
     *   }
     * })
     * 
     */
    create<T extends marca_herramientaCreateArgs>(args: SelectSubset<T, marca_herramientaCreateArgs<ExtArgs>>): Prisma__marca_herramientaClient<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Marca_herramientas.
     * @param {marca_herramientaCreateManyArgs} args - Arguments to create many Marca_herramientas.
     * @example
     * // Create many Marca_herramientas
     * const marca_herramienta = await prisma.marca_herramienta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends marca_herramientaCreateManyArgs>(args?: SelectSubset<T, marca_herramientaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Marca_herramientas and returns the data saved in the database.
     * @param {marca_herramientaCreateManyAndReturnArgs} args - Arguments to create many Marca_herramientas.
     * @example
     * // Create many Marca_herramientas
     * const marca_herramienta = await prisma.marca_herramienta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Marca_herramientas and only return the `id`
     * const marca_herramientaWithIdOnly = await prisma.marca_herramienta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends marca_herramientaCreateManyAndReturnArgs>(args?: SelectSubset<T, marca_herramientaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Marca_herramienta.
     * @param {marca_herramientaDeleteArgs} args - Arguments to delete one Marca_herramienta.
     * @example
     * // Delete one Marca_herramienta
     * const Marca_herramienta = await prisma.marca_herramienta.delete({
     *   where: {
     *     // ... filter to delete one Marca_herramienta
     *   }
     * })
     * 
     */
    delete<T extends marca_herramientaDeleteArgs>(args: SelectSubset<T, marca_herramientaDeleteArgs<ExtArgs>>): Prisma__marca_herramientaClient<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Marca_herramienta.
     * @param {marca_herramientaUpdateArgs} args - Arguments to update one Marca_herramienta.
     * @example
     * // Update one Marca_herramienta
     * const marca_herramienta = await prisma.marca_herramienta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends marca_herramientaUpdateArgs>(args: SelectSubset<T, marca_herramientaUpdateArgs<ExtArgs>>): Prisma__marca_herramientaClient<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Marca_herramientas.
     * @param {marca_herramientaDeleteManyArgs} args - Arguments to filter Marca_herramientas to delete.
     * @example
     * // Delete a few Marca_herramientas
     * const { count } = await prisma.marca_herramienta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends marca_herramientaDeleteManyArgs>(args?: SelectSubset<T, marca_herramientaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marca_herramientas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_herramientaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marca_herramientas
     * const marca_herramienta = await prisma.marca_herramienta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends marca_herramientaUpdateManyArgs>(args: SelectSubset<T, marca_herramientaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marca_herramientas and returns the data updated in the database.
     * @param {marca_herramientaUpdateManyAndReturnArgs} args - Arguments to update many Marca_herramientas.
     * @example
     * // Update many Marca_herramientas
     * const marca_herramienta = await prisma.marca_herramienta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Marca_herramientas and only return the `id`
     * const marca_herramientaWithIdOnly = await prisma.marca_herramienta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends marca_herramientaUpdateManyAndReturnArgs>(args: SelectSubset<T, marca_herramientaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Marca_herramienta.
     * @param {marca_herramientaUpsertArgs} args - Arguments to update or create a Marca_herramienta.
     * @example
     * // Update or create a Marca_herramienta
     * const marca_herramienta = await prisma.marca_herramienta.upsert({
     *   create: {
     *     // ... data to create a Marca_herramienta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marca_herramienta we want to update
     *   }
     * })
     */
    upsert<T extends marca_herramientaUpsertArgs>(args: SelectSubset<T, marca_herramientaUpsertArgs<ExtArgs>>): Prisma__marca_herramientaClient<$Result.GetResult<Prisma.$marca_herramientaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Marca_herramientas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_herramientaCountArgs} args - Arguments to filter Marca_herramientas to count.
     * @example
     * // Count the number of Marca_herramientas
     * const count = await prisma.marca_herramienta.count({
     *   where: {
     *     // ... the filter for the Marca_herramientas we want to count
     *   }
     * })
    **/
    count<T extends marca_herramientaCountArgs>(
      args?: Subset<T, marca_herramientaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Marca_herramientaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marca_herramienta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Marca_herramientaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Marca_herramientaAggregateArgs>(args: Subset<T, Marca_herramientaAggregateArgs>): Prisma.PrismaPromise<GetMarca_herramientaAggregateType<T>>

    /**
     * Group by Marca_herramienta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_herramientaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends marca_herramientaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: marca_herramientaGroupByArgs['orderBy'] }
        : { orderBy?: marca_herramientaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, marca_herramientaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarca_herramientaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the marca_herramienta model
   */
  readonly fields: marca_herramientaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for marca_herramienta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__marca_herramientaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    herramienta<T extends marca_herramienta$herramientaArgs<ExtArgs> = {}>(args?: Subset<T, marca_herramienta$herramientaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the marca_herramienta model
   */
  interface marca_herramientaFieldRefs {
    readonly id: FieldRef<"marca_herramienta", 'Int'>
    readonly nombre: FieldRef<"marca_herramienta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * marca_herramienta findUnique
   */
  export type marca_herramientaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_herramientaInclude<ExtArgs> | null
    /**
     * Filter, which marca_herramienta to fetch.
     */
    where: marca_herramientaWhereUniqueInput
  }

  /**
   * marca_herramienta findUniqueOrThrow
   */
  export type marca_herramientaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_herramientaInclude<ExtArgs> | null
    /**
     * Filter, which marca_herramienta to fetch.
     */
    where: marca_herramientaWhereUniqueInput
  }

  /**
   * marca_herramienta findFirst
   */
  export type marca_herramientaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_herramientaInclude<ExtArgs> | null
    /**
     * Filter, which marca_herramienta to fetch.
     */
    where?: marca_herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marca_herramientas to fetch.
     */
    orderBy?: marca_herramientaOrderByWithRelationInput | marca_herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marca_herramientas.
     */
    cursor?: marca_herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marca_herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marca_herramientas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marca_herramientas.
     */
    distinct?: Marca_herramientaScalarFieldEnum | Marca_herramientaScalarFieldEnum[]
  }

  /**
   * marca_herramienta findFirstOrThrow
   */
  export type marca_herramientaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_herramientaInclude<ExtArgs> | null
    /**
     * Filter, which marca_herramienta to fetch.
     */
    where?: marca_herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marca_herramientas to fetch.
     */
    orderBy?: marca_herramientaOrderByWithRelationInput | marca_herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marca_herramientas.
     */
    cursor?: marca_herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marca_herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marca_herramientas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marca_herramientas.
     */
    distinct?: Marca_herramientaScalarFieldEnum | Marca_herramientaScalarFieldEnum[]
  }

  /**
   * marca_herramienta findMany
   */
  export type marca_herramientaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_herramientaInclude<ExtArgs> | null
    /**
     * Filter, which marca_herramientas to fetch.
     */
    where?: marca_herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marca_herramientas to fetch.
     */
    orderBy?: marca_herramientaOrderByWithRelationInput | marca_herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing marca_herramientas.
     */
    cursor?: marca_herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marca_herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marca_herramientas.
     */
    skip?: number
    distinct?: Marca_herramientaScalarFieldEnum | Marca_herramientaScalarFieldEnum[]
  }

  /**
   * marca_herramienta create
   */
  export type marca_herramientaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_herramientaInclude<ExtArgs> | null
    /**
     * The data needed to create a marca_herramienta.
     */
    data: XOR<marca_herramientaCreateInput, marca_herramientaUncheckedCreateInput>
  }

  /**
   * marca_herramienta createMany
   */
  export type marca_herramientaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many marca_herramientas.
     */
    data: marca_herramientaCreateManyInput | marca_herramientaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * marca_herramienta createManyAndReturn
   */
  export type marca_herramientaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * The data used to create many marca_herramientas.
     */
    data: marca_herramientaCreateManyInput | marca_herramientaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * marca_herramienta update
   */
  export type marca_herramientaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_herramientaInclude<ExtArgs> | null
    /**
     * The data needed to update a marca_herramienta.
     */
    data: XOR<marca_herramientaUpdateInput, marca_herramientaUncheckedUpdateInput>
    /**
     * Choose, which marca_herramienta to update.
     */
    where: marca_herramientaWhereUniqueInput
  }

  /**
   * marca_herramienta updateMany
   */
  export type marca_herramientaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update marca_herramientas.
     */
    data: XOR<marca_herramientaUpdateManyMutationInput, marca_herramientaUncheckedUpdateManyInput>
    /**
     * Filter which marca_herramientas to update
     */
    where?: marca_herramientaWhereInput
    /**
     * Limit how many marca_herramientas to update.
     */
    limit?: number
  }

  /**
   * marca_herramienta updateManyAndReturn
   */
  export type marca_herramientaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * The data used to update marca_herramientas.
     */
    data: XOR<marca_herramientaUpdateManyMutationInput, marca_herramientaUncheckedUpdateManyInput>
    /**
     * Filter which marca_herramientas to update
     */
    where?: marca_herramientaWhereInput
    /**
     * Limit how many marca_herramientas to update.
     */
    limit?: number
  }

  /**
   * marca_herramienta upsert
   */
  export type marca_herramientaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_herramientaInclude<ExtArgs> | null
    /**
     * The filter to search for the marca_herramienta to update in case it exists.
     */
    where: marca_herramientaWhereUniqueInput
    /**
     * In case the marca_herramienta found by the `where` argument doesn't exist, create a new marca_herramienta with this data.
     */
    create: XOR<marca_herramientaCreateInput, marca_herramientaUncheckedCreateInput>
    /**
     * In case the marca_herramienta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<marca_herramientaUpdateInput, marca_herramientaUncheckedUpdateInput>
  }

  /**
   * marca_herramienta delete
   */
  export type marca_herramientaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_herramientaInclude<ExtArgs> | null
    /**
     * Filter which marca_herramienta to delete.
     */
    where: marca_herramientaWhereUniqueInput
  }

  /**
   * marca_herramienta deleteMany
   */
  export type marca_herramientaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marca_herramientas to delete
     */
    where?: marca_herramientaWhereInput
    /**
     * Limit how many marca_herramientas to delete.
     */
    limit?: number
  }

  /**
   * marca_herramienta.herramienta
   */
  export type marca_herramienta$herramientaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the herramienta
     */
    select?: herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the herramienta
     */
    omit?: herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: herramientaInclude<ExtArgs> | null
    where?: herramientaWhereInput
    orderBy?: herramientaOrderByWithRelationInput | herramientaOrderByWithRelationInput[]
    cursor?: herramientaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HerramientaScalarFieldEnum | HerramientaScalarFieldEnum[]
  }

  /**
   * marca_herramienta without action
   */
  export type marca_herramientaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_herramienta
     */
    select?: marca_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_herramienta
     */
    omit?: marca_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_herramientaInclude<ExtArgs> | null
  }


  /**
   * Model marca_moto
   */

  export type AggregateMarca_moto = {
    _count: Marca_motoCountAggregateOutputType | null
    _avg: Marca_motoAvgAggregateOutputType | null
    _sum: Marca_motoSumAggregateOutputType | null
    _min: Marca_motoMinAggregateOutputType | null
    _max: Marca_motoMaxAggregateOutputType | null
  }

  export type Marca_motoAvgAggregateOutputType = {
    id: number | null
  }

  export type Marca_motoSumAggregateOutputType = {
    id: number | null
  }

  export type Marca_motoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type Marca_motoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type Marca_motoCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type Marca_motoAvgAggregateInputType = {
    id?: true
  }

  export type Marca_motoSumAggregateInputType = {
    id?: true
  }

  export type Marca_motoMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type Marca_motoMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type Marca_motoCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type Marca_motoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marca_moto to aggregate.
     */
    where?: marca_motoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marca_motos to fetch.
     */
    orderBy?: marca_motoOrderByWithRelationInput | marca_motoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: marca_motoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marca_motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marca_motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned marca_motos
    **/
    _count?: true | Marca_motoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Marca_motoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Marca_motoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Marca_motoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Marca_motoMaxAggregateInputType
  }

  export type GetMarca_motoAggregateType<T extends Marca_motoAggregateArgs> = {
        [P in keyof T & keyof AggregateMarca_moto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarca_moto[P]>
      : GetScalarType<T[P], AggregateMarca_moto[P]>
  }




  export type marca_motoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: marca_motoWhereInput
    orderBy?: marca_motoOrderByWithAggregationInput | marca_motoOrderByWithAggregationInput[]
    by: Marca_motoScalarFieldEnum[] | Marca_motoScalarFieldEnum
    having?: marca_motoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Marca_motoCountAggregateInputType | true
    _avg?: Marca_motoAvgAggregateInputType
    _sum?: Marca_motoSumAggregateInputType
    _min?: Marca_motoMinAggregateInputType
    _max?: Marca_motoMaxAggregateInputType
  }

  export type Marca_motoGroupByOutputType = {
    id: number
    nombre: string
    _count: Marca_motoCountAggregateOutputType | null
    _avg: Marca_motoAvgAggregateOutputType | null
    _sum: Marca_motoSumAggregateOutputType | null
    _min: Marca_motoMinAggregateOutputType | null
    _max: Marca_motoMaxAggregateOutputType | null
  }

  type GetMarca_motoGroupByPayload<T extends marca_motoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Marca_motoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Marca_motoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Marca_motoGroupByOutputType[P]>
            : GetScalarType<T[P], Marca_motoGroupByOutputType[P]>
        }
      >
    >


  export type marca_motoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    moto?: boolean | marca_moto$motoArgs<ExtArgs>
    _count?: boolean | Marca_motoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marca_moto"]>

  export type marca_motoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["marca_moto"]>

  export type marca_motoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["marca_moto"]>

  export type marca_motoSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type marca_motoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre", ExtArgs["result"]["marca_moto"]>
  export type marca_motoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moto?: boolean | marca_moto$motoArgs<ExtArgs>
    _count?: boolean | Marca_motoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type marca_motoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type marca_motoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $marca_motoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "marca_moto"
    objects: {
      moto: Prisma.$motoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["marca_moto"]>
    composites: {}
  }

  type marca_motoGetPayload<S extends boolean | null | undefined | marca_motoDefaultArgs> = $Result.GetResult<Prisma.$marca_motoPayload, S>

  type marca_motoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<marca_motoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Marca_motoCountAggregateInputType | true
    }

  export interface marca_motoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['marca_moto'], meta: { name: 'marca_moto' } }
    /**
     * Find zero or one Marca_moto that matches the filter.
     * @param {marca_motoFindUniqueArgs} args - Arguments to find a Marca_moto
     * @example
     * // Get one Marca_moto
     * const marca_moto = await prisma.marca_moto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends marca_motoFindUniqueArgs>(args: SelectSubset<T, marca_motoFindUniqueArgs<ExtArgs>>): Prisma__marca_motoClient<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Marca_moto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {marca_motoFindUniqueOrThrowArgs} args - Arguments to find a Marca_moto
     * @example
     * // Get one Marca_moto
     * const marca_moto = await prisma.marca_moto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends marca_motoFindUniqueOrThrowArgs>(args: SelectSubset<T, marca_motoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__marca_motoClient<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marca_moto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_motoFindFirstArgs} args - Arguments to find a Marca_moto
     * @example
     * // Get one Marca_moto
     * const marca_moto = await prisma.marca_moto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends marca_motoFindFirstArgs>(args?: SelectSubset<T, marca_motoFindFirstArgs<ExtArgs>>): Prisma__marca_motoClient<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marca_moto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_motoFindFirstOrThrowArgs} args - Arguments to find a Marca_moto
     * @example
     * // Get one Marca_moto
     * const marca_moto = await prisma.marca_moto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends marca_motoFindFirstOrThrowArgs>(args?: SelectSubset<T, marca_motoFindFirstOrThrowArgs<ExtArgs>>): Prisma__marca_motoClient<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Marca_motos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_motoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marca_motos
     * const marca_motos = await prisma.marca_moto.findMany()
     * 
     * // Get first 10 Marca_motos
     * const marca_motos = await prisma.marca_moto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marca_motoWithIdOnly = await prisma.marca_moto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends marca_motoFindManyArgs>(args?: SelectSubset<T, marca_motoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Marca_moto.
     * @param {marca_motoCreateArgs} args - Arguments to create a Marca_moto.
     * @example
     * // Create one Marca_moto
     * const Marca_moto = await prisma.marca_moto.create({
     *   data: {
     *     // ... data to create a Marca_moto
     *   }
     * })
     * 
     */
    create<T extends marca_motoCreateArgs>(args: SelectSubset<T, marca_motoCreateArgs<ExtArgs>>): Prisma__marca_motoClient<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Marca_motos.
     * @param {marca_motoCreateManyArgs} args - Arguments to create many Marca_motos.
     * @example
     * // Create many Marca_motos
     * const marca_moto = await prisma.marca_moto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends marca_motoCreateManyArgs>(args?: SelectSubset<T, marca_motoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Marca_motos and returns the data saved in the database.
     * @param {marca_motoCreateManyAndReturnArgs} args - Arguments to create many Marca_motos.
     * @example
     * // Create many Marca_motos
     * const marca_moto = await prisma.marca_moto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Marca_motos and only return the `id`
     * const marca_motoWithIdOnly = await prisma.marca_moto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends marca_motoCreateManyAndReturnArgs>(args?: SelectSubset<T, marca_motoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Marca_moto.
     * @param {marca_motoDeleteArgs} args - Arguments to delete one Marca_moto.
     * @example
     * // Delete one Marca_moto
     * const Marca_moto = await prisma.marca_moto.delete({
     *   where: {
     *     // ... filter to delete one Marca_moto
     *   }
     * })
     * 
     */
    delete<T extends marca_motoDeleteArgs>(args: SelectSubset<T, marca_motoDeleteArgs<ExtArgs>>): Prisma__marca_motoClient<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Marca_moto.
     * @param {marca_motoUpdateArgs} args - Arguments to update one Marca_moto.
     * @example
     * // Update one Marca_moto
     * const marca_moto = await prisma.marca_moto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends marca_motoUpdateArgs>(args: SelectSubset<T, marca_motoUpdateArgs<ExtArgs>>): Prisma__marca_motoClient<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Marca_motos.
     * @param {marca_motoDeleteManyArgs} args - Arguments to filter Marca_motos to delete.
     * @example
     * // Delete a few Marca_motos
     * const { count } = await prisma.marca_moto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends marca_motoDeleteManyArgs>(args?: SelectSubset<T, marca_motoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marca_motos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_motoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marca_motos
     * const marca_moto = await prisma.marca_moto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends marca_motoUpdateManyArgs>(args: SelectSubset<T, marca_motoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marca_motos and returns the data updated in the database.
     * @param {marca_motoUpdateManyAndReturnArgs} args - Arguments to update many Marca_motos.
     * @example
     * // Update many Marca_motos
     * const marca_moto = await prisma.marca_moto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Marca_motos and only return the `id`
     * const marca_motoWithIdOnly = await prisma.marca_moto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends marca_motoUpdateManyAndReturnArgs>(args: SelectSubset<T, marca_motoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Marca_moto.
     * @param {marca_motoUpsertArgs} args - Arguments to update or create a Marca_moto.
     * @example
     * // Update or create a Marca_moto
     * const marca_moto = await prisma.marca_moto.upsert({
     *   create: {
     *     // ... data to create a Marca_moto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marca_moto we want to update
     *   }
     * })
     */
    upsert<T extends marca_motoUpsertArgs>(args: SelectSubset<T, marca_motoUpsertArgs<ExtArgs>>): Prisma__marca_motoClient<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Marca_motos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_motoCountArgs} args - Arguments to filter Marca_motos to count.
     * @example
     * // Count the number of Marca_motos
     * const count = await prisma.marca_moto.count({
     *   where: {
     *     // ... the filter for the Marca_motos we want to count
     *   }
     * })
    **/
    count<T extends marca_motoCountArgs>(
      args?: Subset<T, marca_motoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Marca_motoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marca_moto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Marca_motoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Marca_motoAggregateArgs>(args: Subset<T, Marca_motoAggregateArgs>): Prisma.PrismaPromise<GetMarca_motoAggregateType<T>>

    /**
     * Group by Marca_moto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marca_motoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends marca_motoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: marca_motoGroupByArgs['orderBy'] }
        : { orderBy?: marca_motoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, marca_motoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarca_motoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the marca_moto model
   */
  readonly fields: marca_motoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for marca_moto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__marca_motoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    moto<T extends marca_moto$motoArgs<ExtArgs> = {}>(args?: Subset<T, marca_moto$motoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the marca_moto model
   */
  interface marca_motoFieldRefs {
    readonly id: FieldRef<"marca_moto", 'Int'>
    readonly nombre: FieldRef<"marca_moto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * marca_moto findUnique
   */
  export type marca_motoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_motoInclude<ExtArgs> | null
    /**
     * Filter, which marca_moto to fetch.
     */
    where: marca_motoWhereUniqueInput
  }

  /**
   * marca_moto findUniqueOrThrow
   */
  export type marca_motoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_motoInclude<ExtArgs> | null
    /**
     * Filter, which marca_moto to fetch.
     */
    where: marca_motoWhereUniqueInput
  }

  /**
   * marca_moto findFirst
   */
  export type marca_motoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_motoInclude<ExtArgs> | null
    /**
     * Filter, which marca_moto to fetch.
     */
    where?: marca_motoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marca_motos to fetch.
     */
    orderBy?: marca_motoOrderByWithRelationInput | marca_motoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marca_motos.
     */
    cursor?: marca_motoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marca_motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marca_motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marca_motos.
     */
    distinct?: Marca_motoScalarFieldEnum | Marca_motoScalarFieldEnum[]
  }

  /**
   * marca_moto findFirstOrThrow
   */
  export type marca_motoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_motoInclude<ExtArgs> | null
    /**
     * Filter, which marca_moto to fetch.
     */
    where?: marca_motoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marca_motos to fetch.
     */
    orderBy?: marca_motoOrderByWithRelationInput | marca_motoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marca_motos.
     */
    cursor?: marca_motoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marca_motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marca_motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marca_motos.
     */
    distinct?: Marca_motoScalarFieldEnum | Marca_motoScalarFieldEnum[]
  }

  /**
   * marca_moto findMany
   */
  export type marca_motoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_motoInclude<ExtArgs> | null
    /**
     * Filter, which marca_motos to fetch.
     */
    where?: marca_motoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marca_motos to fetch.
     */
    orderBy?: marca_motoOrderByWithRelationInput | marca_motoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing marca_motos.
     */
    cursor?: marca_motoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marca_motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marca_motos.
     */
    skip?: number
    distinct?: Marca_motoScalarFieldEnum | Marca_motoScalarFieldEnum[]
  }

  /**
   * marca_moto create
   */
  export type marca_motoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_motoInclude<ExtArgs> | null
    /**
     * The data needed to create a marca_moto.
     */
    data: XOR<marca_motoCreateInput, marca_motoUncheckedCreateInput>
  }

  /**
   * marca_moto createMany
   */
  export type marca_motoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many marca_motos.
     */
    data: marca_motoCreateManyInput | marca_motoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * marca_moto createManyAndReturn
   */
  export type marca_motoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * The data used to create many marca_motos.
     */
    data: marca_motoCreateManyInput | marca_motoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * marca_moto update
   */
  export type marca_motoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_motoInclude<ExtArgs> | null
    /**
     * The data needed to update a marca_moto.
     */
    data: XOR<marca_motoUpdateInput, marca_motoUncheckedUpdateInput>
    /**
     * Choose, which marca_moto to update.
     */
    where: marca_motoWhereUniqueInput
  }

  /**
   * marca_moto updateMany
   */
  export type marca_motoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update marca_motos.
     */
    data: XOR<marca_motoUpdateManyMutationInput, marca_motoUncheckedUpdateManyInput>
    /**
     * Filter which marca_motos to update
     */
    where?: marca_motoWhereInput
    /**
     * Limit how many marca_motos to update.
     */
    limit?: number
  }

  /**
   * marca_moto updateManyAndReturn
   */
  export type marca_motoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * The data used to update marca_motos.
     */
    data: XOR<marca_motoUpdateManyMutationInput, marca_motoUncheckedUpdateManyInput>
    /**
     * Filter which marca_motos to update
     */
    where?: marca_motoWhereInput
    /**
     * Limit how many marca_motos to update.
     */
    limit?: number
  }

  /**
   * marca_moto upsert
   */
  export type marca_motoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_motoInclude<ExtArgs> | null
    /**
     * The filter to search for the marca_moto to update in case it exists.
     */
    where: marca_motoWhereUniqueInput
    /**
     * In case the marca_moto found by the `where` argument doesn't exist, create a new marca_moto with this data.
     */
    create: XOR<marca_motoCreateInput, marca_motoUncheckedCreateInput>
    /**
     * In case the marca_moto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<marca_motoUpdateInput, marca_motoUncheckedUpdateInput>
  }

  /**
   * marca_moto delete
   */
  export type marca_motoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_motoInclude<ExtArgs> | null
    /**
     * Filter which marca_moto to delete.
     */
    where: marca_motoWhereUniqueInput
  }

  /**
   * marca_moto deleteMany
   */
  export type marca_motoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marca_motos to delete
     */
    where?: marca_motoWhereInput
    /**
     * Limit how many marca_motos to delete.
     */
    limit?: number
  }

  /**
   * marca_moto.moto
   */
  export type marca_moto$motoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
    where?: motoWhereInput
    orderBy?: motoOrderByWithRelationInput | motoOrderByWithRelationInput[]
    cursor?: motoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MotoScalarFieldEnum | MotoScalarFieldEnum[]
  }

  /**
   * marca_moto without action
   */
  export type marca_motoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca_moto
     */
    select?: marca_motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marca_moto
     */
    omit?: marca_motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marca_motoInclude<ExtArgs> | null
  }


  /**
   * Model moto
   */

  export type AggregateMoto = {
    _count: MotoCountAggregateOutputType | null
    _avg: MotoAvgAggregateOutputType | null
    _sum: MotoSumAggregateOutputType | null
    _min: MotoMinAggregateOutputType | null
    _max: MotoMaxAggregateOutputType | null
  }

  export type MotoAvgAggregateOutputType = {
    year: number | null
    marca_id: number | null
  }

  export type MotoSumAggregateOutputType = {
    year: number | null
    marca_id: number | null
  }

  export type MotoMinAggregateOutputType = {
    placa: string | null
    modelo: string | null
    year: number | null
    chasis: string | null
    marca_id: number | null
  }

  export type MotoMaxAggregateOutputType = {
    placa: string | null
    modelo: string | null
    year: number | null
    chasis: string | null
    marca_id: number | null
  }

  export type MotoCountAggregateOutputType = {
    placa: number
    modelo: number
    year: number
    chasis: number
    marca_id: number
    _all: number
  }


  export type MotoAvgAggregateInputType = {
    year?: true
    marca_id?: true
  }

  export type MotoSumAggregateInputType = {
    year?: true
    marca_id?: true
  }

  export type MotoMinAggregateInputType = {
    placa?: true
    modelo?: true
    year?: true
    chasis?: true
    marca_id?: true
  }

  export type MotoMaxAggregateInputType = {
    placa?: true
    modelo?: true
    year?: true
    chasis?: true
    marca_id?: true
  }

  export type MotoCountAggregateInputType = {
    placa?: true
    modelo?: true
    year?: true
    chasis?: true
    marca_id?: true
    _all?: true
  }

  export type MotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which moto to aggregate.
     */
    where?: motoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motos to fetch.
     */
    orderBy?: motoOrderByWithRelationInput | motoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: motoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned motos
    **/
    _count?: true | MotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotoMaxAggregateInputType
  }

  export type GetMotoAggregateType<T extends MotoAggregateArgs> = {
        [P in keyof T & keyof AggregateMoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoto[P]>
      : GetScalarType<T[P], AggregateMoto[P]>
  }




  export type motoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: motoWhereInput
    orderBy?: motoOrderByWithAggregationInput | motoOrderByWithAggregationInput[]
    by: MotoScalarFieldEnum[] | MotoScalarFieldEnum
    having?: motoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotoCountAggregateInputType | true
    _avg?: MotoAvgAggregateInputType
    _sum?: MotoSumAggregateInputType
    _min?: MotoMinAggregateInputType
    _max?: MotoMaxAggregateInputType
  }

  export type MotoGroupByOutputType = {
    placa: string
    modelo: string
    year: number
    chasis: string | null
    marca_id: number
    _count: MotoCountAggregateOutputType | null
    _avg: MotoAvgAggregateOutputType | null
    _sum: MotoSumAggregateOutputType | null
    _min: MotoMinAggregateOutputType | null
    _max: MotoMaxAggregateOutputType | null
  }

  type GetMotoGroupByPayload<T extends motoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotoGroupByOutputType[P]>
            : GetScalarType<T[P], MotoGroupByOutputType[P]>
        }
      >
    >


  export type motoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    placa?: boolean
    modelo?: boolean
    year?: boolean
    chasis?: boolean
    marca_id?: boolean
    diagnostico?: boolean | moto$diagnosticoArgs<ExtArgs>
    marca_moto?: boolean | marca_motoDefaultArgs<ExtArgs>
    _count?: boolean | MotoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moto"]>

  export type motoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    placa?: boolean
    modelo?: boolean
    year?: boolean
    chasis?: boolean
    marca_id?: boolean
    marca_moto?: boolean | marca_motoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moto"]>

  export type motoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    placa?: boolean
    modelo?: boolean
    year?: boolean
    chasis?: boolean
    marca_id?: boolean
    marca_moto?: boolean | marca_motoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moto"]>

  export type motoSelectScalar = {
    placa?: boolean
    modelo?: boolean
    year?: boolean
    chasis?: boolean
    marca_id?: boolean
  }

  export type motoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"placa" | "modelo" | "year" | "chasis" | "marca_id", ExtArgs["result"]["moto"]>
  export type motoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnostico?: boolean | moto$diagnosticoArgs<ExtArgs>
    marca_moto?: boolean | marca_motoDefaultArgs<ExtArgs>
    _count?: boolean | MotoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type motoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marca_moto?: boolean | marca_motoDefaultArgs<ExtArgs>
  }
  export type motoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marca_moto?: boolean | marca_motoDefaultArgs<ExtArgs>
  }

  export type $motoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "moto"
    objects: {
      diagnostico: Prisma.$diagnosticoPayload<ExtArgs>[]
      marca_moto: Prisma.$marca_motoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      placa: string
      modelo: string
      year: number
      chasis: string | null
      marca_id: number
    }, ExtArgs["result"]["moto"]>
    composites: {}
  }

  type motoGetPayload<S extends boolean | null | undefined | motoDefaultArgs> = $Result.GetResult<Prisma.$motoPayload, S>

  type motoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<motoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MotoCountAggregateInputType | true
    }

  export interface motoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['moto'], meta: { name: 'moto' } }
    /**
     * Find zero or one Moto that matches the filter.
     * @param {motoFindUniqueArgs} args - Arguments to find a Moto
     * @example
     * // Get one Moto
     * const moto = await prisma.moto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends motoFindUniqueArgs>(args: SelectSubset<T, motoFindUniqueArgs<ExtArgs>>): Prisma__motoClient<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Moto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {motoFindUniqueOrThrowArgs} args - Arguments to find a Moto
     * @example
     * // Get one Moto
     * const moto = await prisma.moto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends motoFindUniqueOrThrowArgs>(args: SelectSubset<T, motoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__motoClient<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Moto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoFindFirstArgs} args - Arguments to find a Moto
     * @example
     * // Get one Moto
     * const moto = await prisma.moto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends motoFindFirstArgs>(args?: SelectSubset<T, motoFindFirstArgs<ExtArgs>>): Prisma__motoClient<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Moto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoFindFirstOrThrowArgs} args - Arguments to find a Moto
     * @example
     * // Get one Moto
     * const moto = await prisma.moto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends motoFindFirstOrThrowArgs>(args?: SelectSubset<T, motoFindFirstOrThrowArgs<ExtArgs>>): Prisma__motoClient<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Motos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motos
     * const motos = await prisma.moto.findMany()
     * 
     * // Get first 10 Motos
     * const motos = await prisma.moto.findMany({ take: 10 })
     * 
     * // Only select the `placa`
     * const motoWithPlacaOnly = await prisma.moto.findMany({ select: { placa: true } })
     * 
     */
    findMany<T extends motoFindManyArgs>(args?: SelectSubset<T, motoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Moto.
     * @param {motoCreateArgs} args - Arguments to create a Moto.
     * @example
     * // Create one Moto
     * const Moto = await prisma.moto.create({
     *   data: {
     *     // ... data to create a Moto
     *   }
     * })
     * 
     */
    create<T extends motoCreateArgs>(args: SelectSubset<T, motoCreateArgs<ExtArgs>>): Prisma__motoClient<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Motos.
     * @param {motoCreateManyArgs} args - Arguments to create many Motos.
     * @example
     * // Create many Motos
     * const moto = await prisma.moto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends motoCreateManyArgs>(args?: SelectSubset<T, motoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Motos and returns the data saved in the database.
     * @param {motoCreateManyAndReturnArgs} args - Arguments to create many Motos.
     * @example
     * // Create many Motos
     * const moto = await prisma.moto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Motos and only return the `placa`
     * const motoWithPlacaOnly = await prisma.moto.createManyAndReturn({
     *   select: { placa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends motoCreateManyAndReturnArgs>(args?: SelectSubset<T, motoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Moto.
     * @param {motoDeleteArgs} args - Arguments to delete one Moto.
     * @example
     * // Delete one Moto
     * const Moto = await prisma.moto.delete({
     *   where: {
     *     // ... filter to delete one Moto
     *   }
     * })
     * 
     */
    delete<T extends motoDeleteArgs>(args: SelectSubset<T, motoDeleteArgs<ExtArgs>>): Prisma__motoClient<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Moto.
     * @param {motoUpdateArgs} args - Arguments to update one Moto.
     * @example
     * // Update one Moto
     * const moto = await prisma.moto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends motoUpdateArgs>(args: SelectSubset<T, motoUpdateArgs<ExtArgs>>): Prisma__motoClient<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Motos.
     * @param {motoDeleteManyArgs} args - Arguments to filter Motos to delete.
     * @example
     * // Delete a few Motos
     * const { count } = await prisma.moto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends motoDeleteManyArgs>(args?: SelectSubset<T, motoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motos
     * const moto = await prisma.moto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends motoUpdateManyArgs>(args: SelectSubset<T, motoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motos and returns the data updated in the database.
     * @param {motoUpdateManyAndReturnArgs} args - Arguments to update many Motos.
     * @example
     * // Update many Motos
     * const moto = await prisma.moto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Motos and only return the `placa`
     * const motoWithPlacaOnly = await prisma.moto.updateManyAndReturn({
     *   select: { placa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends motoUpdateManyAndReturnArgs>(args: SelectSubset<T, motoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Moto.
     * @param {motoUpsertArgs} args - Arguments to update or create a Moto.
     * @example
     * // Update or create a Moto
     * const moto = await prisma.moto.upsert({
     *   create: {
     *     // ... data to create a Moto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Moto we want to update
     *   }
     * })
     */
    upsert<T extends motoUpsertArgs>(args: SelectSubset<T, motoUpsertArgs<ExtArgs>>): Prisma__motoClient<$Result.GetResult<Prisma.$motoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Motos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoCountArgs} args - Arguments to filter Motos to count.
     * @example
     * // Count the number of Motos
     * const count = await prisma.moto.count({
     *   where: {
     *     // ... the filter for the Motos we want to count
     *   }
     * })
    **/
    count<T extends motoCountArgs>(
      args?: Subset<T, motoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Moto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotoAggregateArgs>(args: Subset<T, MotoAggregateArgs>): Prisma.PrismaPromise<GetMotoAggregateType<T>>

    /**
     * Group by Moto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends motoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: motoGroupByArgs['orderBy'] }
        : { orderBy?: motoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, motoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the moto model
   */
  readonly fields: motoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for moto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__motoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diagnostico<T extends moto$diagnosticoArgs<ExtArgs> = {}>(args?: Subset<T, moto$diagnosticoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    marca_moto<T extends marca_motoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, marca_motoDefaultArgs<ExtArgs>>): Prisma__marca_motoClient<$Result.GetResult<Prisma.$marca_motoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the moto model
   */
  interface motoFieldRefs {
    readonly placa: FieldRef<"moto", 'String'>
    readonly modelo: FieldRef<"moto", 'String'>
    readonly year: FieldRef<"moto", 'Int'>
    readonly chasis: FieldRef<"moto", 'String'>
    readonly marca_id: FieldRef<"moto", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * moto findUnique
   */
  export type motoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
    /**
     * Filter, which moto to fetch.
     */
    where: motoWhereUniqueInput
  }

  /**
   * moto findUniqueOrThrow
   */
  export type motoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
    /**
     * Filter, which moto to fetch.
     */
    where: motoWhereUniqueInput
  }

  /**
   * moto findFirst
   */
  export type motoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
    /**
     * Filter, which moto to fetch.
     */
    where?: motoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motos to fetch.
     */
    orderBy?: motoOrderByWithRelationInput | motoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for motos.
     */
    cursor?: motoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of motos.
     */
    distinct?: MotoScalarFieldEnum | MotoScalarFieldEnum[]
  }

  /**
   * moto findFirstOrThrow
   */
  export type motoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
    /**
     * Filter, which moto to fetch.
     */
    where?: motoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motos to fetch.
     */
    orderBy?: motoOrderByWithRelationInput | motoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for motos.
     */
    cursor?: motoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of motos.
     */
    distinct?: MotoScalarFieldEnum | MotoScalarFieldEnum[]
  }

  /**
   * moto findMany
   */
  export type motoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
    /**
     * Filter, which motos to fetch.
     */
    where?: motoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motos to fetch.
     */
    orderBy?: motoOrderByWithRelationInput | motoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing motos.
     */
    cursor?: motoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motos.
     */
    skip?: number
    distinct?: MotoScalarFieldEnum | MotoScalarFieldEnum[]
  }

  /**
   * moto create
   */
  export type motoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
    /**
     * The data needed to create a moto.
     */
    data: XOR<motoCreateInput, motoUncheckedCreateInput>
  }

  /**
   * moto createMany
   */
  export type motoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many motos.
     */
    data: motoCreateManyInput | motoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * moto createManyAndReturn
   */
  export type motoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * The data used to create many motos.
     */
    data: motoCreateManyInput | motoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * moto update
   */
  export type motoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
    /**
     * The data needed to update a moto.
     */
    data: XOR<motoUpdateInput, motoUncheckedUpdateInput>
    /**
     * Choose, which moto to update.
     */
    where: motoWhereUniqueInput
  }

  /**
   * moto updateMany
   */
  export type motoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update motos.
     */
    data: XOR<motoUpdateManyMutationInput, motoUncheckedUpdateManyInput>
    /**
     * Filter which motos to update
     */
    where?: motoWhereInput
    /**
     * Limit how many motos to update.
     */
    limit?: number
  }

  /**
   * moto updateManyAndReturn
   */
  export type motoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * The data used to update motos.
     */
    data: XOR<motoUpdateManyMutationInput, motoUncheckedUpdateManyInput>
    /**
     * Filter which motos to update
     */
    where?: motoWhereInput
    /**
     * Limit how many motos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * moto upsert
   */
  export type motoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
    /**
     * The filter to search for the moto to update in case it exists.
     */
    where: motoWhereUniqueInput
    /**
     * In case the moto found by the `where` argument doesn't exist, create a new moto with this data.
     */
    create: XOR<motoCreateInput, motoUncheckedCreateInput>
    /**
     * In case the moto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<motoUpdateInput, motoUncheckedUpdateInput>
  }

  /**
   * moto delete
   */
  export type motoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
    /**
     * Filter which moto to delete.
     */
    where: motoWhereUniqueInput
  }

  /**
   * moto deleteMany
   */
  export type motoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which motos to delete
     */
    where?: motoWhereInput
    /**
     * Limit how many motos to delete.
     */
    limit?: number
  }

  /**
   * moto.diagnostico
   */
  export type moto$diagnosticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    where?: diagnosticoWhereInput
    orderBy?: diagnosticoOrderByWithRelationInput | diagnosticoOrderByWithRelationInput[]
    cursor?: diagnosticoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosticoScalarFieldEnum | DiagnosticoScalarFieldEnum[]
  }

  /**
   * moto without action
   */
  export type motoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the moto
     */
    select?: motoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the moto
     */
    omit?: motoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: motoInclude<ExtArgs> | null
  }


  /**
   * Model movimiento_herramienta
   */

  export type AggregateMovimiento_herramienta = {
    _count: Movimiento_herramientaCountAggregateOutputType | null
    _avg: Movimiento_herramientaAvgAggregateOutputType | null
    _sum: Movimiento_herramientaSumAggregateOutputType | null
    _min: Movimiento_herramientaMinAggregateOutputType | null
    _max: Movimiento_herramientaMaxAggregateOutputType | null
  }

  export type Movimiento_herramientaAvgAggregateOutputType = {
    herramienta_id: number | null
    orden_trabajo_id: number | null
    cantidad: number | null
  }

  export type Movimiento_herramientaSumAggregateOutputType = {
    herramienta_id: number | null
    orden_trabajo_id: bigint | null
    cantidad: number | null
  }

  export type Movimiento_herramientaMinAggregateOutputType = {
    herramienta_id: number | null
    orden_trabajo_id: bigint | null
    fecha: Date | null
    cantidad: number | null
  }

  export type Movimiento_herramientaMaxAggregateOutputType = {
    herramienta_id: number | null
    orden_trabajo_id: bigint | null
    fecha: Date | null
    cantidad: number | null
  }

  export type Movimiento_herramientaCountAggregateOutputType = {
    herramienta_id: number
    orden_trabajo_id: number
    fecha: number
    cantidad: number
    _all: number
  }


  export type Movimiento_herramientaAvgAggregateInputType = {
    herramienta_id?: true
    orden_trabajo_id?: true
    cantidad?: true
  }

  export type Movimiento_herramientaSumAggregateInputType = {
    herramienta_id?: true
    orden_trabajo_id?: true
    cantidad?: true
  }

  export type Movimiento_herramientaMinAggregateInputType = {
    herramienta_id?: true
    orden_trabajo_id?: true
    fecha?: true
    cantidad?: true
  }

  export type Movimiento_herramientaMaxAggregateInputType = {
    herramienta_id?: true
    orden_trabajo_id?: true
    fecha?: true
    cantidad?: true
  }

  export type Movimiento_herramientaCountAggregateInputType = {
    herramienta_id?: true
    orden_trabajo_id?: true
    fecha?: true
    cantidad?: true
    _all?: true
  }

  export type Movimiento_herramientaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which movimiento_herramienta to aggregate.
     */
    where?: movimiento_herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimiento_herramientas to fetch.
     */
    orderBy?: movimiento_herramientaOrderByWithRelationInput | movimiento_herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: movimiento_herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimiento_herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimiento_herramientas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned movimiento_herramientas
    **/
    _count?: true | Movimiento_herramientaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Movimiento_herramientaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Movimiento_herramientaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Movimiento_herramientaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Movimiento_herramientaMaxAggregateInputType
  }

  export type GetMovimiento_herramientaAggregateType<T extends Movimiento_herramientaAggregateArgs> = {
        [P in keyof T & keyof AggregateMovimiento_herramienta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovimiento_herramienta[P]>
      : GetScalarType<T[P], AggregateMovimiento_herramienta[P]>
  }




  export type movimiento_herramientaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: movimiento_herramientaWhereInput
    orderBy?: movimiento_herramientaOrderByWithAggregationInput | movimiento_herramientaOrderByWithAggregationInput[]
    by: Movimiento_herramientaScalarFieldEnum[] | Movimiento_herramientaScalarFieldEnum
    having?: movimiento_herramientaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Movimiento_herramientaCountAggregateInputType | true
    _avg?: Movimiento_herramientaAvgAggregateInputType
    _sum?: Movimiento_herramientaSumAggregateInputType
    _min?: Movimiento_herramientaMinAggregateInputType
    _max?: Movimiento_herramientaMaxAggregateInputType
  }

  export type Movimiento_herramientaGroupByOutputType = {
    herramienta_id: number
    orden_trabajo_id: bigint
    fecha: Date
    cantidad: number
    _count: Movimiento_herramientaCountAggregateOutputType | null
    _avg: Movimiento_herramientaAvgAggregateOutputType | null
    _sum: Movimiento_herramientaSumAggregateOutputType | null
    _min: Movimiento_herramientaMinAggregateOutputType | null
    _max: Movimiento_herramientaMaxAggregateOutputType | null
  }

  type GetMovimiento_herramientaGroupByPayload<T extends movimiento_herramientaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Movimiento_herramientaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Movimiento_herramientaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Movimiento_herramientaGroupByOutputType[P]>
            : GetScalarType<T[P], Movimiento_herramientaGroupByOutputType[P]>
        }
      >
    >


  export type movimiento_herramientaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    herramienta_id?: boolean
    orden_trabajo_id?: boolean
    fecha?: boolean
    cantidad?: boolean
    herramienta?: boolean | herramientaDefaultArgs<ExtArgs>
    orden_trabajo?: boolean | orden_trabajoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movimiento_herramienta"]>

  export type movimiento_herramientaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    herramienta_id?: boolean
    orden_trabajo_id?: boolean
    fecha?: boolean
    cantidad?: boolean
    herramienta?: boolean | herramientaDefaultArgs<ExtArgs>
    orden_trabajo?: boolean | orden_trabajoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movimiento_herramienta"]>

  export type movimiento_herramientaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    herramienta_id?: boolean
    orden_trabajo_id?: boolean
    fecha?: boolean
    cantidad?: boolean
    herramienta?: boolean | herramientaDefaultArgs<ExtArgs>
    orden_trabajo?: boolean | orden_trabajoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movimiento_herramienta"]>

  export type movimiento_herramientaSelectScalar = {
    herramienta_id?: boolean
    orden_trabajo_id?: boolean
    fecha?: boolean
    cantidad?: boolean
  }

  export type movimiento_herramientaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"herramienta_id" | "orden_trabajo_id" | "fecha" | "cantidad", ExtArgs["result"]["movimiento_herramienta"]>
  export type movimiento_herramientaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    herramienta?: boolean | herramientaDefaultArgs<ExtArgs>
    orden_trabajo?: boolean | orden_trabajoDefaultArgs<ExtArgs>
  }
  export type movimiento_herramientaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    herramienta?: boolean | herramientaDefaultArgs<ExtArgs>
    orden_trabajo?: boolean | orden_trabajoDefaultArgs<ExtArgs>
  }
  export type movimiento_herramientaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    herramienta?: boolean | herramientaDefaultArgs<ExtArgs>
    orden_trabajo?: boolean | orden_trabajoDefaultArgs<ExtArgs>
  }

  export type $movimiento_herramientaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "movimiento_herramienta"
    objects: {
      herramienta: Prisma.$herramientaPayload<ExtArgs>
      orden_trabajo: Prisma.$orden_trabajoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      herramienta_id: number
      orden_trabajo_id: bigint
      fecha: Date
      cantidad: number
    }, ExtArgs["result"]["movimiento_herramienta"]>
    composites: {}
  }

  type movimiento_herramientaGetPayload<S extends boolean | null | undefined | movimiento_herramientaDefaultArgs> = $Result.GetResult<Prisma.$movimiento_herramientaPayload, S>

  type movimiento_herramientaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<movimiento_herramientaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Movimiento_herramientaCountAggregateInputType | true
    }

  export interface movimiento_herramientaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['movimiento_herramienta'], meta: { name: 'movimiento_herramienta' } }
    /**
     * Find zero or one Movimiento_herramienta that matches the filter.
     * @param {movimiento_herramientaFindUniqueArgs} args - Arguments to find a Movimiento_herramienta
     * @example
     * // Get one Movimiento_herramienta
     * const movimiento_herramienta = await prisma.movimiento_herramienta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends movimiento_herramientaFindUniqueArgs>(args: SelectSubset<T, movimiento_herramientaFindUniqueArgs<ExtArgs>>): Prisma__movimiento_herramientaClient<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Movimiento_herramienta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {movimiento_herramientaFindUniqueOrThrowArgs} args - Arguments to find a Movimiento_herramienta
     * @example
     * // Get one Movimiento_herramienta
     * const movimiento_herramienta = await prisma.movimiento_herramienta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends movimiento_herramientaFindUniqueOrThrowArgs>(args: SelectSubset<T, movimiento_herramientaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__movimiento_herramientaClient<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Movimiento_herramienta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_herramientaFindFirstArgs} args - Arguments to find a Movimiento_herramienta
     * @example
     * // Get one Movimiento_herramienta
     * const movimiento_herramienta = await prisma.movimiento_herramienta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends movimiento_herramientaFindFirstArgs>(args?: SelectSubset<T, movimiento_herramientaFindFirstArgs<ExtArgs>>): Prisma__movimiento_herramientaClient<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Movimiento_herramienta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_herramientaFindFirstOrThrowArgs} args - Arguments to find a Movimiento_herramienta
     * @example
     * // Get one Movimiento_herramienta
     * const movimiento_herramienta = await prisma.movimiento_herramienta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends movimiento_herramientaFindFirstOrThrowArgs>(args?: SelectSubset<T, movimiento_herramientaFindFirstOrThrowArgs<ExtArgs>>): Prisma__movimiento_herramientaClient<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Movimiento_herramientas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_herramientaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movimiento_herramientas
     * const movimiento_herramientas = await prisma.movimiento_herramienta.findMany()
     * 
     * // Get first 10 Movimiento_herramientas
     * const movimiento_herramientas = await prisma.movimiento_herramienta.findMany({ take: 10 })
     * 
     * // Only select the `herramienta_id`
     * const movimiento_herramientaWithHerramienta_idOnly = await prisma.movimiento_herramienta.findMany({ select: { herramienta_id: true } })
     * 
     */
    findMany<T extends movimiento_herramientaFindManyArgs>(args?: SelectSubset<T, movimiento_herramientaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Movimiento_herramienta.
     * @param {movimiento_herramientaCreateArgs} args - Arguments to create a Movimiento_herramienta.
     * @example
     * // Create one Movimiento_herramienta
     * const Movimiento_herramienta = await prisma.movimiento_herramienta.create({
     *   data: {
     *     // ... data to create a Movimiento_herramienta
     *   }
     * })
     * 
     */
    create<T extends movimiento_herramientaCreateArgs>(args: SelectSubset<T, movimiento_herramientaCreateArgs<ExtArgs>>): Prisma__movimiento_herramientaClient<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Movimiento_herramientas.
     * @param {movimiento_herramientaCreateManyArgs} args - Arguments to create many Movimiento_herramientas.
     * @example
     * // Create many Movimiento_herramientas
     * const movimiento_herramienta = await prisma.movimiento_herramienta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends movimiento_herramientaCreateManyArgs>(args?: SelectSubset<T, movimiento_herramientaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Movimiento_herramientas and returns the data saved in the database.
     * @param {movimiento_herramientaCreateManyAndReturnArgs} args - Arguments to create many Movimiento_herramientas.
     * @example
     * // Create many Movimiento_herramientas
     * const movimiento_herramienta = await prisma.movimiento_herramienta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Movimiento_herramientas and only return the `herramienta_id`
     * const movimiento_herramientaWithHerramienta_idOnly = await prisma.movimiento_herramienta.createManyAndReturn({
     *   select: { herramienta_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends movimiento_herramientaCreateManyAndReturnArgs>(args?: SelectSubset<T, movimiento_herramientaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Movimiento_herramienta.
     * @param {movimiento_herramientaDeleteArgs} args - Arguments to delete one Movimiento_herramienta.
     * @example
     * // Delete one Movimiento_herramienta
     * const Movimiento_herramienta = await prisma.movimiento_herramienta.delete({
     *   where: {
     *     // ... filter to delete one Movimiento_herramienta
     *   }
     * })
     * 
     */
    delete<T extends movimiento_herramientaDeleteArgs>(args: SelectSubset<T, movimiento_herramientaDeleteArgs<ExtArgs>>): Prisma__movimiento_herramientaClient<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Movimiento_herramienta.
     * @param {movimiento_herramientaUpdateArgs} args - Arguments to update one Movimiento_herramienta.
     * @example
     * // Update one Movimiento_herramienta
     * const movimiento_herramienta = await prisma.movimiento_herramienta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends movimiento_herramientaUpdateArgs>(args: SelectSubset<T, movimiento_herramientaUpdateArgs<ExtArgs>>): Prisma__movimiento_herramientaClient<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Movimiento_herramientas.
     * @param {movimiento_herramientaDeleteManyArgs} args - Arguments to filter Movimiento_herramientas to delete.
     * @example
     * // Delete a few Movimiento_herramientas
     * const { count } = await prisma.movimiento_herramienta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends movimiento_herramientaDeleteManyArgs>(args?: SelectSubset<T, movimiento_herramientaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movimiento_herramientas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_herramientaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movimiento_herramientas
     * const movimiento_herramienta = await prisma.movimiento_herramienta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends movimiento_herramientaUpdateManyArgs>(args: SelectSubset<T, movimiento_herramientaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movimiento_herramientas and returns the data updated in the database.
     * @param {movimiento_herramientaUpdateManyAndReturnArgs} args - Arguments to update many Movimiento_herramientas.
     * @example
     * // Update many Movimiento_herramientas
     * const movimiento_herramienta = await prisma.movimiento_herramienta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Movimiento_herramientas and only return the `herramienta_id`
     * const movimiento_herramientaWithHerramienta_idOnly = await prisma.movimiento_herramienta.updateManyAndReturn({
     *   select: { herramienta_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends movimiento_herramientaUpdateManyAndReturnArgs>(args: SelectSubset<T, movimiento_herramientaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Movimiento_herramienta.
     * @param {movimiento_herramientaUpsertArgs} args - Arguments to update or create a Movimiento_herramienta.
     * @example
     * // Update or create a Movimiento_herramienta
     * const movimiento_herramienta = await prisma.movimiento_herramienta.upsert({
     *   create: {
     *     // ... data to create a Movimiento_herramienta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movimiento_herramienta we want to update
     *   }
     * })
     */
    upsert<T extends movimiento_herramientaUpsertArgs>(args: SelectSubset<T, movimiento_herramientaUpsertArgs<ExtArgs>>): Prisma__movimiento_herramientaClient<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Movimiento_herramientas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_herramientaCountArgs} args - Arguments to filter Movimiento_herramientas to count.
     * @example
     * // Count the number of Movimiento_herramientas
     * const count = await prisma.movimiento_herramienta.count({
     *   where: {
     *     // ... the filter for the Movimiento_herramientas we want to count
     *   }
     * })
    **/
    count<T extends movimiento_herramientaCountArgs>(
      args?: Subset<T, movimiento_herramientaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Movimiento_herramientaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movimiento_herramienta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Movimiento_herramientaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Movimiento_herramientaAggregateArgs>(args: Subset<T, Movimiento_herramientaAggregateArgs>): Prisma.PrismaPromise<GetMovimiento_herramientaAggregateType<T>>

    /**
     * Group by Movimiento_herramienta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movimiento_herramientaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends movimiento_herramientaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: movimiento_herramientaGroupByArgs['orderBy'] }
        : { orderBy?: movimiento_herramientaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, movimiento_herramientaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovimiento_herramientaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the movimiento_herramienta model
   */
  readonly fields: movimiento_herramientaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for movimiento_herramienta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__movimiento_herramientaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    herramienta<T extends herramientaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, herramientaDefaultArgs<ExtArgs>>): Prisma__herramientaClient<$Result.GetResult<Prisma.$herramientaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orden_trabajo<T extends orden_trabajoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, orden_trabajoDefaultArgs<ExtArgs>>): Prisma__orden_trabajoClient<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the movimiento_herramienta model
   */
  interface movimiento_herramientaFieldRefs {
    readonly herramienta_id: FieldRef<"movimiento_herramienta", 'Int'>
    readonly orden_trabajo_id: FieldRef<"movimiento_herramienta", 'BigInt'>
    readonly fecha: FieldRef<"movimiento_herramienta", 'DateTime'>
    readonly cantidad: FieldRef<"movimiento_herramienta", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * movimiento_herramienta findUnique
   */
  export type movimiento_herramientaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    /**
     * Filter, which movimiento_herramienta to fetch.
     */
    where: movimiento_herramientaWhereUniqueInput
  }

  /**
   * movimiento_herramienta findUniqueOrThrow
   */
  export type movimiento_herramientaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    /**
     * Filter, which movimiento_herramienta to fetch.
     */
    where: movimiento_herramientaWhereUniqueInput
  }

  /**
   * movimiento_herramienta findFirst
   */
  export type movimiento_herramientaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    /**
     * Filter, which movimiento_herramienta to fetch.
     */
    where?: movimiento_herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimiento_herramientas to fetch.
     */
    orderBy?: movimiento_herramientaOrderByWithRelationInput | movimiento_herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movimiento_herramientas.
     */
    cursor?: movimiento_herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimiento_herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimiento_herramientas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movimiento_herramientas.
     */
    distinct?: Movimiento_herramientaScalarFieldEnum | Movimiento_herramientaScalarFieldEnum[]
  }

  /**
   * movimiento_herramienta findFirstOrThrow
   */
  export type movimiento_herramientaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    /**
     * Filter, which movimiento_herramienta to fetch.
     */
    where?: movimiento_herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimiento_herramientas to fetch.
     */
    orderBy?: movimiento_herramientaOrderByWithRelationInput | movimiento_herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movimiento_herramientas.
     */
    cursor?: movimiento_herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimiento_herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimiento_herramientas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movimiento_herramientas.
     */
    distinct?: Movimiento_herramientaScalarFieldEnum | Movimiento_herramientaScalarFieldEnum[]
  }

  /**
   * movimiento_herramienta findMany
   */
  export type movimiento_herramientaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    /**
     * Filter, which movimiento_herramientas to fetch.
     */
    where?: movimiento_herramientaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movimiento_herramientas to fetch.
     */
    orderBy?: movimiento_herramientaOrderByWithRelationInput | movimiento_herramientaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing movimiento_herramientas.
     */
    cursor?: movimiento_herramientaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movimiento_herramientas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movimiento_herramientas.
     */
    skip?: number
    distinct?: Movimiento_herramientaScalarFieldEnum | Movimiento_herramientaScalarFieldEnum[]
  }

  /**
   * movimiento_herramienta create
   */
  export type movimiento_herramientaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    /**
     * The data needed to create a movimiento_herramienta.
     */
    data: XOR<movimiento_herramientaCreateInput, movimiento_herramientaUncheckedCreateInput>
  }

  /**
   * movimiento_herramienta createMany
   */
  export type movimiento_herramientaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many movimiento_herramientas.
     */
    data: movimiento_herramientaCreateManyInput | movimiento_herramientaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * movimiento_herramienta createManyAndReturn
   */
  export type movimiento_herramientaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * The data used to create many movimiento_herramientas.
     */
    data: movimiento_herramientaCreateManyInput | movimiento_herramientaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * movimiento_herramienta update
   */
  export type movimiento_herramientaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    /**
     * The data needed to update a movimiento_herramienta.
     */
    data: XOR<movimiento_herramientaUpdateInput, movimiento_herramientaUncheckedUpdateInput>
    /**
     * Choose, which movimiento_herramienta to update.
     */
    where: movimiento_herramientaWhereUniqueInput
  }

  /**
   * movimiento_herramienta updateMany
   */
  export type movimiento_herramientaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update movimiento_herramientas.
     */
    data: XOR<movimiento_herramientaUpdateManyMutationInput, movimiento_herramientaUncheckedUpdateManyInput>
    /**
     * Filter which movimiento_herramientas to update
     */
    where?: movimiento_herramientaWhereInput
    /**
     * Limit how many movimiento_herramientas to update.
     */
    limit?: number
  }

  /**
   * movimiento_herramienta updateManyAndReturn
   */
  export type movimiento_herramientaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * The data used to update movimiento_herramientas.
     */
    data: XOR<movimiento_herramientaUpdateManyMutationInput, movimiento_herramientaUncheckedUpdateManyInput>
    /**
     * Filter which movimiento_herramientas to update
     */
    where?: movimiento_herramientaWhereInput
    /**
     * Limit how many movimiento_herramientas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * movimiento_herramienta upsert
   */
  export type movimiento_herramientaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    /**
     * The filter to search for the movimiento_herramienta to update in case it exists.
     */
    where: movimiento_herramientaWhereUniqueInput
    /**
     * In case the movimiento_herramienta found by the `where` argument doesn't exist, create a new movimiento_herramienta with this data.
     */
    create: XOR<movimiento_herramientaCreateInput, movimiento_herramientaUncheckedCreateInput>
    /**
     * In case the movimiento_herramienta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<movimiento_herramientaUpdateInput, movimiento_herramientaUncheckedUpdateInput>
  }

  /**
   * movimiento_herramienta delete
   */
  export type movimiento_herramientaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    /**
     * Filter which movimiento_herramienta to delete.
     */
    where: movimiento_herramientaWhereUniqueInput
  }

  /**
   * movimiento_herramienta deleteMany
   */
  export type movimiento_herramientaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which movimiento_herramientas to delete
     */
    where?: movimiento_herramientaWhereInput
    /**
     * Limit how many movimiento_herramientas to delete.
     */
    limit?: number
  }

  /**
   * movimiento_herramienta without action
   */
  export type movimiento_herramientaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
  }


  /**
   * Model orden_trabajo
   */

  export type AggregateOrden_trabajo = {
    _count: Orden_trabajoCountAggregateOutputType | null
    _avg: Orden_trabajoAvgAggregateOutputType | null
    _sum: Orden_trabajoSumAggregateOutputType | null
    _min: Orden_trabajoMinAggregateOutputType | null
    _max: Orden_trabajoMaxAggregateOutputType | null
  }

  export type Orden_trabajoAvgAggregateOutputType = {
    id: number | null
    empleado_ci: number | null
    administrador_id: number | null
    servicio_id: number | null
  }

  export type Orden_trabajoSumAggregateOutputType = {
    id: bigint | null
    empleado_ci: number | null
    administrador_id: number | null
    servicio_id: number | null
  }

  export type Orden_trabajoMinAggregateOutputType = {
    id: bigint | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    estado: $Enums.estado_orden | null
    empleado_ci: number | null
    administrador_id: number | null
    servicio_id: number | null
  }

  export type Orden_trabajoMaxAggregateOutputType = {
    id: bigint | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    estado: $Enums.estado_orden | null
    empleado_ci: number | null
    administrador_id: number | null
    servicio_id: number | null
  }

  export type Orden_trabajoCountAggregateOutputType = {
    id: number
    fecha_inicio: number
    fecha_fin: number
    estado: number
    empleado_ci: number
    administrador_id: number
    servicio_id: number
    _all: number
  }


  export type Orden_trabajoAvgAggregateInputType = {
    id?: true
    empleado_ci?: true
    administrador_id?: true
    servicio_id?: true
  }

  export type Orden_trabajoSumAggregateInputType = {
    id?: true
    empleado_ci?: true
    administrador_id?: true
    servicio_id?: true
  }

  export type Orden_trabajoMinAggregateInputType = {
    id?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empleado_ci?: true
    administrador_id?: true
    servicio_id?: true
  }

  export type Orden_trabajoMaxAggregateInputType = {
    id?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empleado_ci?: true
    administrador_id?: true
    servicio_id?: true
  }

  export type Orden_trabajoCountAggregateInputType = {
    id?: true
    fecha_inicio?: true
    fecha_fin?: true
    estado?: true
    empleado_ci?: true
    administrador_id?: true
    servicio_id?: true
    _all?: true
  }

  export type Orden_trabajoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orden_trabajo to aggregate.
     */
    where?: orden_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orden_trabajos to fetch.
     */
    orderBy?: orden_trabajoOrderByWithRelationInput | orden_trabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orden_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orden_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orden_trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orden_trabajos
    **/
    _count?: true | Orden_trabajoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Orden_trabajoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Orden_trabajoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Orden_trabajoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Orden_trabajoMaxAggregateInputType
  }

  export type GetOrden_trabajoAggregateType<T extends Orden_trabajoAggregateArgs> = {
        [P in keyof T & keyof AggregateOrden_trabajo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrden_trabajo[P]>
      : GetScalarType<T[P], AggregateOrden_trabajo[P]>
  }




  export type orden_trabajoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orden_trabajoWhereInput
    orderBy?: orden_trabajoOrderByWithAggregationInput | orden_trabajoOrderByWithAggregationInput[]
    by: Orden_trabajoScalarFieldEnum[] | Orden_trabajoScalarFieldEnum
    having?: orden_trabajoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Orden_trabajoCountAggregateInputType | true
    _avg?: Orden_trabajoAvgAggregateInputType
    _sum?: Orden_trabajoSumAggregateInputType
    _min?: Orden_trabajoMinAggregateInputType
    _max?: Orden_trabajoMaxAggregateInputType
  }

  export type Orden_trabajoGroupByOutputType = {
    id: bigint
    fecha_inicio: Date
    fecha_fin: Date | null
    estado: $Enums.estado_orden
    empleado_ci: number
    administrador_id: number | null
    servicio_id: number
    _count: Orden_trabajoCountAggregateOutputType | null
    _avg: Orden_trabajoAvgAggregateOutputType | null
    _sum: Orden_trabajoSumAggregateOutputType | null
    _min: Orden_trabajoMinAggregateOutputType | null
    _max: Orden_trabajoMaxAggregateOutputType | null
  }

  type GetOrden_trabajoGroupByPayload<T extends orden_trabajoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Orden_trabajoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Orden_trabajoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Orden_trabajoGroupByOutputType[P]>
            : GetScalarType<T[P], Orden_trabajoGroupByOutputType[P]>
        }
      >
    >


  export type orden_trabajoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
    empleado_ci?: boolean
    administrador_id?: boolean
    servicio_id?: boolean
    comision?: boolean | orden_trabajo$comisionArgs<ExtArgs>
    movimiento_herramienta?: boolean | orden_trabajo$movimiento_herramientaArgs<ExtArgs>
    administrador?: boolean | orden_trabajo$administradorArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    servicio?: boolean | servicioDefaultArgs<ExtArgs>
    _count?: boolean | Orden_trabajoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orden_trabajo"]>

  export type orden_trabajoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
    empleado_ci?: boolean
    administrador_id?: boolean
    servicio_id?: boolean
    administrador?: boolean | orden_trabajo$administradorArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    servicio?: boolean | servicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orden_trabajo"]>

  export type orden_trabajoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
    empleado_ci?: boolean
    administrador_id?: boolean
    servicio_id?: boolean
    administrador?: boolean | orden_trabajo$administradorArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    servicio?: boolean | servicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orden_trabajo"]>

  export type orden_trabajoSelectScalar = {
    id?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    estado?: boolean
    empleado_ci?: boolean
    administrador_id?: boolean
    servicio_id?: boolean
  }

  export type orden_trabajoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fecha_inicio" | "fecha_fin" | "estado" | "empleado_ci" | "administrador_id" | "servicio_id", ExtArgs["result"]["orden_trabajo"]>
  export type orden_trabajoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comision?: boolean | orden_trabajo$comisionArgs<ExtArgs>
    movimiento_herramienta?: boolean | orden_trabajo$movimiento_herramientaArgs<ExtArgs>
    administrador?: boolean | orden_trabajo$administradorArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    servicio?: boolean | servicioDefaultArgs<ExtArgs>
    _count?: boolean | Orden_trabajoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type orden_trabajoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    administrador?: boolean | orden_trabajo$administradorArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    servicio?: boolean | servicioDefaultArgs<ExtArgs>
  }
  export type orden_trabajoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    administrador?: boolean | orden_trabajo$administradorArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    servicio?: boolean | servicioDefaultArgs<ExtArgs>
  }

  export type $orden_trabajoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orden_trabajo"
    objects: {
      comision: Prisma.$comisionPayload<ExtArgs> | null
      movimiento_herramienta: Prisma.$movimiento_herramientaPayload<ExtArgs>[]
      administrador: Prisma.$administradorPayload<ExtArgs> | null
      empleado: Prisma.$empleadoPayload<ExtArgs>
      servicio: Prisma.$servicioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      fecha_inicio: Date
      fecha_fin: Date | null
      estado: $Enums.estado_orden
      empleado_ci: number
      administrador_id: number | null
      servicio_id: number
    }, ExtArgs["result"]["orden_trabajo"]>
    composites: {}
  }

  type orden_trabajoGetPayload<S extends boolean | null | undefined | orden_trabajoDefaultArgs> = $Result.GetResult<Prisma.$orden_trabajoPayload, S>

  type orden_trabajoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<orden_trabajoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Orden_trabajoCountAggregateInputType | true
    }

  export interface orden_trabajoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orden_trabajo'], meta: { name: 'orden_trabajo' } }
    /**
     * Find zero or one Orden_trabajo that matches the filter.
     * @param {orden_trabajoFindUniqueArgs} args - Arguments to find a Orden_trabajo
     * @example
     * // Get one Orden_trabajo
     * const orden_trabajo = await prisma.orden_trabajo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends orden_trabajoFindUniqueArgs>(args: SelectSubset<T, orden_trabajoFindUniqueArgs<ExtArgs>>): Prisma__orden_trabajoClient<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Orden_trabajo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {orden_trabajoFindUniqueOrThrowArgs} args - Arguments to find a Orden_trabajo
     * @example
     * // Get one Orden_trabajo
     * const orden_trabajo = await prisma.orden_trabajo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends orden_trabajoFindUniqueOrThrowArgs>(args: SelectSubset<T, orden_trabajoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__orden_trabajoClient<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orden_trabajo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orden_trabajoFindFirstArgs} args - Arguments to find a Orden_trabajo
     * @example
     * // Get one Orden_trabajo
     * const orden_trabajo = await prisma.orden_trabajo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends orden_trabajoFindFirstArgs>(args?: SelectSubset<T, orden_trabajoFindFirstArgs<ExtArgs>>): Prisma__orden_trabajoClient<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orden_trabajo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orden_trabajoFindFirstOrThrowArgs} args - Arguments to find a Orden_trabajo
     * @example
     * // Get one Orden_trabajo
     * const orden_trabajo = await prisma.orden_trabajo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends orden_trabajoFindFirstOrThrowArgs>(args?: SelectSubset<T, orden_trabajoFindFirstOrThrowArgs<ExtArgs>>): Prisma__orden_trabajoClient<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orden_trabajos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orden_trabajoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orden_trabajos
     * const orden_trabajos = await prisma.orden_trabajo.findMany()
     * 
     * // Get first 10 Orden_trabajos
     * const orden_trabajos = await prisma.orden_trabajo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orden_trabajoWithIdOnly = await prisma.orden_trabajo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends orden_trabajoFindManyArgs>(args?: SelectSubset<T, orden_trabajoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Orden_trabajo.
     * @param {orden_trabajoCreateArgs} args - Arguments to create a Orden_trabajo.
     * @example
     * // Create one Orden_trabajo
     * const Orden_trabajo = await prisma.orden_trabajo.create({
     *   data: {
     *     // ... data to create a Orden_trabajo
     *   }
     * })
     * 
     */
    create<T extends orden_trabajoCreateArgs>(args: SelectSubset<T, orden_trabajoCreateArgs<ExtArgs>>): Prisma__orden_trabajoClient<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orden_trabajos.
     * @param {orden_trabajoCreateManyArgs} args - Arguments to create many Orden_trabajos.
     * @example
     * // Create many Orden_trabajos
     * const orden_trabajo = await prisma.orden_trabajo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends orden_trabajoCreateManyArgs>(args?: SelectSubset<T, orden_trabajoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orden_trabajos and returns the data saved in the database.
     * @param {orden_trabajoCreateManyAndReturnArgs} args - Arguments to create many Orden_trabajos.
     * @example
     * // Create many Orden_trabajos
     * const orden_trabajo = await prisma.orden_trabajo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orden_trabajos and only return the `id`
     * const orden_trabajoWithIdOnly = await prisma.orden_trabajo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends orden_trabajoCreateManyAndReturnArgs>(args?: SelectSubset<T, orden_trabajoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Orden_trabajo.
     * @param {orden_trabajoDeleteArgs} args - Arguments to delete one Orden_trabajo.
     * @example
     * // Delete one Orden_trabajo
     * const Orden_trabajo = await prisma.orden_trabajo.delete({
     *   where: {
     *     // ... filter to delete one Orden_trabajo
     *   }
     * })
     * 
     */
    delete<T extends orden_trabajoDeleteArgs>(args: SelectSubset<T, orden_trabajoDeleteArgs<ExtArgs>>): Prisma__orden_trabajoClient<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Orden_trabajo.
     * @param {orden_trabajoUpdateArgs} args - Arguments to update one Orden_trabajo.
     * @example
     * // Update one Orden_trabajo
     * const orden_trabajo = await prisma.orden_trabajo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends orden_trabajoUpdateArgs>(args: SelectSubset<T, orden_trabajoUpdateArgs<ExtArgs>>): Prisma__orden_trabajoClient<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orden_trabajos.
     * @param {orden_trabajoDeleteManyArgs} args - Arguments to filter Orden_trabajos to delete.
     * @example
     * // Delete a few Orden_trabajos
     * const { count } = await prisma.orden_trabajo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends orden_trabajoDeleteManyArgs>(args?: SelectSubset<T, orden_trabajoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orden_trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orden_trabajoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orden_trabajos
     * const orden_trabajo = await prisma.orden_trabajo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends orden_trabajoUpdateManyArgs>(args: SelectSubset<T, orden_trabajoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orden_trabajos and returns the data updated in the database.
     * @param {orden_trabajoUpdateManyAndReturnArgs} args - Arguments to update many Orden_trabajos.
     * @example
     * // Update many Orden_trabajos
     * const orden_trabajo = await prisma.orden_trabajo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orden_trabajos and only return the `id`
     * const orden_trabajoWithIdOnly = await prisma.orden_trabajo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends orden_trabajoUpdateManyAndReturnArgs>(args: SelectSubset<T, orden_trabajoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Orden_trabajo.
     * @param {orden_trabajoUpsertArgs} args - Arguments to update or create a Orden_trabajo.
     * @example
     * // Update or create a Orden_trabajo
     * const orden_trabajo = await prisma.orden_trabajo.upsert({
     *   create: {
     *     // ... data to create a Orden_trabajo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orden_trabajo we want to update
     *   }
     * })
     */
    upsert<T extends orden_trabajoUpsertArgs>(args: SelectSubset<T, orden_trabajoUpsertArgs<ExtArgs>>): Prisma__orden_trabajoClient<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orden_trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orden_trabajoCountArgs} args - Arguments to filter Orden_trabajos to count.
     * @example
     * // Count the number of Orden_trabajos
     * const count = await prisma.orden_trabajo.count({
     *   where: {
     *     // ... the filter for the Orden_trabajos we want to count
     *   }
     * })
    **/
    count<T extends orden_trabajoCountArgs>(
      args?: Subset<T, orden_trabajoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Orden_trabajoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orden_trabajo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Orden_trabajoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Orden_trabajoAggregateArgs>(args: Subset<T, Orden_trabajoAggregateArgs>): Prisma.PrismaPromise<GetOrden_trabajoAggregateType<T>>

    /**
     * Group by Orden_trabajo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orden_trabajoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orden_trabajoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orden_trabajoGroupByArgs['orderBy'] }
        : { orderBy?: orden_trabajoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orden_trabajoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrden_trabajoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orden_trabajo model
   */
  readonly fields: orden_trabajoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orden_trabajo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orden_trabajoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comision<T extends orden_trabajo$comisionArgs<ExtArgs> = {}>(args?: Subset<T, orden_trabajo$comisionArgs<ExtArgs>>): Prisma__comisionClient<$Result.GetResult<Prisma.$comisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    movimiento_herramienta<T extends orden_trabajo$movimiento_herramientaArgs<ExtArgs> = {}>(args?: Subset<T, orden_trabajo$movimiento_herramientaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$movimiento_herramientaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    administrador<T extends orden_trabajo$administradorArgs<ExtArgs> = {}>(args?: Subset<T, orden_trabajo$administradorArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    empleado<T extends empleadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, empleadoDefaultArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    servicio<T extends servicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, servicioDefaultArgs<ExtArgs>>): Prisma__servicioClient<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the orden_trabajo model
   */
  interface orden_trabajoFieldRefs {
    readonly id: FieldRef<"orden_trabajo", 'BigInt'>
    readonly fecha_inicio: FieldRef<"orden_trabajo", 'DateTime'>
    readonly fecha_fin: FieldRef<"orden_trabajo", 'DateTime'>
    readonly estado: FieldRef<"orden_trabajo", 'estado_orden'>
    readonly empleado_ci: FieldRef<"orden_trabajo", 'Int'>
    readonly administrador_id: FieldRef<"orden_trabajo", 'Int'>
    readonly servicio_id: FieldRef<"orden_trabajo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * orden_trabajo findUnique
   */
  export type orden_trabajoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    /**
     * Filter, which orden_trabajo to fetch.
     */
    where: orden_trabajoWhereUniqueInput
  }

  /**
   * orden_trabajo findUniqueOrThrow
   */
  export type orden_trabajoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    /**
     * Filter, which orden_trabajo to fetch.
     */
    where: orden_trabajoWhereUniqueInput
  }

  /**
   * orden_trabajo findFirst
   */
  export type orden_trabajoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    /**
     * Filter, which orden_trabajo to fetch.
     */
    where?: orden_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orden_trabajos to fetch.
     */
    orderBy?: orden_trabajoOrderByWithRelationInput | orden_trabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orden_trabajos.
     */
    cursor?: orden_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orden_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orden_trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orden_trabajos.
     */
    distinct?: Orden_trabajoScalarFieldEnum | Orden_trabajoScalarFieldEnum[]
  }

  /**
   * orden_trabajo findFirstOrThrow
   */
  export type orden_trabajoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    /**
     * Filter, which orden_trabajo to fetch.
     */
    where?: orden_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orden_trabajos to fetch.
     */
    orderBy?: orden_trabajoOrderByWithRelationInput | orden_trabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orden_trabajos.
     */
    cursor?: orden_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orden_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orden_trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orden_trabajos.
     */
    distinct?: Orden_trabajoScalarFieldEnum | Orden_trabajoScalarFieldEnum[]
  }

  /**
   * orden_trabajo findMany
   */
  export type orden_trabajoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    /**
     * Filter, which orden_trabajos to fetch.
     */
    where?: orden_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orden_trabajos to fetch.
     */
    orderBy?: orden_trabajoOrderByWithRelationInput | orden_trabajoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orden_trabajos.
     */
    cursor?: orden_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orden_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orden_trabajos.
     */
    skip?: number
    distinct?: Orden_trabajoScalarFieldEnum | Orden_trabajoScalarFieldEnum[]
  }

  /**
   * orden_trabajo create
   */
  export type orden_trabajoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    /**
     * The data needed to create a orden_trabajo.
     */
    data: XOR<orden_trabajoCreateInput, orden_trabajoUncheckedCreateInput>
  }

  /**
   * orden_trabajo createMany
   */
  export type orden_trabajoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orden_trabajos.
     */
    data: orden_trabajoCreateManyInput | orden_trabajoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orden_trabajo createManyAndReturn
   */
  export type orden_trabajoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * The data used to create many orden_trabajos.
     */
    data: orden_trabajoCreateManyInput | orden_trabajoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * orden_trabajo update
   */
  export type orden_trabajoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    /**
     * The data needed to update a orden_trabajo.
     */
    data: XOR<orden_trabajoUpdateInput, orden_trabajoUncheckedUpdateInput>
    /**
     * Choose, which orden_trabajo to update.
     */
    where: orden_trabajoWhereUniqueInput
  }

  /**
   * orden_trabajo updateMany
   */
  export type orden_trabajoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orden_trabajos.
     */
    data: XOR<orden_trabajoUpdateManyMutationInput, orden_trabajoUncheckedUpdateManyInput>
    /**
     * Filter which orden_trabajos to update
     */
    where?: orden_trabajoWhereInput
    /**
     * Limit how many orden_trabajos to update.
     */
    limit?: number
  }

  /**
   * orden_trabajo updateManyAndReturn
   */
  export type orden_trabajoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * The data used to update orden_trabajos.
     */
    data: XOR<orden_trabajoUpdateManyMutationInput, orden_trabajoUncheckedUpdateManyInput>
    /**
     * Filter which orden_trabajos to update
     */
    where?: orden_trabajoWhereInput
    /**
     * Limit how many orden_trabajos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * orden_trabajo upsert
   */
  export type orden_trabajoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    /**
     * The filter to search for the orden_trabajo to update in case it exists.
     */
    where: orden_trabajoWhereUniqueInput
    /**
     * In case the orden_trabajo found by the `where` argument doesn't exist, create a new orden_trabajo with this data.
     */
    create: XOR<orden_trabajoCreateInput, orden_trabajoUncheckedCreateInput>
    /**
     * In case the orden_trabajo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orden_trabajoUpdateInput, orden_trabajoUncheckedUpdateInput>
  }

  /**
   * orden_trabajo delete
   */
  export type orden_trabajoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    /**
     * Filter which orden_trabajo to delete.
     */
    where: orden_trabajoWhereUniqueInput
  }

  /**
   * orden_trabajo deleteMany
   */
  export type orden_trabajoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orden_trabajos to delete
     */
    where?: orden_trabajoWhereInput
    /**
     * Limit how many orden_trabajos to delete.
     */
    limit?: number
  }

  /**
   * orden_trabajo.comision
   */
  export type orden_trabajo$comisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comision
     */
    select?: comisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comision
     */
    omit?: comisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comisionInclude<ExtArgs> | null
    where?: comisionWhereInput
  }

  /**
   * orden_trabajo.movimiento_herramienta
   */
  export type orden_trabajo$movimiento_herramientaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movimiento_herramienta
     */
    select?: movimiento_herramientaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the movimiento_herramienta
     */
    omit?: movimiento_herramientaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: movimiento_herramientaInclude<ExtArgs> | null
    where?: movimiento_herramientaWhereInput
    orderBy?: movimiento_herramientaOrderByWithRelationInput | movimiento_herramientaOrderByWithRelationInput[]
    cursor?: movimiento_herramientaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Movimiento_herramientaScalarFieldEnum | Movimiento_herramientaScalarFieldEnum[]
  }

  /**
   * orden_trabajo.administrador
   */
  export type orden_trabajo$administradorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    where?: administradorWhereInput
  }

  /**
   * orden_trabajo without action
   */
  export type orden_trabajoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
  }


  /**
   * Model proforma
   */

  export type AggregateProforma = {
    _count: ProformaCountAggregateOutputType | null
    _avg: ProformaAvgAggregateOutputType | null
    _sum: ProformaSumAggregateOutputType | null
    _min: ProformaMinAggregateOutputType | null
    _max: ProformaMaxAggregateOutputType | null
  }

  export type ProformaAvgAggregateOutputType = {
    id: number | null
    total: Decimal | null
    cliente_ci: number | null
    diagnostico_id: number | null
  }

  export type ProformaSumAggregateOutputType = {
    id: bigint | null
    total: Decimal | null
    cliente_ci: number | null
    diagnostico_id: bigint | null
  }

  export type ProformaMinAggregateOutputType = {
    id: bigint | null
    fecha: Date | null
    estado: $Enums.estado_proforma | null
    total: Decimal | null
    cliente_ci: number | null
    diagnostico_id: bigint | null
  }

  export type ProformaMaxAggregateOutputType = {
    id: bigint | null
    fecha: Date | null
    estado: $Enums.estado_proforma | null
    total: Decimal | null
    cliente_ci: number | null
    diagnostico_id: bigint | null
  }

  export type ProformaCountAggregateOutputType = {
    id: number
    fecha: number
    estado: number
    total: number
    cliente_ci: number
    diagnostico_id: number
    _all: number
  }


  export type ProformaAvgAggregateInputType = {
    id?: true
    total?: true
    cliente_ci?: true
    diagnostico_id?: true
  }

  export type ProformaSumAggregateInputType = {
    id?: true
    total?: true
    cliente_ci?: true
    diagnostico_id?: true
  }

  export type ProformaMinAggregateInputType = {
    id?: true
    fecha?: true
    estado?: true
    total?: true
    cliente_ci?: true
    diagnostico_id?: true
  }

  export type ProformaMaxAggregateInputType = {
    id?: true
    fecha?: true
    estado?: true
    total?: true
    cliente_ci?: true
    diagnostico_id?: true
  }

  export type ProformaCountAggregateInputType = {
    id?: true
    fecha?: true
    estado?: true
    total?: true
    cliente_ci?: true
    diagnostico_id?: true
    _all?: true
  }

  export type ProformaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proforma to aggregate.
     */
    where?: proformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proformas to fetch.
     */
    orderBy?: proformaOrderByWithRelationInput | proformaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proformas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proformas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proformas
    **/
    _count?: true | ProformaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProformaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProformaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProformaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProformaMaxAggregateInputType
  }

  export type GetProformaAggregateType<T extends ProformaAggregateArgs> = {
        [P in keyof T & keyof AggregateProforma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProforma[P]>
      : GetScalarType<T[P], AggregateProforma[P]>
  }




  export type proformaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proformaWhereInput
    orderBy?: proformaOrderByWithAggregationInput | proformaOrderByWithAggregationInput[]
    by: ProformaScalarFieldEnum[] | ProformaScalarFieldEnum
    having?: proformaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProformaCountAggregateInputType | true
    _avg?: ProformaAvgAggregateInputType
    _sum?: ProformaSumAggregateInputType
    _min?: ProformaMinAggregateInputType
    _max?: ProformaMaxAggregateInputType
  }

  export type ProformaGroupByOutputType = {
    id: bigint
    fecha: Date
    estado: $Enums.estado_proforma
    total: Decimal
    cliente_ci: number
    diagnostico_id: bigint | null
    _count: ProformaCountAggregateOutputType | null
    _avg: ProformaAvgAggregateOutputType | null
    _sum: ProformaSumAggregateOutputType | null
    _min: ProformaMinAggregateOutputType | null
    _max: ProformaMaxAggregateOutputType | null
  }

  type GetProformaGroupByPayload<T extends proformaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProformaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProformaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProformaGroupByOutputType[P]>
            : GetScalarType<T[P], ProformaGroupByOutputType[P]>
        }
      >
    >


  export type proformaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    estado?: boolean
    total?: boolean
    cliente_ci?: boolean
    diagnostico_id?: boolean
    detalle_proforma?: boolean | proforma$detalle_proformaArgs<ExtArgs>
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
    diagnostico?: boolean | proforma$diagnosticoArgs<ExtArgs>
    proforma_repuesto?: boolean | proforma$proforma_repuestoArgs<ExtArgs>
    _count?: boolean | ProformaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proforma"]>

  export type proformaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    estado?: boolean
    total?: boolean
    cliente_ci?: boolean
    diagnostico_id?: boolean
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
    diagnostico?: boolean | proforma$diagnosticoArgs<ExtArgs>
  }, ExtArgs["result"]["proforma"]>

  export type proformaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    estado?: boolean
    total?: boolean
    cliente_ci?: boolean
    diagnostico_id?: boolean
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
    diagnostico?: boolean | proforma$diagnosticoArgs<ExtArgs>
  }, ExtArgs["result"]["proforma"]>

  export type proformaSelectScalar = {
    id?: boolean
    fecha?: boolean
    estado?: boolean
    total?: boolean
    cliente_ci?: boolean
    diagnostico_id?: boolean
  }

  export type proformaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fecha" | "estado" | "total" | "cliente_ci" | "diagnostico_id", ExtArgs["result"]["proforma"]>
  export type proformaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_proforma?: boolean | proforma$detalle_proformaArgs<ExtArgs>
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
    diagnostico?: boolean | proforma$diagnosticoArgs<ExtArgs>
    proforma_repuesto?: boolean | proforma$proforma_repuestoArgs<ExtArgs>
    _count?: boolean | ProformaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type proformaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
    diagnostico?: boolean | proforma$diagnosticoArgs<ExtArgs>
  }
  export type proformaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | clienteDefaultArgs<ExtArgs>
    diagnostico?: boolean | proforma$diagnosticoArgs<ExtArgs>
  }

  export type $proformaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "proforma"
    objects: {
      detalle_proforma: Prisma.$detalle_proformaPayload<ExtArgs>[]
      cliente: Prisma.$clientePayload<ExtArgs>
      diagnostico: Prisma.$diagnosticoPayload<ExtArgs> | null
      proforma_repuesto: Prisma.$proforma_repuestoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      fecha: Date
      estado: $Enums.estado_proforma
      total: Prisma.Decimal
      cliente_ci: number
      diagnostico_id: bigint | null
    }, ExtArgs["result"]["proforma"]>
    composites: {}
  }

  type proformaGetPayload<S extends boolean | null | undefined | proformaDefaultArgs> = $Result.GetResult<Prisma.$proformaPayload, S>

  type proformaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<proformaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProformaCountAggregateInputType | true
    }

  export interface proformaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['proforma'], meta: { name: 'proforma' } }
    /**
     * Find zero or one Proforma that matches the filter.
     * @param {proformaFindUniqueArgs} args - Arguments to find a Proforma
     * @example
     * // Get one Proforma
     * const proforma = await prisma.proforma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends proformaFindUniqueArgs>(args: SelectSubset<T, proformaFindUniqueArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proforma that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {proformaFindUniqueOrThrowArgs} args - Arguments to find a Proforma
     * @example
     * // Get one Proforma
     * const proforma = await prisma.proforma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends proformaFindUniqueOrThrowArgs>(args: SelectSubset<T, proformaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proforma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proformaFindFirstArgs} args - Arguments to find a Proforma
     * @example
     * // Get one Proforma
     * const proforma = await prisma.proforma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends proformaFindFirstArgs>(args?: SelectSubset<T, proformaFindFirstArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proforma that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proformaFindFirstOrThrowArgs} args - Arguments to find a Proforma
     * @example
     * // Get one Proforma
     * const proforma = await prisma.proforma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends proformaFindFirstOrThrowArgs>(args?: SelectSubset<T, proformaFindFirstOrThrowArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proformas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proformaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proformas
     * const proformas = await prisma.proforma.findMany()
     * 
     * // Get first 10 Proformas
     * const proformas = await prisma.proforma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proformaWithIdOnly = await prisma.proforma.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends proformaFindManyArgs>(args?: SelectSubset<T, proformaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proforma.
     * @param {proformaCreateArgs} args - Arguments to create a Proforma.
     * @example
     * // Create one Proforma
     * const Proforma = await prisma.proforma.create({
     *   data: {
     *     // ... data to create a Proforma
     *   }
     * })
     * 
     */
    create<T extends proformaCreateArgs>(args: SelectSubset<T, proformaCreateArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proformas.
     * @param {proformaCreateManyArgs} args - Arguments to create many Proformas.
     * @example
     * // Create many Proformas
     * const proforma = await prisma.proforma.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends proformaCreateManyArgs>(args?: SelectSubset<T, proformaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proformas and returns the data saved in the database.
     * @param {proformaCreateManyAndReturnArgs} args - Arguments to create many Proformas.
     * @example
     * // Create many Proformas
     * const proforma = await prisma.proforma.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proformas and only return the `id`
     * const proformaWithIdOnly = await prisma.proforma.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends proformaCreateManyAndReturnArgs>(args?: SelectSubset<T, proformaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Proforma.
     * @param {proformaDeleteArgs} args - Arguments to delete one Proforma.
     * @example
     * // Delete one Proforma
     * const Proforma = await prisma.proforma.delete({
     *   where: {
     *     // ... filter to delete one Proforma
     *   }
     * })
     * 
     */
    delete<T extends proformaDeleteArgs>(args: SelectSubset<T, proformaDeleteArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proforma.
     * @param {proformaUpdateArgs} args - Arguments to update one Proforma.
     * @example
     * // Update one Proforma
     * const proforma = await prisma.proforma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends proformaUpdateArgs>(args: SelectSubset<T, proformaUpdateArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proformas.
     * @param {proformaDeleteManyArgs} args - Arguments to filter Proformas to delete.
     * @example
     * // Delete a few Proformas
     * const { count } = await prisma.proforma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends proformaDeleteManyArgs>(args?: SelectSubset<T, proformaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proformas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proformaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proformas
     * const proforma = await prisma.proforma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends proformaUpdateManyArgs>(args: SelectSubset<T, proformaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proformas and returns the data updated in the database.
     * @param {proformaUpdateManyAndReturnArgs} args - Arguments to update many Proformas.
     * @example
     * // Update many Proformas
     * const proforma = await prisma.proforma.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Proformas and only return the `id`
     * const proformaWithIdOnly = await prisma.proforma.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends proformaUpdateManyAndReturnArgs>(args: SelectSubset<T, proformaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Proforma.
     * @param {proformaUpsertArgs} args - Arguments to update or create a Proforma.
     * @example
     * // Update or create a Proforma
     * const proforma = await prisma.proforma.upsert({
     *   create: {
     *     // ... data to create a Proforma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proforma we want to update
     *   }
     * })
     */
    upsert<T extends proformaUpsertArgs>(args: SelectSubset<T, proformaUpsertArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proformas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proformaCountArgs} args - Arguments to filter Proformas to count.
     * @example
     * // Count the number of Proformas
     * const count = await prisma.proforma.count({
     *   where: {
     *     // ... the filter for the Proformas we want to count
     *   }
     * })
    **/
    count<T extends proformaCountArgs>(
      args?: Subset<T, proformaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProformaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proforma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProformaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProformaAggregateArgs>(args: Subset<T, ProformaAggregateArgs>): Prisma.PrismaPromise<GetProformaAggregateType<T>>

    /**
     * Group by Proforma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proformaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends proformaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: proformaGroupByArgs['orderBy'] }
        : { orderBy?: proformaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, proformaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProformaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the proforma model
   */
  readonly fields: proformaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for proforma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__proformaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detalle_proforma<T extends proforma$detalle_proformaArgs<ExtArgs> = {}>(args?: Subset<T, proforma$detalle_proformaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cliente<T extends clienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clienteDefaultArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    diagnostico<T extends proforma$diagnosticoArgs<ExtArgs> = {}>(args?: Subset<T, proforma$diagnosticoArgs<ExtArgs>>): Prisma__diagnosticoClient<$Result.GetResult<Prisma.$diagnosticoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proforma_repuesto<T extends proforma$proforma_repuestoArgs<ExtArgs> = {}>(args?: Subset<T, proforma$proforma_repuestoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the proforma model
   */
  interface proformaFieldRefs {
    readonly id: FieldRef<"proforma", 'BigInt'>
    readonly fecha: FieldRef<"proforma", 'DateTime'>
    readonly estado: FieldRef<"proforma", 'estado_proforma'>
    readonly total: FieldRef<"proforma", 'Decimal'>
    readonly cliente_ci: FieldRef<"proforma", 'Int'>
    readonly diagnostico_id: FieldRef<"proforma", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * proforma findUnique
   */
  export type proformaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    /**
     * Filter, which proforma to fetch.
     */
    where: proformaWhereUniqueInput
  }

  /**
   * proforma findUniqueOrThrow
   */
  export type proformaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    /**
     * Filter, which proforma to fetch.
     */
    where: proformaWhereUniqueInput
  }

  /**
   * proforma findFirst
   */
  export type proformaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    /**
     * Filter, which proforma to fetch.
     */
    where?: proformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proformas to fetch.
     */
    orderBy?: proformaOrderByWithRelationInput | proformaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proformas.
     */
    cursor?: proformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proformas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proformas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proformas.
     */
    distinct?: ProformaScalarFieldEnum | ProformaScalarFieldEnum[]
  }

  /**
   * proforma findFirstOrThrow
   */
  export type proformaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    /**
     * Filter, which proforma to fetch.
     */
    where?: proformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proformas to fetch.
     */
    orderBy?: proformaOrderByWithRelationInput | proformaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proformas.
     */
    cursor?: proformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proformas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proformas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proformas.
     */
    distinct?: ProformaScalarFieldEnum | ProformaScalarFieldEnum[]
  }

  /**
   * proforma findMany
   */
  export type proformaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    /**
     * Filter, which proformas to fetch.
     */
    where?: proformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proformas to fetch.
     */
    orderBy?: proformaOrderByWithRelationInput | proformaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proformas.
     */
    cursor?: proformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proformas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proformas.
     */
    skip?: number
    distinct?: ProformaScalarFieldEnum | ProformaScalarFieldEnum[]
  }

  /**
   * proforma create
   */
  export type proformaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    /**
     * The data needed to create a proforma.
     */
    data: XOR<proformaCreateInput, proformaUncheckedCreateInput>
  }

  /**
   * proforma createMany
   */
  export type proformaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many proformas.
     */
    data: proformaCreateManyInput | proformaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * proforma createManyAndReturn
   */
  export type proformaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * The data used to create many proformas.
     */
    data: proformaCreateManyInput | proformaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * proforma update
   */
  export type proformaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    /**
     * The data needed to update a proforma.
     */
    data: XOR<proformaUpdateInput, proformaUncheckedUpdateInput>
    /**
     * Choose, which proforma to update.
     */
    where: proformaWhereUniqueInput
  }

  /**
   * proforma updateMany
   */
  export type proformaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update proformas.
     */
    data: XOR<proformaUpdateManyMutationInput, proformaUncheckedUpdateManyInput>
    /**
     * Filter which proformas to update
     */
    where?: proformaWhereInput
    /**
     * Limit how many proformas to update.
     */
    limit?: number
  }

  /**
   * proforma updateManyAndReturn
   */
  export type proformaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * The data used to update proformas.
     */
    data: XOR<proformaUpdateManyMutationInput, proformaUncheckedUpdateManyInput>
    /**
     * Filter which proformas to update
     */
    where?: proformaWhereInput
    /**
     * Limit how many proformas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * proforma upsert
   */
  export type proformaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    /**
     * The filter to search for the proforma to update in case it exists.
     */
    where: proformaWhereUniqueInput
    /**
     * In case the proforma found by the `where` argument doesn't exist, create a new proforma with this data.
     */
    create: XOR<proformaCreateInput, proformaUncheckedCreateInput>
    /**
     * In case the proforma was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proformaUpdateInput, proformaUncheckedUpdateInput>
  }

  /**
   * proforma delete
   */
  export type proformaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
    /**
     * Filter which proforma to delete.
     */
    where: proformaWhereUniqueInput
  }

  /**
   * proforma deleteMany
   */
  export type proformaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proformas to delete
     */
    where?: proformaWhereInput
    /**
     * Limit how many proformas to delete.
     */
    limit?: number
  }

  /**
   * proforma.detalle_proforma
   */
  export type proforma$detalle_proformaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    where?: detalle_proformaWhereInput
    orderBy?: detalle_proformaOrderByWithRelationInput | detalle_proformaOrderByWithRelationInput[]
    cursor?: detalle_proformaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detalle_proformaScalarFieldEnum | Detalle_proformaScalarFieldEnum[]
  }

  /**
   * proforma.diagnostico
   */
  export type proforma$diagnosticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostico
     */
    select?: diagnosticoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostico
     */
    omit?: diagnosticoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnosticoInclude<ExtArgs> | null
    where?: diagnosticoWhereInput
  }

  /**
   * proforma.proforma_repuesto
   */
  export type proforma$proforma_repuestoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
    where?: proforma_repuestoWhereInput
    orderBy?: proforma_repuestoOrderByWithRelationInput | proforma_repuestoOrderByWithRelationInput[]
    cursor?: proforma_repuestoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Proforma_repuestoScalarFieldEnum | Proforma_repuestoScalarFieldEnum[]
  }

  /**
   * proforma without action
   */
  export type proformaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma
     */
    select?: proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma
     */
    omit?: proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proformaInclude<ExtArgs> | null
  }


  /**
   * Model proforma_repuesto
   */

  export type AggregateProforma_repuesto = {
    _count: Proforma_repuestoCountAggregateOutputType | null
    _avg: Proforma_repuestoAvgAggregateOutputType | null
    _sum: Proforma_repuestoSumAggregateOutputType | null
    _min: Proforma_repuestoMinAggregateOutputType | null
    _max: Proforma_repuestoMaxAggregateOutputType | null
  }

  export type Proforma_repuestoAvgAggregateOutputType = {
    id: number | null
    proforma_id: number | null
  }

  export type Proforma_repuestoSumAggregateOutputType = {
    id: number | null
    proforma_id: bigint | null
  }

  export type Proforma_repuestoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    proforma_id: bigint | null
  }

  export type Proforma_repuestoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    proforma_id: bigint | null
  }

  export type Proforma_repuestoCountAggregateOutputType = {
    id: number
    nombre: number
    proforma_id: number
    _all: number
  }


  export type Proforma_repuestoAvgAggregateInputType = {
    id?: true
    proforma_id?: true
  }

  export type Proforma_repuestoSumAggregateInputType = {
    id?: true
    proforma_id?: true
  }

  export type Proforma_repuestoMinAggregateInputType = {
    id?: true
    nombre?: true
    proforma_id?: true
  }

  export type Proforma_repuestoMaxAggregateInputType = {
    id?: true
    nombre?: true
    proforma_id?: true
  }

  export type Proforma_repuestoCountAggregateInputType = {
    id?: true
    nombre?: true
    proforma_id?: true
    _all?: true
  }

  export type Proforma_repuestoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proforma_repuesto to aggregate.
     */
    where?: proforma_repuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proforma_repuestos to fetch.
     */
    orderBy?: proforma_repuestoOrderByWithRelationInput | proforma_repuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proforma_repuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proforma_repuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proforma_repuestos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proforma_repuestos
    **/
    _count?: true | Proforma_repuestoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Proforma_repuestoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Proforma_repuestoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Proforma_repuestoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Proforma_repuestoMaxAggregateInputType
  }

  export type GetProforma_repuestoAggregateType<T extends Proforma_repuestoAggregateArgs> = {
        [P in keyof T & keyof AggregateProforma_repuesto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProforma_repuesto[P]>
      : GetScalarType<T[P], AggregateProforma_repuesto[P]>
  }




  export type proforma_repuestoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proforma_repuestoWhereInput
    orderBy?: proforma_repuestoOrderByWithAggregationInput | proforma_repuestoOrderByWithAggregationInput[]
    by: Proforma_repuestoScalarFieldEnum[] | Proforma_repuestoScalarFieldEnum
    having?: proforma_repuestoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Proforma_repuestoCountAggregateInputType | true
    _avg?: Proforma_repuestoAvgAggregateInputType
    _sum?: Proforma_repuestoSumAggregateInputType
    _min?: Proforma_repuestoMinAggregateInputType
    _max?: Proforma_repuestoMaxAggregateInputType
  }

  export type Proforma_repuestoGroupByOutputType = {
    id: number
    nombre: string
    proforma_id: bigint
    _count: Proforma_repuestoCountAggregateOutputType | null
    _avg: Proforma_repuestoAvgAggregateOutputType | null
    _sum: Proforma_repuestoSumAggregateOutputType | null
    _min: Proforma_repuestoMinAggregateOutputType | null
    _max: Proforma_repuestoMaxAggregateOutputType | null
  }

  type GetProforma_repuestoGroupByPayload<T extends proforma_repuestoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Proforma_repuestoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Proforma_repuestoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Proforma_repuestoGroupByOutputType[P]>
            : GetScalarType<T[P], Proforma_repuestoGroupByOutputType[P]>
        }
      >
    >


  export type proforma_repuestoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    proforma_id?: boolean
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proforma_repuesto"]>

  export type proforma_repuestoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    proforma_id?: boolean
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proforma_repuesto"]>

  export type proforma_repuestoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    proforma_id?: boolean
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proforma_repuesto"]>

  export type proforma_repuestoSelectScalar = {
    id?: boolean
    nombre?: boolean
    proforma_id?: boolean
  }

  export type proforma_repuestoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "proforma_id", ExtArgs["result"]["proforma_repuesto"]>
  export type proforma_repuestoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
  }
  export type proforma_repuestoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
  }
  export type proforma_repuestoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proforma?: boolean | proformaDefaultArgs<ExtArgs>
  }

  export type $proforma_repuestoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "proforma_repuesto"
    objects: {
      proforma: Prisma.$proformaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      proforma_id: bigint
    }, ExtArgs["result"]["proforma_repuesto"]>
    composites: {}
  }

  type proforma_repuestoGetPayload<S extends boolean | null | undefined | proforma_repuestoDefaultArgs> = $Result.GetResult<Prisma.$proforma_repuestoPayload, S>

  type proforma_repuestoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<proforma_repuestoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Proforma_repuestoCountAggregateInputType | true
    }

  export interface proforma_repuestoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['proforma_repuesto'], meta: { name: 'proforma_repuesto' } }
    /**
     * Find zero or one Proforma_repuesto that matches the filter.
     * @param {proforma_repuestoFindUniqueArgs} args - Arguments to find a Proforma_repuesto
     * @example
     * // Get one Proforma_repuesto
     * const proforma_repuesto = await prisma.proforma_repuesto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends proforma_repuestoFindUniqueArgs>(args: SelectSubset<T, proforma_repuestoFindUniqueArgs<ExtArgs>>): Prisma__proforma_repuestoClient<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proforma_repuesto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {proforma_repuestoFindUniqueOrThrowArgs} args - Arguments to find a Proforma_repuesto
     * @example
     * // Get one Proforma_repuesto
     * const proforma_repuesto = await prisma.proforma_repuesto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends proforma_repuestoFindUniqueOrThrowArgs>(args: SelectSubset<T, proforma_repuestoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__proforma_repuestoClient<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proforma_repuesto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proforma_repuestoFindFirstArgs} args - Arguments to find a Proforma_repuesto
     * @example
     * // Get one Proforma_repuesto
     * const proforma_repuesto = await prisma.proforma_repuesto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends proforma_repuestoFindFirstArgs>(args?: SelectSubset<T, proforma_repuestoFindFirstArgs<ExtArgs>>): Prisma__proforma_repuestoClient<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proforma_repuesto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proforma_repuestoFindFirstOrThrowArgs} args - Arguments to find a Proforma_repuesto
     * @example
     * // Get one Proforma_repuesto
     * const proforma_repuesto = await prisma.proforma_repuesto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends proforma_repuestoFindFirstOrThrowArgs>(args?: SelectSubset<T, proforma_repuestoFindFirstOrThrowArgs<ExtArgs>>): Prisma__proforma_repuestoClient<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proforma_repuestos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proforma_repuestoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proforma_repuestos
     * const proforma_repuestos = await prisma.proforma_repuesto.findMany()
     * 
     * // Get first 10 Proforma_repuestos
     * const proforma_repuestos = await prisma.proforma_repuesto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proforma_repuestoWithIdOnly = await prisma.proforma_repuesto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends proforma_repuestoFindManyArgs>(args?: SelectSubset<T, proforma_repuestoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proforma_repuesto.
     * @param {proforma_repuestoCreateArgs} args - Arguments to create a Proforma_repuesto.
     * @example
     * // Create one Proforma_repuesto
     * const Proforma_repuesto = await prisma.proforma_repuesto.create({
     *   data: {
     *     // ... data to create a Proforma_repuesto
     *   }
     * })
     * 
     */
    create<T extends proforma_repuestoCreateArgs>(args: SelectSubset<T, proforma_repuestoCreateArgs<ExtArgs>>): Prisma__proforma_repuestoClient<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proforma_repuestos.
     * @param {proforma_repuestoCreateManyArgs} args - Arguments to create many Proforma_repuestos.
     * @example
     * // Create many Proforma_repuestos
     * const proforma_repuesto = await prisma.proforma_repuesto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends proforma_repuestoCreateManyArgs>(args?: SelectSubset<T, proforma_repuestoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proforma_repuestos and returns the data saved in the database.
     * @param {proforma_repuestoCreateManyAndReturnArgs} args - Arguments to create many Proforma_repuestos.
     * @example
     * // Create many Proforma_repuestos
     * const proforma_repuesto = await prisma.proforma_repuesto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proforma_repuestos and only return the `id`
     * const proforma_repuestoWithIdOnly = await prisma.proforma_repuesto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends proforma_repuestoCreateManyAndReturnArgs>(args?: SelectSubset<T, proforma_repuestoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Proforma_repuesto.
     * @param {proforma_repuestoDeleteArgs} args - Arguments to delete one Proforma_repuesto.
     * @example
     * // Delete one Proforma_repuesto
     * const Proforma_repuesto = await prisma.proforma_repuesto.delete({
     *   where: {
     *     // ... filter to delete one Proforma_repuesto
     *   }
     * })
     * 
     */
    delete<T extends proforma_repuestoDeleteArgs>(args: SelectSubset<T, proforma_repuestoDeleteArgs<ExtArgs>>): Prisma__proforma_repuestoClient<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proforma_repuesto.
     * @param {proforma_repuestoUpdateArgs} args - Arguments to update one Proforma_repuesto.
     * @example
     * // Update one Proforma_repuesto
     * const proforma_repuesto = await prisma.proforma_repuesto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends proforma_repuestoUpdateArgs>(args: SelectSubset<T, proforma_repuestoUpdateArgs<ExtArgs>>): Prisma__proforma_repuestoClient<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proforma_repuestos.
     * @param {proforma_repuestoDeleteManyArgs} args - Arguments to filter Proforma_repuestos to delete.
     * @example
     * // Delete a few Proforma_repuestos
     * const { count } = await prisma.proforma_repuesto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends proforma_repuestoDeleteManyArgs>(args?: SelectSubset<T, proforma_repuestoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proforma_repuestos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proforma_repuestoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proforma_repuestos
     * const proforma_repuesto = await prisma.proforma_repuesto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends proforma_repuestoUpdateManyArgs>(args: SelectSubset<T, proforma_repuestoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proforma_repuestos and returns the data updated in the database.
     * @param {proforma_repuestoUpdateManyAndReturnArgs} args - Arguments to update many Proforma_repuestos.
     * @example
     * // Update many Proforma_repuestos
     * const proforma_repuesto = await prisma.proforma_repuesto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Proforma_repuestos and only return the `id`
     * const proforma_repuestoWithIdOnly = await prisma.proforma_repuesto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends proforma_repuestoUpdateManyAndReturnArgs>(args: SelectSubset<T, proforma_repuestoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Proforma_repuesto.
     * @param {proforma_repuestoUpsertArgs} args - Arguments to update or create a Proforma_repuesto.
     * @example
     * // Update or create a Proforma_repuesto
     * const proforma_repuesto = await prisma.proforma_repuesto.upsert({
     *   create: {
     *     // ... data to create a Proforma_repuesto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proforma_repuesto we want to update
     *   }
     * })
     */
    upsert<T extends proforma_repuestoUpsertArgs>(args: SelectSubset<T, proforma_repuestoUpsertArgs<ExtArgs>>): Prisma__proforma_repuestoClient<$Result.GetResult<Prisma.$proforma_repuestoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proforma_repuestos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proforma_repuestoCountArgs} args - Arguments to filter Proforma_repuestos to count.
     * @example
     * // Count the number of Proforma_repuestos
     * const count = await prisma.proforma_repuesto.count({
     *   where: {
     *     // ... the filter for the Proforma_repuestos we want to count
     *   }
     * })
    **/
    count<T extends proforma_repuestoCountArgs>(
      args?: Subset<T, proforma_repuestoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Proforma_repuestoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proforma_repuesto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Proforma_repuestoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Proforma_repuestoAggregateArgs>(args: Subset<T, Proforma_repuestoAggregateArgs>): Prisma.PrismaPromise<GetProforma_repuestoAggregateType<T>>

    /**
     * Group by Proforma_repuesto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proforma_repuestoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends proforma_repuestoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: proforma_repuestoGroupByArgs['orderBy'] }
        : { orderBy?: proforma_repuestoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, proforma_repuestoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProforma_repuestoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the proforma_repuesto model
   */
  readonly fields: proforma_repuestoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for proforma_repuesto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__proforma_repuestoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proforma<T extends proformaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, proformaDefaultArgs<ExtArgs>>): Prisma__proformaClient<$Result.GetResult<Prisma.$proformaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the proforma_repuesto model
   */
  interface proforma_repuestoFieldRefs {
    readonly id: FieldRef<"proforma_repuesto", 'Int'>
    readonly nombre: FieldRef<"proforma_repuesto", 'String'>
    readonly proforma_id: FieldRef<"proforma_repuesto", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * proforma_repuesto findUnique
   */
  export type proforma_repuestoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
    /**
     * Filter, which proforma_repuesto to fetch.
     */
    where: proforma_repuestoWhereUniqueInput
  }

  /**
   * proforma_repuesto findUniqueOrThrow
   */
  export type proforma_repuestoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
    /**
     * Filter, which proforma_repuesto to fetch.
     */
    where: proforma_repuestoWhereUniqueInput
  }

  /**
   * proforma_repuesto findFirst
   */
  export type proforma_repuestoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
    /**
     * Filter, which proforma_repuesto to fetch.
     */
    where?: proforma_repuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proforma_repuestos to fetch.
     */
    orderBy?: proforma_repuestoOrderByWithRelationInput | proforma_repuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proforma_repuestos.
     */
    cursor?: proforma_repuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proforma_repuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proforma_repuestos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proforma_repuestos.
     */
    distinct?: Proforma_repuestoScalarFieldEnum | Proforma_repuestoScalarFieldEnum[]
  }

  /**
   * proforma_repuesto findFirstOrThrow
   */
  export type proforma_repuestoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
    /**
     * Filter, which proforma_repuesto to fetch.
     */
    where?: proforma_repuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proforma_repuestos to fetch.
     */
    orderBy?: proforma_repuestoOrderByWithRelationInput | proforma_repuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proforma_repuestos.
     */
    cursor?: proforma_repuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proforma_repuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proforma_repuestos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proforma_repuestos.
     */
    distinct?: Proforma_repuestoScalarFieldEnum | Proforma_repuestoScalarFieldEnum[]
  }

  /**
   * proforma_repuesto findMany
   */
  export type proforma_repuestoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
    /**
     * Filter, which proforma_repuestos to fetch.
     */
    where?: proforma_repuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proforma_repuestos to fetch.
     */
    orderBy?: proforma_repuestoOrderByWithRelationInput | proforma_repuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proforma_repuestos.
     */
    cursor?: proforma_repuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proforma_repuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proforma_repuestos.
     */
    skip?: number
    distinct?: Proforma_repuestoScalarFieldEnum | Proforma_repuestoScalarFieldEnum[]
  }

  /**
   * proforma_repuesto create
   */
  export type proforma_repuestoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
    /**
     * The data needed to create a proforma_repuesto.
     */
    data: XOR<proforma_repuestoCreateInput, proforma_repuestoUncheckedCreateInput>
  }

  /**
   * proforma_repuesto createMany
   */
  export type proforma_repuestoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many proforma_repuestos.
     */
    data: proforma_repuestoCreateManyInput | proforma_repuestoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * proforma_repuesto createManyAndReturn
   */
  export type proforma_repuestoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * The data used to create many proforma_repuestos.
     */
    data: proforma_repuestoCreateManyInput | proforma_repuestoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * proforma_repuesto update
   */
  export type proforma_repuestoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
    /**
     * The data needed to update a proforma_repuesto.
     */
    data: XOR<proforma_repuestoUpdateInput, proforma_repuestoUncheckedUpdateInput>
    /**
     * Choose, which proforma_repuesto to update.
     */
    where: proforma_repuestoWhereUniqueInput
  }

  /**
   * proforma_repuesto updateMany
   */
  export type proforma_repuestoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update proforma_repuestos.
     */
    data: XOR<proforma_repuestoUpdateManyMutationInput, proforma_repuestoUncheckedUpdateManyInput>
    /**
     * Filter which proforma_repuestos to update
     */
    where?: proforma_repuestoWhereInput
    /**
     * Limit how many proforma_repuestos to update.
     */
    limit?: number
  }

  /**
   * proforma_repuesto updateManyAndReturn
   */
  export type proforma_repuestoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * The data used to update proforma_repuestos.
     */
    data: XOR<proforma_repuestoUpdateManyMutationInput, proforma_repuestoUncheckedUpdateManyInput>
    /**
     * Filter which proforma_repuestos to update
     */
    where?: proforma_repuestoWhereInput
    /**
     * Limit how many proforma_repuestos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * proforma_repuesto upsert
   */
  export type proforma_repuestoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
    /**
     * The filter to search for the proforma_repuesto to update in case it exists.
     */
    where: proforma_repuestoWhereUniqueInput
    /**
     * In case the proforma_repuesto found by the `where` argument doesn't exist, create a new proforma_repuesto with this data.
     */
    create: XOR<proforma_repuestoCreateInput, proforma_repuestoUncheckedCreateInput>
    /**
     * In case the proforma_repuesto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proforma_repuestoUpdateInput, proforma_repuestoUncheckedUpdateInput>
  }

  /**
   * proforma_repuesto delete
   */
  export type proforma_repuestoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
    /**
     * Filter which proforma_repuesto to delete.
     */
    where: proforma_repuestoWhereUniqueInput
  }

  /**
   * proforma_repuesto deleteMany
   */
  export type proforma_repuestoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proforma_repuestos to delete
     */
    where?: proforma_repuestoWhereInput
    /**
     * Limit how many proforma_repuestos to delete.
     */
    limit?: number
  }

  /**
   * proforma_repuesto without action
   */
  export type proforma_repuestoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proforma_repuesto
     */
    select?: proforma_repuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the proforma_repuesto
     */
    omit?: proforma_repuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: proforma_repuestoInclude<ExtArgs> | null
  }


  /**
   * Model servicio
   */

  export type AggregateServicio = {
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  export type ServicioAvgAggregateOutputType = {
    id: number | null
    categoria_id: number | null
  }

  export type ServicioSumAggregateOutputType = {
    id: number | null
    categoria_id: number | null
  }

  export type ServicioMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
    categoria_id: number | null
  }

  export type ServicioMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
    categoria_id: number | null
  }

  export type ServicioCountAggregateOutputType = {
    id: number
    descripcion: number
    categoria_id: number
    _all: number
  }


  export type ServicioAvgAggregateInputType = {
    id?: true
    categoria_id?: true
  }

  export type ServicioSumAggregateInputType = {
    id?: true
    categoria_id?: true
  }

  export type ServicioMinAggregateInputType = {
    id?: true
    descripcion?: true
    categoria_id?: true
  }

  export type ServicioMaxAggregateInputType = {
    id?: true
    descripcion?: true
    categoria_id?: true
  }

  export type ServicioCountAggregateInputType = {
    id?: true
    descripcion?: true
    categoria_id?: true
    _all?: true
  }

  export type ServicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicio to aggregate.
     */
    where?: servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: servicioOrderByWithRelationInput | servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicios
    **/
    _count?: true | ServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicioMaxAggregateInputType
  }

  export type GetServicioAggregateType<T extends ServicioAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio[P]>
      : GetScalarType<T[P], AggregateServicio[P]>
  }




  export type servicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicioWhereInput
    orderBy?: servicioOrderByWithAggregationInput | servicioOrderByWithAggregationInput[]
    by: ServicioScalarFieldEnum[] | ServicioScalarFieldEnum
    having?: servicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicioCountAggregateInputType | true
    _avg?: ServicioAvgAggregateInputType
    _sum?: ServicioSumAggregateInputType
    _min?: ServicioMinAggregateInputType
    _max?: ServicioMaxAggregateInputType
  }

  export type ServicioGroupByOutputType = {
    id: number
    descripcion: string
    categoria_id: number
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  type GetServicioGroupByPayload<T extends servicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicioGroupByOutputType[P]>
            : GetScalarType<T[P], ServicioGroupByOutputType[P]>
        }
      >
    >


  export type servicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descripcion?: boolean
    categoria_id?: boolean
    detalle_proforma?: boolean | servicio$detalle_proformaArgs<ExtArgs>
    orden_trabajo?: boolean | servicio$orden_trabajoArgs<ExtArgs>
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
    _count?: boolean | ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicio"]>

  export type servicioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descripcion?: boolean
    categoria_id?: boolean
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicio"]>

  export type servicioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descripcion?: boolean
    categoria_id?: boolean
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicio"]>

  export type servicioSelectScalar = {
    id?: boolean
    descripcion?: boolean
    categoria_id?: boolean
  }

  export type servicioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descripcion" | "categoria_id", ExtArgs["result"]["servicio"]>
  export type servicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalle_proforma?: boolean | servicio$detalle_proformaArgs<ExtArgs>
    orden_trabajo?: boolean | servicio$orden_trabajoArgs<ExtArgs>
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
    _count?: boolean | ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type servicioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
  }
  export type servicioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | categoriaDefaultArgs<ExtArgs>
  }

  export type $servicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "servicio"
    objects: {
      detalle_proforma: Prisma.$detalle_proformaPayload<ExtArgs>[]
      orden_trabajo: Prisma.$orden_trabajoPayload<ExtArgs>[]
      categoria: Prisma.$categoriaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descripcion: string
      categoria_id: number
    }, ExtArgs["result"]["servicio"]>
    composites: {}
  }

  type servicioGetPayload<S extends boolean | null | undefined | servicioDefaultArgs> = $Result.GetResult<Prisma.$servicioPayload, S>

  type servicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<servicioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicioCountAggregateInputType | true
    }

  export interface servicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicio'], meta: { name: 'servicio' } }
    /**
     * Find zero or one Servicio that matches the filter.
     * @param {servicioFindUniqueArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends servicioFindUniqueArgs>(args: SelectSubset<T, servicioFindUniqueArgs<ExtArgs>>): Prisma__servicioClient<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Servicio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {servicioFindUniqueOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends servicioFindUniqueOrThrowArgs>(args: SelectSubset<T, servicioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__servicioClient<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicioFindFirstArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends servicioFindFirstArgs>(args?: SelectSubset<T, servicioFindFirstArgs<ExtArgs>>): Prisma__servicioClient<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Servicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicioFindFirstOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends servicioFindFirstOrThrowArgs>(args?: SelectSubset<T, servicioFindFirstOrThrowArgs<ExtArgs>>): Prisma__servicioClient<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicio.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicioWithIdOnly = await prisma.servicio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends servicioFindManyArgs>(args?: SelectSubset<T, servicioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Servicio.
     * @param {servicioCreateArgs} args - Arguments to create a Servicio.
     * @example
     * // Create one Servicio
     * const Servicio = await prisma.servicio.create({
     *   data: {
     *     // ... data to create a Servicio
     *   }
     * })
     * 
     */
    create<T extends servicioCreateArgs>(args: SelectSubset<T, servicioCreateArgs<ExtArgs>>): Prisma__servicioClient<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Servicios.
     * @param {servicioCreateManyArgs} args - Arguments to create many Servicios.
     * @example
     * // Create many Servicios
     * const servicio = await prisma.servicio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends servicioCreateManyArgs>(args?: SelectSubset<T, servicioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Servicios and returns the data saved in the database.
     * @param {servicioCreateManyAndReturnArgs} args - Arguments to create many Servicios.
     * @example
     * // Create many Servicios
     * const servicio = await prisma.servicio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Servicios and only return the `id`
     * const servicioWithIdOnly = await prisma.servicio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends servicioCreateManyAndReturnArgs>(args?: SelectSubset<T, servicioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Servicio.
     * @param {servicioDeleteArgs} args - Arguments to delete one Servicio.
     * @example
     * // Delete one Servicio
     * const Servicio = await prisma.servicio.delete({
     *   where: {
     *     // ... filter to delete one Servicio
     *   }
     * })
     * 
     */
    delete<T extends servicioDeleteArgs>(args: SelectSubset<T, servicioDeleteArgs<ExtArgs>>): Prisma__servicioClient<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Servicio.
     * @param {servicioUpdateArgs} args - Arguments to update one Servicio.
     * @example
     * // Update one Servicio
     * const servicio = await prisma.servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends servicioUpdateArgs>(args: SelectSubset<T, servicioUpdateArgs<ExtArgs>>): Prisma__servicioClient<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Servicios.
     * @param {servicioDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends servicioDeleteManyArgs>(args?: SelectSubset<T, servicioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicio = await prisma.servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends servicioUpdateManyArgs>(args: SelectSubset<T, servicioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios and returns the data updated in the database.
     * @param {servicioUpdateManyAndReturnArgs} args - Arguments to update many Servicios.
     * @example
     * // Update many Servicios
     * const servicio = await prisma.servicio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Servicios and only return the `id`
     * const servicioWithIdOnly = await prisma.servicio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends servicioUpdateManyAndReturnArgs>(args: SelectSubset<T, servicioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Servicio.
     * @param {servicioUpsertArgs} args - Arguments to update or create a Servicio.
     * @example
     * // Update or create a Servicio
     * const servicio = await prisma.servicio.upsert({
     *   create: {
     *     // ... data to create a Servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio we want to update
     *   }
     * })
     */
    upsert<T extends servicioUpsertArgs>(args: SelectSubset<T, servicioUpsertArgs<ExtArgs>>): Prisma__servicioClient<$Result.GetResult<Prisma.$servicioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicioCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicio.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends servicioCountArgs>(
      args?: Subset<T, servicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicioAggregateArgs>(args: Subset<T, ServicioAggregateArgs>): Prisma.PrismaPromise<GetServicioAggregateType<T>>

    /**
     * Group by Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicioGroupByArgs['orderBy'] }
        : { orderBy?: servicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the servicio model
   */
  readonly fields: servicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__servicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detalle_proforma<T extends servicio$detalle_proformaArgs<ExtArgs> = {}>(args?: Subset<T, servicio$detalle_proformaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_proformaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orden_trabajo<T extends servicio$orden_trabajoArgs<ExtArgs> = {}>(args?: Subset<T, servicio$orden_trabajoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orden_trabajoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categoria<T extends categoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriaDefaultArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the servicio model
   */
  interface servicioFieldRefs {
    readonly id: FieldRef<"servicio", 'Int'>
    readonly descripcion: FieldRef<"servicio", 'String'>
    readonly categoria_id: FieldRef<"servicio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * servicio findUnique
   */
  export type servicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    /**
     * Filter, which servicio to fetch.
     */
    where: servicioWhereUniqueInput
  }

  /**
   * servicio findUniqueOrThrow
   */
  export type servicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    /**
     * Filter, which servicio to fetch.
     */
    where: servicioWhereUniqueInput
  }

  /**
   * servicio findFirst
   */
  export type servicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    /**
     * Filter, which servicio to fetch.
     */
    where?: servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: servicioOrderByWithRelationInput | servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     */
    cursor?: servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     */
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * servicio findFirstOrThrow
   */
  export type servicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    /**
     * Filter, which servicio to fetch.
     */
    where?: servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: servicioOrderByWithRelationInput | servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicios.
     */
    cursor?: servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicios.
     */
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * servicio findMany
   */
  export type servicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    /**
     * Filter, which servicios to fetch.
     */
    where?: servicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicios to fetch.
     */
    orderBy?: servicioOrderByWithRelationInput | servicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicios.
     */
    cursor?: servicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicios.
     */
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * servicio create
   */
  export type servicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    /**
     * The data needed to create a servicio.
     */
    data: XOR<servicioCreateInput, servicioUncheckedCreateInput>
  }

  /**
   * servicio createMany
   */
  export type servicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicios.
     */
    data: servicioCreateManyInput | servicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * servicio createManyAndReturn
   */
  export type servicioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * The data used to create many servicios.
     */
    data: servicioCreateManyInput | servicioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * servicio update
   */
  export type servicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    /**
     * The data needed to update a servicio.
     */
    data: XOR<servicioUpdateInput, servicioUncheckedUpdateInput>
    /**
     * Choose, which servicio to update.
     */
    where: servicioWhereUniqueInput
  }

  /**
   * servicio updateMany
   */
  export type servicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicios.
     */
    data: XOR<servicioUpdateManyMutationInput, servicioUncheckedUpdateManyInput>
    /**
     * Filter which servicios to update
     */
    where?: servicioWhereInput
    /**
     * Limit how many servicios to update.
     */
    limit?: number
  }

  /**
   * servicio updateManyAndReturn
   */
  export type servicioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * The data used to update servicios.
     */
    data: XOR<servicioUpdateManyMutationInput, servicioUncheckedUpdateManyInput>
    /**
     * Filter which servicios to update
     */
    where?: servicioWhereInput
    /**
     * Limit how many servicios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * servicio upsert
   */
  export type servicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    /**
     * The filter to search for the servicio to update in case it exists.
     */
    where: servicioWhereUniqueInput
    /**
     * In case the servicio found by the `where` argument doesn't exist, create a new servicio with this data.
     */
    create: XOR<servicioCreateInput, servicioUncheckedCreateInput>
    /**
     * In case the servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicioUpdateInput, servicioUncheckedUpdateInput>
  }

  /**
   * servicio delete
   */
  export type servicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
    /**
     * Filter which servicio to delete.
     */
    where: servicioWhereUniqueInput
  }

  /**
   * servicio deleteMany
   */
  export type servicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicios to delete
     */
    where?: servicioWhereInput
    /**
     * Limit how many servicios to delete.
     */
    limit?: number
  }

  /**
   * servicio.detalle_proforma
   */
  export type servicio$detalle_proformaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_proforma
     */
    select?: detalle_proformaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the detalle_proforma
     */
    omit?: detalle_proformaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: detalle_proformaInclude<ExtArgs> | null
    where?: detalle_proformaWhereInput
    orderBy?: detalle_proformaOrderByWithRelationInput | detalle_proformaOrderByWithRelationInput[]
    cursor?: detalle_proformaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detalle_proformaScalarFieldEnum | Detalle_proformaScalarFieldEnum[]
  }

  /**
   * servicio.orden_trabajo
   */
  export type servicio$orden_trabajoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orden_trabajo
     */
    select?: orden_trabajoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orden_trabajo
     */
    omit?: orden_trabajoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orden_trabajoInclude<ExtArgs> | null
    where?: orden_trabajoWhereInput
    orderBy?: orden_trabajoOrderByWithRelationInput | orden_trabajoOrderByWithRelationInput[]
    cursor?: orden_trabajoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Orden_trabajoScalarFieldEnum | Orden_trabajoScalarFieldEnum[]
  }

  /**
   * servicio without action
   */
  export type servicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicio
     */
    select?: servicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the servicio
     */
    omit?: servicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: servicioInclude<ExtArgs> | null
  }


  /**
   * Model usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    empleado_ci: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    empleado_ci: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    empleado_ci: number | null
    usuario: string | null
    contrasena: string | null
    email: string | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    empleado_ci: number | null
    usuario: string | null
    contrasena: string | null
    email: string | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    empleado_ci: number
    usuario: number
    contrasena: number
    email: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    empleado_ci?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    empleado_ci?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    empleado_ci?: true
    usuario?: true
    contrasena?: true
    email?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    empleado_ci?: true
    usuario?: true
    contrasena?: true
    email?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    empleado_ci?: true
    usuario?: true
    contrasena?: true
    email?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario to aggregate.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type usuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithAggregationInput | usuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    empleado_ci: number
    usuario: string
    contrasena: string
    email: string | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends usuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empleado_ci?: boolean
    usuario?: boolean
    contrasena?: boolean
    email?: boolean
    administrador?: boolean | usuario$administradorArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empleado_ci?: boolean
    usuario?: boolean
    contrasena?: boolean
    email?: boolean
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empleado_ci?: boolean
    usuario?: boolean
    contrasena?: boolean
    email?: boolean
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectScalar = {
    id?: boolean
    empleado_ci?: boolean
    usuario?: boolean
    contrasena?: boolean
    email?: boolean
  }

  export type usuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "empleado_ci" | "usuario" | "contrasena" | "email", ExtArgs["result"]["usuario"]>
  export type usuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    administrador?: boolean | usuario$administradorArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
  }
  export type usuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
  }
  export type usuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
  }

  export type $usuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuario"
    objects: {
      administrador: Prisma.$administradorPayload<ExtArgs> | null
      empleado: Prisma.$empleadoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      empleado_ci: number
      usuario: string
      contrasena: string
      email: string | null
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type usuarioGetPayload<S extends boolean | null | undefined | usuarioDefaultArgs> = $Result.GetResult<Prisma.$usuarioPayload, S>

  type usuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface usuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuario'], meta: { name: 'usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuarioFindUniqueArgs>(args: SelectSubset<T, usuarioFindUniqueArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, usuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuarioFindFirstArgs>(args?: SelectSubset<T, usuarioFindFirstArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, usuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuarioFindManyArgs>(args?: SelectSubset<T, usuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends usuarioCreateArgs>(args: SelectSubset<T, usuarioCreateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuarioCreateManyArgs>(args?: SelectSubset<T, usuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {usuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, usuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends usuarioDeleteArgs>(args: SelectSubset<T, usuarioDeleteArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuarioUpdateArgs>(args: SelectSubset<T, usuarioUpdateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuarioDeleteManyArgs>(args?: SelectSubset<T, usuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuarioUpdateManyArgs>(args: SelectSubset<T, usuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {usuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, usuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends usuarioUpsertArgs>(args: SelectSubset<T, usuarioUpsertArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuarioGroupByArgs['orderBy'] }
        : { orderBy?: usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuario model
   */
  readonly fields: usuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    administrador<T extends usuario$administradorArgs<ExtArgs> = {}>(args?: Subset<T, usuario$administradorArgs<ExtArgs>>): Prisma__administradorClient<$Result.GetResult<Prisma.$administradorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    empleado<T extends empleadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, empleadoDefaultArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuario model
   */
  interface usuarioFieldRefs {
    readonly id: FieldRef<"usuario", 'Int'>
    readonly empleado_ci: FieldRef<"usuario", 'Int'>
    readonly usuario: FieldRef<"usuario", 'String'>
    readonly contrasena: FieldRef<"usuario", 'String'>
    readonly email: FieldRef<"usuario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * usuario findUnique
   */
  export type usuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findFirst
   */
  export type usuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario create
   */
  export type usuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a usuario.
     */
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }

  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuario createManyAndReturn
   */
  export type usuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * usuario update
   */
  export type usuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a usuario.
     */
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
    /**
     * Limit how many usuarios to update.
     */
    limit?: number
  }

  /**
   * usuario updateManyAndReturn
   */
  export type usuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
    /**
     * Limit how many usuarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the usuario to update in case it exists.
     */
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     */
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }

  /**
   * usuario delete
   */
  export type usuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter which usuario to delete.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuarioWhereInput
    /**
     * Limit how many usuarios to delete.
     */
    limit?: number
  }

  /**
   * usuario.administrador
   */
  export type usuario$administradorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrador
     */
    select?: administradorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the administrador
     */
    omit?: administradorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administradorInclude<ExtArgs> | null
    where?: administradorWhereInput
  }

  /**
   * usuario without action
   */
  export type usuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuario
     */
    omit?: usuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdministradorScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id'
  };

  export type AdministradorScalarFieldEnum = (typeof AdministradorScalarFieldEnum)[keyof typeof AdministradorScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    ci: 'ci',
    nombre: 'nombre',
    telefono: 'telefono',
    direccion: 'direccion'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const ComisionScalarFieldEnum: {
    id: 'id',
    orden_id: 'orden_id',
    monto: 'monto',
    estado_pago: 'estado_pago',
    fecha_pago: 'fecha_pago'
  };

  export type ComisionScalarFieldEnum = (typeof ComisionScalarFieldEnum)[keyof typeof ComisionScalarFieldEnum]


  export const Detalle_diagnosticoScalarFieldEnum: {
    id: 'id',
    diagnostico_id: 'diagnostico_id',
    descripcion: 'descripcion'
  };

  export type Detalle_diagnosticoScalarFieldEnum = (typeof Detalle_diagnosticoScalarFieldEnum)[keyof typeof Detalle_diagnosticoScalarFieldEnum]


  export const Detalle_proformaScalarFieldEnum: {
    id: 'id',
    proforma_id: 'proforma_id',
    servicio_id: 'servicio_id',
    descripcion: 'descripcion',
    cantidad: 'cantidad',
    precio_unit: 'precio_unit',
    subtotal: 'subtotal'
  };

  export type Detalle_proformaScalarFieldEnum = (typeof Detalle_proformaScalarFieldEnum)[keyof typeof Detalle_proformaScalarFieldEnum]


  export const DiagnosticoScalarFieldEnum: {
    nro: 'nro',
    fecha: 'fecha',
    hora: 'hora',
    placa_moto: 'placa_moto',
    empleado_ci: 'empleado_ci'
  };

  export type DiagnosticoScalarFieldEnum = (typeof DiagnosticoScalarFieldEnum)[keyof typeof DiagnosticoScalarFieldEnum]


  export const EmpleadoScalarFieldEnum: {
    ci: 'ci',
    nombre: 'nombre',
    fechanac: 'fechanac',
    direccion: 'direccion',
    telefono: 'telefono'
  };

  export type EmpleadoScalarFieldEnum = (typeof EmpleadoScalarFieldEnum)[keyof typeof EmpleadoScalarFieldEnum]


  export const FacturaScalarFieldEnum: {
    id: 'id',
    monto: 'monto',
    fecha: 'fecha',
    cliente_ci: 'cliente_ci'
  };

  export type FacturaScalarFieldEnum = (typeof FacturaScalarFieldEnum)[keyof typeof FacturaScalarFieldEnum]


  export const HerramientaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    marca_id: 'marca_id'
  };

  export type HerramientaScalarFieldEnum = (typeof HerramientaScalarFieldEnum)[keyof typeof HerramientaScalarFieldEnum]


  export const HorarioScalarFieldEnum: {
    id: 'id',
    hora_inicio: 'hora_inicio',
    hora_fin: 'hora_fin'
  };

  export type HorarioScalarFieldEnum = (typeof HorarioScalarFieldEnum)[keyof typeof HorarioScalarFieldEnum]


  export const Horario_empleadoScalarFieldEnum: {
    empleado_ci: 'empleado_ci',
    horario_id: 'horario_id',
    fecha: 'fecha'
  };

  export type Horario_empleadoScalarFieldEnum = (typeof Horario_empleadoScalarFieldEnum)[keyof typeof Horario_empleadoScalarFieldEnum]


  export const Marca_herramientaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type Marca_herramientaScalarFieldEnum = (typeof Marca_herramientaScalarFieldEnum)[keyof typeof Marca_herramientaScalarFieldEnum]


  export const Marca_motoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type Marca_motoScalarFieldEnum = (typeof Marca_motoScalarFieldEnum)[keyof typeof Marca_motoScalarFieldEnum]


  export const MotoScalarFieldEnum: {
    placa: 'placa',
    modelo: 'modelo',
    year: 'year',
    chasis: 'chasis',
    marca_id: 'marca_id'
  };

  export type MotoScalarFieldEnum = (typeof MotoScalarFieldEnum)[keyof typeof MotoScalarFieldEnum]


  export const Movimiento_herramientaScalarFieldEnum: {
    herramienta_id: 'herramienta_id',
    orden_trabajo_id: 'orden_trabajo_id',
    fecha: 'fecha',
    cantidad: 'cantidad'
  };

  export type Movimiento_herramientaScalarFieldEnum = (typeof Movimiento_herramientaScalarFieldEnum)[keyof typeof Movimiento_herramientaScalarFieldEnum]


  export const Orden_trabajoScalarFieldEnum: {
    id: 'id',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    estado: 'estado',
    empleado_ci: 'empleado_ci',
    administrador_id: 'administrador_id',
    servicio_id: 'servicio_id'
  };

  export type Orden_trabajoScalarFieldEnum = (typeof Orden_trabajoScalarFieldEnum)[keyof typeof Orden_trabajoScalarFieldEnum]


  export const ProformaScalarFieldEnum: {
    id: 'id',
    fecha: 'fecha',
    estado: 'estado',
    total: 'total',
    cliente_ci: 'cliente_ci',
    diagnostico_id: 'diagnostico_id'
  };

  export type ProformaScalarFieldEnum = (typeof ProformaScalarFieldEnum)[keyof typeof ProformaScalarFieldEnum]


  export const Proforma_repuestoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    proforma_id: 'proforma_id'
  };

  export type Proforma_repuestoScalarFieldEnum = (typeof Proforma_repuestoScalarFieldEnum)[keyof typeof Proforma_repuestoScalarFieldEnum]


  export const ServicioScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion',
    categoria_id: 'categoria_id'
  };

  export type ServicioScalarFieldEnum = (typeof ServicioScalarFieldEnum)[keyof typeof ServicioScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    empleado_ci: 'empleado_ci',
    usuario: 'usuario',
    contrasena: 'contrasena',
    email: 'email'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'estado_pago'
   */
  export type Enumestado_pagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'estado_pago'>
    


  /**
   * Reference to a field of type 'estado_pago[]'
   */
  export type ListEnumestado_pagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'estado_pago[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'estado_orden'
   */
  export type Enumestado_ordenFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'estado_orden'>
    


  /**
   * Reference to a field of type 'estado_orden[]'
   */
  export type ListEnumestado_ordenFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'estado_orden[]'>
    


  /**
   * Reference to a field of type 'estado_proforma'
   */
  export type Enumestado_proformaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'estado_proforma'>
    


  /**
   * Reference to a field of type 'estado_proforma[]'
   */
  export type ListEnumestado_proformaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'estado_proforma[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type administradorWhereInput = {
    AND?: administradorWhereInput | administradorWhereInput[]
    OR?: administradorWhereInput[]
    NOT?: administradorWhereInput | administradorWhereInput[]
    id?: IntFilter<"administrador"> | number
    usuario_id?: IntFilter<"administrador"> | number
    usuario?: XOR<UsuarioScalarRelationFilter, usuarioWhereInput>
    orden_trabajo?: Orden_trabajoListRelationFilter
  }

  export type administradorOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
    orden_trabajo?: orden_trabajoOrderByRelationAggregateInput
  }

  export type administradorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    usuario_id?: number
    AND?: administradorWhereInput | administradorWhereInput[]
    OR?: administradorWhereInput[]
    NOT?: administradorWhereInput | administradorWhereInput[]
    usuario?: XOR<UsuarioScalarRelationFilter, usuarioWhereInput>
    orden_trabajo?: Orden_trabajoListRelationFilter
  }, "id" | "usuario_id">

  export type administradorOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    _count?: administradorCountOrderByAggregateInput
    _avg?: administradorAvgOrderByAggregateInput
    _max?: administradorMaxOrderByAggregateInput
    _min?: administradorMinOrderByAggregateInput
    _sum?: administradorSumOrderByAggregateInput
  }

  export type administradorScalarWhereWithAggregatesInput = {
    AND?: administradorScalarWhereWithAggregatesInput | administradorScalarWhereWithAggregatesInput[]
    OR?: administradorScalarWhereWithAggregatesInput[]
    NOT?: administradorScalarWhereWithAggregatesInput | administradorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"administrador"> | number
    usuario_id?: IntWithAggregatesFilter<"administrador"> | number
  }

  export type categoriaWhereInput = {
    AND?: categoriaWhereInput | categoriaWhereInput[]
    OR?: categoriaWhereInput[]
    NOT?: categoriaWhereInput | categoriaWhereInput[]
    id?: IntFilter<"categoria"> | number
    nombre?: StringFilter<"categoria"> | string
    servicio?: ServicioListRelationFilter
  }

  export type categoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    servicio?: servicioOrderByRelationAggregateInput
  }

  export type categoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: categoriaWhereInput | categoriaWhereInput[]
    OR?: categoriaWhereInput[]
    NOT?: categoriaWhereInput | categoriaWhereInput[]
    nombre?: StringFilter<"categoria"> | string
    servicio?: ServicioListRelationFilter
  }, "id">

  export type categoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: categoriaCountOrderByAggregateInput
    _avg?: categoriaAvgOrderByAggregateInput
    _max?: categoriaMaxOrderByAggregateInput
    _min?: categoriaMinOrderByAggregateInput
    _sum?: categoriaSumOrderByAggregateInput
  }

  export type categoriaScalarWhereWithAggregatesInput = {
    AND?: categoriaScalarWhereWithAggregatesInput | categoriaScalarWhereWithAggregatesInput[]
    OR?: categoriaScalarWhereWithAggregatesInput[]
    NOT?: categoriaScalarWhereWithAggregatesInput | categoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"categoria"> | number
    nombre?: StringWithAggregatesFilter<"categoria"> | string
  }

  export type clienteWhereInput = {
    AND?: clienteWhereInput | clienteWhereInput[]
    OR?: clienteWhereInput[]
    NOT?: clienteWhereInput | clienteWhereInput[]
    ci?: IntFilter<"cliente"> | number
    nombre?: StringFilter<"cliente"> | string
    telefono?: StringFilter<"cliente"> | string
    direccion?: StringFilter<"cliente"> | string
    factura?: FacturaListRelationFilter
    proforma?: ProformaListRelationFilter
  }

  export type clienteOrderByWithRelationInput = {
    ci?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    factura?: facturaOrderByRelationAggregateInput
    proforma?: proformaOrderByRelationAggregateInput
  }

  export type clienteWhereUniqueInput = Prisma.AtLeast<{
    ci?: number
    AND?: clienteWhereInput | clienteWhereInput[]
    OR?: clienteWhereInput[]
    NOT?: clienteWhereInput | clienteWhereInput[]
    nombre?: StringFilter<"cliente"> | string
    telefono?: StringFilter<"cliente"> | string
    direccion?: StringFilter<"cliente"> | string
    factura?: FacturaListRelationFilter
    proforma?: ProformaListRelationFilter
  }, "ci">

  export type clienteOrderByWithAggregationInput = {
    ci?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    _count?: clienteCountOrderByAggregateInput
    _avg?: clienteAvgOrderByAggregateInput
    _max?: clienteMaxOrderByAggregateInput
    _min?: clienteMinOrderByAggregateInput
    _sum?: clienteSumOrderByAggregateInput
  }

  export type clienteScalarWhereWithAggregatesInput = {
    AND?: clienteScalarWhereWithAggregatesInput | clienteScalarWhereWithAggregatesInput[]
    OR?: clienteScalarWhereWithAggregatesInput[]
    NOT?: clienteScalarWhereWithAggregatesInput | clienteScalarWhereWithAggregatesInput[]
    ci?: IntWithAggregatesFilter<"cliente"> | number
    nombre?: StringWithAggregatesFilter<"cliente"> | string
    telefono?: StringWithAggregatesFilter<"cliente"> | string
    direccion?: StringWithAggregatesFilter<"cliente"> | string
  }

  export type comisionWhereInput = {
    AND?: comisionWhereInput | comisionWhereInput[]
    OR?: comisionWhereInput[]
    NOT?: comisionWhereInput | comisionWhereInput[]
    id?: IntFilter<"comision"> | number
    orden_id?: BigIntNullableFilter<"comision"> | bigint | number | null
    monto?: DecimalFilter<"comision"> | Decimal | DecimalJsLike | number | string
    estado_pago?: Enumestado_pagoFilter<"comision"> | $Enums.estado_pago
    fecha_pago?: DateTimeNullableFilter<"comision"> | Date | string | null
    orden_trabajo?: XOR<Orden_trabajoNullableScalarRelationFilter, orden_trabajoWhereInput> | null
  }

  export type comisionOrderByWithRelationInput = {
    id?: SortOrder
    orden_id?: SortOrderInput | SortOrder
    monto?: SortOrder
    estado_pago?: SortOrder
    fecha_pago?: SortOrderInput | SortOrder
    orden_trabajo?: orden_trabajoOrderByWithRelationInput
  }

  export type comisionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orden_id?: bigint | number
    AND?: comisionWhereInput | comisionWhereInput[]
    OR?: comisionWhereInput[]
    NOT?: comisionWhereInput | comisionWhereInput[]
    monto?: DecimalFilter<"comision"> | Decimal | DecimalJsLike | number | string
    estado_pago?: Enumestado_pagoFilter<"comision"> | $Enums.estado_pago
    fecha_pago?: DateTimeNullableFilter<"comision"> | Date | string | null
    orden_trabajo?: XOR<Orden_trabajoNullableScalarRelationFilter, orden_trabajoWhereInput> | null
  }, "id" | "orden_id">

  export type comisionOrderByWithAggregationInput = {
    id?: SortOrder
    orden_id?: SortOrderInput | SortOrder
    monto?: SortOrder
    estado_pago?: SortOrder
    fecha_pago?: SortOrderInput | SortOrder
    _count?: comisionCountOrderByAggregateInput
    _avg?: comisionAvgOrderByAggregateInput
    _max?: comisionMaxOrderByAggregateInput
    _min?: comisionMinOrderByAggregateInput
    _sum?: comisionSumOrderByAggregateInput
  }

  export type comisionScalarWhereWithAggregatesInput = {
    AND?: comisionScalarWhereWithAggregatesInput | comisionScalarWhereWithAggregatesInput[]
    OR?: comisionScalarWhereWithAggregatesInput[]
    NOT?: comisionScalarWhereWithAggregatesInput | comisionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"comision"> | number
    orden_id?: BigIntNullableWithAggregatesFilter<"comision"> | bigint | number | null
    monto?: DecimalWithAggregatesFilter<"comision"> | Decimal | DecimalJsLike | number | string
    estado_pago?: Enumestado_pagoWithAggregatesFilter<"comision"> | $Enums.estado_pago
    fecha_pago?: DateTimeNullableWithAggregatesFilter<"comision"> | Date | string | null
  }

  export type detalle_diagnosticoWhereInput = {
    AND?: detalle_diagnosticoWhereInput | detalle_diagnosticoWhereInput[]
    OR?: detalle_diagnosticoWhereInput[]
    NOT?: detalle_diagnosticoWhereInput | detalle_diagnosticoWhereInput[]
    id?: BigIntFilter<"detalle_diagnostico"> | bigint | number
    diagnostico_id?: BigIntFilter<"detalle_diagnostico"> | bigint | number
    descripcion?: StringFilter<"detalle_diagnostico"> | string
    diagnostico?: XOR<DiagnosticoScalarRelationFilter, diagnosticoWhereInput>
  }

  export type detalle_diagnosticoOrderByWithRelationInput = {
    id?: SortOrder
    diagnostico_id?: SortOrder
    descripcion?: SortOrder
    diagnostico?: diagnosticoOrderByWithRelationInput
  }

  export type detalle_diagnosticoWhereUniqueInput = Prisma.AtLeast<{
    id_diagnostico_id?: detalle_diagnosticoIdDiagnostico_idCompoundUniqueInput
    AND?: detalle_diagnosticoWhereInput | detalle_diagnosticoWhereInput[]
    OR?: detalle_diagnosticoWhereInput[]
    NOT?: detalle_diagnosticoWhereInput | detalle_diagnosticoWhereInput[]
    id?: BigIntFilter<"detalle_diagnostico"> | bigint | number
    diagnostico_id?: BigIntFilter<"detalle_diagnostico"> | bigint | number
    descripcion?: StringFilter<"detalle_diagnostico"> | string
    diagnostico?: XOR<DiagnosticoScalarRelationFilter, diagnosticoWhereInput>
  }, "id_diagnostico_id">

  export type detalle_diagnosticoOrderByWithAggregationInput = {
    id?: SortOrder
    diagnostico_id?: SortOrder
    descripcion?: SortOrder
    _count?: detalle_diagnosticoCountOrderByAggregateInput
    _avg?: detalle_diagnosticoAvgOrderByAggregateInput
    _max?: detalle_diagnosticoMaxOrderByAggregateInput
    _min?: detalle_diagnosticoMinOrderByAggregateInput
    _sum?: detalle_diagnosticoSumOrderByAggregateInput
  }

  export type detalle_diagnosticoScalarWhereWithAggregatesInput = {
    AND?: detalle_diagnosticoScalarWhereWithAggregatesInput | detalle_diagnosticoScalarWhereWithAggregatesInput[]
    OR?: detalle_diagnosticoScalarWhereWithAggregatesInput[]
    NOT?: detalle_diagnosticoScalarWhereWithAggregatesInput | detalle_diagnosticoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"detalle_diagnostico"> | bigint | number
    diagnostico_id?: BigIntWithAggregatesFilter<"detalle_diagnostico"> | bigint | number
    descripcion?: StringWithAggregatesFilter<"detalle_diagnostico"> | string
  }

  export type detalle_proformaWhereInput = {
    AND?: detalle_proformaWhereInput | detalle_proformaWhereInput[]
    OR?: detalle_proformaWhereInput[]
    NOT?: detalle_proformaWhereInput | detalle_proformaWhereInput[]
    id?: BigIntFilter<"detalle_proforma"> | bigint | number
    proforma_id?: BigIntFilter<"detalle_proforma"> | bigint | number
    servicio_id?: IntNullableFilter<"detalle_proforma"> | number | null
    descripcion?: StringFilter<"detalle_proforma"> | string
    cantidad?: DecimalFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalNullableFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string | null
    proforma?: XOR<ProformaScalarRelationFilter, proformaWhereInput>
    servicio?: XOR<ServicioNullableScalarRelationFilter, servicioWhereInput> | null
  }

  export type detalle_proformaOrderByWithRelationInput = {
    id?: SortOrder
    proforma_id?: SortOrder
    servicio_id?: SortOrderInput | SortOrder
    descripcion?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrderInput | SortOrder
    proforma?: proformaOrderByWithRelationInput
    servicio?: servicioOrderByWithRelationInput
  }

  export type detalle_proformaWhereUniqueInput = Prisma.AtLeast<{
    id_proforma_id?: detalle_proformaIdProforma_idCompoundUniqueInput
    AND?: detalle_proformaWhereInput | detalle_proformaWhereInput[]
    OR?: detalle_proformaWhereInput[]
    NOT?: detalle_proformaWhereInput | detalle_proformaWhereInput[]
    id?: BigIntFilter<"detalle_proforma"> | bigint | number
    proforma_id?: BigIntFilter<"detalle_proforma"> | bigint | number
    servicio_id?: IntNullableFilter<"detalle_proforma"> | number | null
    descripcion?: StringFilter<"detalle_proforma"> | string
    cantidad?: DecimalFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalNullableFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string | null
    proforma?: XOR<ProformaScalarRelationFilter, proformaWhereInput>
    servicio?: XOR<ServicioNullableScalarRelationFilter, servicioWhereInput> | null
  }, "id_proforma_id">

  export type detalle_proformaOrderByWithAggregationInput = {
    id?: SortOrder
    proforma_id?: SortOrder
    servicio_id?: SortOrderInput | SortOrder
    descripcion?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrderInput | SortOrder
    _count?: detalle_proformaCountOrderByAggregateInput
    _avg?: detalle_proformaAvgOrderByAggregateInput
    _max?: detalle_proformaMaxOrderByAggregateInput
    _min?: detalle_proformaMinOrderByAggregateInput
    _sum?: detalle_proformaSumOrderByAggregateInput
  }

  export type detalle_proformaScalarWhereWithAggregatesInput = {
    AND?: detalle_proformaScalarWhereWithAggregatesInput | detalle_proformaScalarWhereWithAggregatesInput[]
    OR?: detalle_proformaScalarWhereWithAggregatesInput[]
    NOT?: detalle_proformaScalarWhereWithAggregatesInput | detalle_proformaScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"detalle_proforma"> | bigint | number
    proforma_id?: BigIntWithAggregatesFilter<"detalle_proforma"> | bigint | number
    servicio_id?: IntNullableWithAggregatesFilter<"detalle_proforma"> | number | null
    descripcion?: StringWithAggregatesFilter<"detalle_proforma"> | string
    cantidad?: DecimalWithAggregatesFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalWithAggregatesFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalNullableWithAggregatesFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string | null
  }

  export type diagnosticoWhereInput = {
    AND?: diagnosticoWhereInput | diagnosticoWhereInput[]
    OR?: diagnosticoWhereInput[]
    NOT?: diagnosticoWhereInput | diagnosticoWhereInput[]
    nro?: BigIntFilter<"diagnostico"> | bigint | number
    fecha?: DateTimeFilter<"diagnostico"> | Date | string
    hora?: DateTimeFilter<"diagnostico"> | Date | string
    placa_moto?: StringFilter<"diagnostico"> | string
    empleado_ci?: IntFilter<"diagnostico"> | number
    detalle_diagnostico?: Detalle_diagnosticoListRelationFilter
    empleado?: XOR<EmpleadoScalarRelationFilter, empleadoWhereInput>
    moto?: XOR<MotoScalarRelationFilter, motoWhereInput>
    proforma?: XOR<ProformaNullableScalarRelationFilter, proformaWhereInput> | null
  }

  export type diagnosticoOrderByWithRelationInput = {
    nro?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    placa_moto?: SortOrder
    empleado_ci?: SortOrder
    detalle_diagnostico?: detalle_diagnosticoOrderByRelationAggregateInput
    empleado?: empleadoOrderByWithRelationInput
    moto?: motoOrderByWithRelationInput
    proforma?: proformaOrderByWithRelationInput
  }

  export type diagnosticoWhereUniqueInput = Prisma.AtLeast<{
    nro?: bigint | number
    placa_moto_fecha_hora?: diagnosticoPlaca_motoFechaHoraCompoundUniqueInput
    AND?: diagnosticoWhereInput | diagnosticoWhereInput[]
    OR?: diagnosticoWhereInput[]
    NOT?: diagnosticoWhereInput | diagnosticoWhereInput[]
    fecha?: DateTimeFilter<"diagnostico"> | Date | string
    hora?: DateTimeFilter<"diagnostico"> | Date | string
    placa_moto?: StringFilter<"diagnostico"> | string
    empleado_ci?: IntFilter<"diagnostico"> | number
    detalle_diagnostico?: Detalle_diagnosticoListRelationFilter
    empleado?: XOR<EmpleadoScalarRelationFilter, empleadoWhereInput>
    moto?: XOR<MotoScalarRelationFilter, motoWhereInput>
    proforma?: XOR<ProformaNullableScalarRelationFilter, proformaWhereInput> | null
  }, "nro" | "placa_moto_fecha_hora">

  export type diagnosticoOrderByWithAggregationInput = {
    nro?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    placa_moto?: SortOrder
    empleado_ci?: SortOrder
    _count?: diagnosticoCountOrderByAggregateInput
    _avg?: diagnosticoAvgOrderByAggregateInput
    _max?: diagnosticoMaxOrderByAggregateInput
    _min?: diagnosticoMinOrderByAggregateInput
    _sum?: diagnosticoSumOrderByAggregateInput
  }

  export type diagnosticoScalarWhereWithAggregatesInput = {
    AND?: diagnosticoScalarWhereWithAggregatesInput | diagnosticoScalarWhereWithAggregatesInput[]
    OR?: diagnosticoScalarWhereWithAggregatesInput[]
    NOT?: diagnosticoScalarWhereWithAggregatesInput | diagnosticoScalarWhereWithAggregatesInput[]
    nro?: BigIntWithAggregatesFilter<"diagnostico"> | bigint | number
    fecha?: DateTimeWithAggregatesFilter<"diagnostico"> | Date | string
    hora?: DateTimeWithAggregatesFilter<"diagnostico"> | Date | string
    placa_moto?: StringWithAggregatesFilter<"diagnostico"> | string
    empleado_ci?: IntWithAggregatesFilter<"diagnostico"> | number
  }

  export type empleadoWhereInput = {
    AND?: empleadoWhereInput | empleadoWhereInput[]
    OR?: empleadoWhereInput[]
    NOT?: empleadoWhereInput | empleadoWhereInput[]
    ci?: IntFilter<"empleado"> | number
    nombre?: StringFilter<"empleado"> | string
    fechanac?: DateTimeFilter<"empleado"> | Date | string
    direccion?: StringFilter<"empleado"> | string
    telefono?: IntFilter<"empleado"> | number
    diagnostico?: DiagnosticoListRelationFilter
    horario_empleado?: Horario_empleadoListRelationFilter
    orden_trabajo?: Orden_trabajoListRelationFilter
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
  }

  export type empleadoOrderByWithRelationInput = {
    ci?: SortOrder
    nombre?: SortOrder
    fechanac?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    diagnostico?: diagnosticoOrderByRelationAggregateInput
    horario_empleado?: horario_empleadoOrderByRelationAggregateInput
    orden_trabajo?: orden_trabajoOrderByRelationAggregateInput
    usuario?: usuarioOrderByWithRelationInput
  }

  export type empleadoWhereUniqueInput = Prisma.AtLeast<{
    ci?: number
    AND?: empleadoWhereInput | empleadoWhereInput[]
    OR?: empleadoWhereInput[]
    NOT?: empleadoWhereInput | empleadoWhereInput[]
    nombre?: StringFilter<"empleado"> | string
    fechanac?: DateTimeFilter<"empleado"> | Date | string
    direccion?: StringFilter<"empleado"> | string
    telefono?: IntFilter<"empleado"> | number
    diagnostico?: DiagnosticoListRelationFilter
    horario_empleado?: Horario_empleadoListRelationFilter
    orden_trabajo?: Orden_trabajoListRelationFilter
    usuario?: XOR<UsuarioNullableScalarRelationFilter, usuarioWhereInput> | null
  }, "ci">

  export type empleadoOrderByWithAggregationInput = {
    ci?: SortOrder
    nombre?: SortOrder
    fechanac?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    _count?: empleadoCountOrderByAggregateInput
    _avg?: empleadoAvgOrderByAggregateInput
    _max?: empleadoMaxOrderByAggregateInput
    _min?: empleadoMinOrderByAggregateInput
    _sum?: empleadoSumOrderByAggregateInput
  }

  export type empleadoScalarWhereWithAggregatesInput = {
    AND?: empleadoScalarWhereWithAggregatesInput | empleadoScalarWhereWithAggregatesInput[]
    OR?: empleadoScalarWhereWithAggregatesInput[]
    NOT?: empleadoScalarWhereWithAggregatesInput | empleadoScalarWhereWithAggregatesInput[]
    ci?: IntWithAggregatesFilter<"empleado"> | number
    nombre?: StringWithAggregatesFilter<"empleado"> | string
    fechanac?: DateTimeWithAggregatesFilter<"empleado"> | Date | string
    direccion?: StringWithAggregatesFilter<"empleado"> | string
    telefono?: IntWithAggregatesFilter<"empleado"> | number
  }

  export type facturaWhereInput = {
    AND?: facturaWhereInput | facturaWhereInput[]
    OR?: facturaWhereInput[]
    NOT?: facturaWhereInput | facturaWhereInput[]
    id?: BigIntFilter<"factura"> | bigint | number
    monto?: DecimalFilter<"factura"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"factura"> | Date | string
    cliente_ci?: IntFilter<"factura"> | number
    cliente?: XOR<ClienteScalarRelationFilter, clienteWhereInput>
  }

  export type facturaOrderByWithRelationInput = {
    id?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    cliente_ci?: SortOrder
    cliente?: clienteOrderByWithRelationInput
  }

  export type facturaWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: facturaWhereInput | facturaWhereInput[]
    OR?: facturaWhereInput[]
    NOT?: facturaWhereInput | facturaWhereInput[]
    monto?: DecimalFilter<"factura"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"factura"> | Date | string
    cliente_ci?: IntFilter<"factura"> | number
    cliente?: XOR<ClienteScalarRelationFilter, clienteWhereInput>
  }, "id">

  export type facturaOrderByWithAggregationInput = {
    id?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    cliente_ci?: SortOrder
    _count?: facturaCountOrderByAggregateInput
    _avg?: facturaAvgOrderByAggregateInput
    _max?: facturaMaxOrderByAggregateInput
    _min?: facturaMinOrderByAggregateInput
    _sum?: facturaSumOrderByAggregateInput
  }

  export type facturaScalarWhereWithAggregatesInput = {
    AND?: facturaScalarWhereWithAggregatesInput | facturaScalarWhereWithAggregatesInput[]
    OR?: facturaScalarWhereWithAggregatesInput[]
    NOT?: facturaScalarWhereWithAggregatesInput | facturaScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"factura"> | bigint | number
    monto?: DecimalWithAggregatesFilter<"factura"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeWithAggregatesFilter<"factura"> | Date | string
    cliente_ci?: IntWithAggregatesFilter<"factura"> | number
  }

  export type herramientaWhereInput = {
    AND?: herramientaWhereInput | herramientaWhereInput[]
    OR?: herramientaWhereInput[]
    NOT?: herramientaWhereInput | herramientaWhereInput[]
    id?: IntFilter<"herramienta"> | number
    nombre?: StringFilter<"herramienta"> | string
    descripcion?: StringNullableFilter<"herramienta"> | string | null
    marca_id?: IntFilter<"herramienta"> | number
    marca_herramienta?: XOR<Marca_herramientaScalarRelationFilter, marca_herramientaWhereInput>
    movimiento_herramienta?: Movimiento_herramientaListRelationFilter
  }

  export type herramientaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    marca_id?: SortOrder
    marca_herramienta?: marca_herramientaOrderByWithRelationInput
    movimiento_herramienta?: movimiento_herramientaOrderByRelationAggregateInput
  }

  export type herramientaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: herramientaWhereInput | herramientaWhereInput[]
    OR?: herramientaWhereInput[]
    NOT?: herramientaWhereInput | herramientaWhereInput[]
    nombre?: StringFilter<"herramienta"> | string
    descripcion?: StringNullableFilter<"herramienta"> | string | null
    marca_id?: IntFilter<"herramienta"> | number
    marca_herramienta?: XOR<Marca_herramientaScalarRelationFilter, marca_herramientaWhereInput>
    movimiento_herramienta?: Movimiento_herramientaListRelationFilter
  }, "id">

  export type herramientaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    marca_id?: SortOrder
    _count?: herramientaCountOrderByAggregateInput
    _avg?: herramientaAvgOrderByAggregateInput
    _max?: herramientaMaxOrderByAggregateInput
    _min?: herramientaMinOrderByAggregateInput
    _sum?: herramientaSumOrderByAggregateInput
  }

  export type herramientaScalarWhereWithAggregatesInput = {
    AND?: herramientaScalarWhereWithAggregatesInput | herramientaScalarWhereWithAggregatesInput[]
    OR?: herramientaScalarWhereWithAggregatesInput[]
    NOT?: herramientaScalarWhereWithAggregatesInput | herramientaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"herramienta"> | number
    nombre?: StringWithAggregatesFilter<"herramienta"> | string
    descripcion?: StringNullableWithAggregatesFilter<"herramienta"> | string | null
    marca_id?: IntWithAggregatesFilter<"herramienta"> | number
  }

  export type horarioWhereInput = {
    AND?: horarioWhereInput | horarioWhereInput[]
    OR?: horarioWhereInput[]
    NOT?: horarioWhereInput | horarioWhereInput[]
    id?: IntFilter<"horario"> | number
    hora_inicio?: DateTimeFilter<"horario"> | Date | string
    hora_fin?: DateTimeFilter<"horario"> | Date | string
    horario_empleado?: Horario_empleadoListRelationFilter
  }

  export type horarioOrderByWithRelationInput = {
    id?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    horario_empleado?: horario_empleadoOrderByRelationAggregateInput
  }

  export type horarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: horarioWhereInput | horarioWhereInput[]
    OR?: horarioWhereInput[]
    NOT?: horarioWhereInput | horarioWhereInput[]
    hora_inicio?: DateTimeFilter<"horario"> | Date | string
    hora_fin?: DateTimeFilter<"horario"> | Date | string
    horario_empleado?: Horario_empleadoListRelationFilter
  }, "id">

  export type horarioOrderByWithAggregationInput = {
    id?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    _count?: horarioCountOrderByAggregateInput
    _avg?: horarioAvgOrderByAggregateInput
    _max?: horarioMaxOrderByAggregateInput
    _min?: horarioMinOrderByAggregateInput
    _sum?: horarioSumOrderByAggregateInput
  }

  export type horarioScalarWhereWithAggregatesInput = {
    AND?: horarioScalarWhereWithAggregatesInput | horarioScalarWhereWithAggregatesInput[]
    OR?: horarioScalarWhereWithAggregatesInput[]
    NOT?: horarioScalarWhereWithAggregatesInput | horarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"horario"> | number
    hora_inicio?: DateTimeWithAggregatesFilter<"horario"> | Date | string
    hora_fin?: DateTimeWithAggregatesFilter<"horario"> | Date | string
  }

  export type horario_empleadoWhereInput = {
    AND?: horario_empleadoWhereInput | horario_empleadoWhereInput[]
    OR?: horario_empleadoWhereInput[]
    NOT?: horario_empleadoWhereInput | horario_empleadoWhereInput[]
    empleado_ci?: IntFilter<"horario_empleado"> | number
    horario_id?: IntFilter<"horario_empleado"> | number
    fecha?: DateTimeFilter<"horario_empleado"> | Date | string
    empleado?: XOR<EmpleadoScalarRelationFilter, empleadoWhereInput>
    horario?: XOR<HorarioScalarRelationFilter, horarioWhereInput>
  }

  export type horario_empleadoOrderByWithRelationInput = {
    empleado_ci?: SortOrder
    horario_id?: SortOrder
    fecha?: SortOrder
    empleado?: empleadoOrderByWithRelationInput
    horario?: horarioOrderByWithRelationInput
  }

  export type horario_empleadoWhereUniqueInput = Prisma.AtLeast<{
    empleado_ci_horario_id?: horario_empleadoEmpleado_ciHorario_idCompoundUniqueInput
    AND?: horario_empleadoWhereInput | horario_empleadoWhereInput[]
    OR?: horario_empleadoWhereInput[]
    NOT?: horario_empleadoWhereInput | horario_empleadoWhereInput[]
    empleado_ci?: IntFilter<"horario_empleado"> | number
    horario_id?: IntFilter<"horario_empleado"> | number
    fecha?: DateTimeFilter<"horario_empleado"> | Date | string
    empleado?: XOR<EmpleadoScalarRelationFilter, empleadoWhereInput>
    horario?: XOR<HorarioScalarRelationFilter, horarioWhereInput>
  }, "empleado_ci_horario_id">

  export type horario_empleadoOrderByWithAggregationInput = {
    empleado_ci?: SortOrder
    horario_id?: SortOrder
    fecha?: SortOrder
    _count?: horario_empleadoCountOrderByAggregateInput
    _avg?: horario_empleadoAvgOrderByAggregateInput
    _max?: horario_empleadoMaxOrderByAggregateInput
    _min?: horario_empleadoMinOrderByAggregateInput
    _sum?: horario_empleadoSumOrderByAggregateInput
  }

  export type horario_empleadoScalarWhereWithAggregatesInput = {
    AND?: horario_empleadoScalarWhereWithAggregatesInput | horario_empleadoScalarWhereWithAggregatesInput[]
    OR?: horario_empleadoScalarWhereWithAggregatesInput[]
    NOT?: horario_empleadoScalarWhereWithAggregatesInput | horario_empleadoScalarWhereWithAggregatesInput[]
    empleado_ci?: IntWithAggregatesFilter<"horario_empleado"> | number
    horario_id?: IntWithAggregatesFilter<"horario_empleado"> | number
    fecha?: DateTimeWithAggregatesFilter<"horario_empleado"> | Date | string
  }

  export type marca_herramientaWhereInput = {
    AND?: marca_herramientaWhereInput | marca_herramientaWhereInput[]
    OR?: marca_herramientaWhereInput[]
    NOT?: marca_herramientaWhereInput | marca_herramientaWhereInput[]
    id?: IntFilter<"marca_herramienta"> | number
    nombre?: StringFilter<"marca_herramienta"> | string
    herramienta?: HerramientaListRelationFilter
  }

  export type marca_herramientaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    herramienta?: herramientaOrderByRelationAggregateInput
  }

  export type marca_herramientaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: marca_herramientaWhereInput | marca_herramientaWhereInput[]
    OR?: marca_herramientaWhereInput[]
    NOT?: marca_herramientaWhereInput | marca_herramientaWhereInput[]
    nombre?: StringFilter<"marca_herramienta"> | string
    herramienta?: HerramientaListRelationFilter
  }, "id">

  export type marca_herramientaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: marca_herramientaCountOrderByAggregateInput
    _avg?: marca_herramientaAvgOrderByAggregateInput
    _max?: marca_herramientaMaxOrderByAggregateInput
    _min?: marca_herramientaMinOrderByAggregateInput
    _sum?: marca_herramientaSumOrderByAggregateInput
  }

  export type marca_herramientaScalarWhereWithAggregatesInput = {
    AND?: marca_herramientaScalarWhereWithAggregatesInput | marca_herramientaScalarWhereWithAggregatesInput[]
    OR?: marca_herramientaScalarWhereWithAggregatesInput[]
    NOT?: marca_herramientaScalarWhereWithAggregatesInput | marca_herramientaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"marca_herramienta"> | number
    nombre?: StringWithAggregatesFilter<"marca_herramienta"> | string
  }

  export type marca_motoWhereInput = {
    AND?: marca_motoWhereInput | marca_motoWhereInput[]
    OR?: marca_motoWhereInput[]
    NOT?: marca_motoWhereInput | marca_motoWhereInput[]
    id?: IntFilter<"marca_moto"> | number
    nombre?: StringFilter<"marca_moto"> | string
    moto?: MotoListRelationFilter
  }

  export type marca_motoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    moto?: motoOrderByRelationAggregateInput
  }

  export type marca_motoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: marca_motoWhereInput | marca_motoWhereInput[]
    OR?: marca_motoWhereInput[]
    NOT?: marca_motoWhereInput | marca_motoWhereInput[]
    nombre?: StringFilter<"marca_moto"> | string
    moto?: MotoListRelationFilter
  }, "id">

  export type marca_motoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: marca_motoCountOrderByAggregateInput
    _avg?: marca_motoAvgOrderByAggregateInput
    _max?: marca_motoMaxOrderByAggregateInput
    _min?: marca_motoMinOrderByAggregateInput
    _sum?: marca_motoSumOrderByAggregateInput
  }

  export type marca_motoScalarWhereWithAggregatesInput = {
    AND?: marca_motoScalarWhereWithAggregatesInput | marca_motoScalarWhereWithAggregatesInput[]
    OR?: marca_motoScalarWhereWithAggregatesInput[]
    NOT?: marca_motoScalarWhereWithAggregatesInput | marca_motoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"marca_moto"> | number
    nombre?: StringWithAggregatesFilter<"marca_moto"> | string
  }

  export type motoWhereInput = {
    AND?: motoWhereInput | motoWhereInput[]
    OR?: motoWhereInput[]
    NOT?: motoWhereInput | motoWhereInput[]
    placa?: StringFilter<"moto"> | string
    modelo?: StringFilter<"moto"> | string
    year?: IntFilter<"moto"> | number
    chasis?: StringNullableFilter<"moto"> | string | null
    marca_id?: IntFilter<"moto"> | number
    diagnostico?: DiagnosticoListRelationFilter
    marca_moto?: XOR<Marca_motoScalarRelationFilter, marca_motoWhereInput>
  }

  export type motoOrderByWithRelationInput = {
    placa?: SortOrder
    modelo?: SortOrder
    year?: SortOrder
    chasis?: SortOrderInput | SortOrder
    marca_id?: SortOrder
    diagnostico?: diagnosticoOrderByRelationAggregateInput
    marca_moto?: marca_motoOrderByWithRelationInput
  }

  export type motoWhereUniqueInput = Prisma.AtLeast<{
    placa?: string
    chasis?: string
    AND?: motoWhereInput | motoWhereInput[]
    OR?: motoWhereInput[]
    NOT?: motoWhereInput | motoWhereInput[]
    modelo?: StringFilter<"moto"> | string
    year?: IntFilter<"moto"> | number
    marca_id?: IntFilter<"moto"> | number
    diagnostico?: DiagnosticoListRelationFilter
    marca_moto?: XOR<Marca_motoScalarRelationFilter, marca_motoWhereInput>
  }, "placa" | "chasis">

  export type motoOrderByWithAggregationInput = {
    placa?: SortOrder
    modelo?: SortOrder
    year?: SortOrder
    chasis?: SortOrderInput | SortOrder
    marca_id?: SortOrder
    _count?: motoCountOrderByAggregateInput
    _avg?: motoAvgOrderByAggregateInput
    _max?: motoMaxOrderByAggregateInput
    _min?: motoMinOrderByAggregateInput
    _sum?: motoSumOrderByAggregateInput
  }

  export type motoScalarWhereWithAggregatesInput = {
    AND?: motoScalarWhereWithAggregatesInput | motoScalarWhereWithAggregatesInput[]
    OR?: motoScalarWhereWithAggregatesInput[]
    NOT?: motoScalarWhereWithAggregatesInput | motoScalarWhereWithAggregatesInput[]
    placa?: StringWithAggregatesFilter<"moto"> | string
    modelo?: StringWithAggregatesFilter<"moto"> | string
    year?: IntWithAggregatesFilter<"moto"> | number
    chasis?: StringNullableWithAggregatesFilter<"moto"> | string | null
    marca_id?: IntWithAggregatesFilter<"moto"> | number
  }

  export type movimiento_herramientaWhereInput = {
    AND?: movimiento_herramientaWhereInput | movimiento_herramientaWhereInput[]
    OR?: movimiento_herramientaWhereInput[]
    NOT?: movimiento_herramientaWhereInput | movimiento_herramientaWhereInput[]
    herramienta_id?: IntFilter<"movimiento_herramienta"> | number
    orden_trabajo_id?: BigIntFilter<"movimiento_herramienta"> | bigint | number
    fecha?: DateTimeFilter<"movimiento_herramienta"> | Date | string
    cantidad?: IntFilter<"movimiento_herramienta"> | number
    herramienta?: XOR<HerramientaScalarRelationFilter, herramientaWhereInput>
    orden_trabajo?: XOR<Orden_trabajoScalarRelationFilter, orden_trabajoWhereInput>
  }

  export type movimiento_herramientaOrderByWithRelationInput = {
    herramienta_id?: SortOrder
    orden_trabajo_id?: SortOrder
    fecha?: SortOrder
    cantidad?: SortOrder
    herramienta?: herramientaOrderByWithRelationInput
    orden_trabajo?: orden_trabajoOrderByWithRelationInput
  }

  export type movimiento_herramientaWhereUniqueInput = Prisma.AtLeast<{
    orden_trabajo_id_herramienta_id?: movimiento_herramientaOrden_trabajo_idHerramienta_idCompoundUniqueInput
    AND?: movimiento_herramientaWhereInput | movimiento_herramientaWhereInput[]
    OR?: movimiento_herramientaWhereInput[]
    NOT?: movimiento_herramientaWhereInput | movimiento_herramientaWhereInput[]
    herramienta_id?: IntFilter<"movimiento_herramienta"> | number
    orden_trabajo_id?: BigIntFilter<"movimiento_herramienta"> | bigint | number
    fecha?: DateTimeFilter<"movimiento_herramienta"> | Date | string
    cantidad?: IntFilter<"movimiento_herramienta"> | number
    herramienta?: XOR<HerramientaScalarRelationFilter, herramientaWhereInput>
    orden_trabajo?: XOR<Orden_trabajoScalarRelationFilter, orden_trabajoWhereInput>
  }, "orden_trabajo_id_herramienta_id">

  export type movimiento_herramientaOrderByWithAggregationInput = {
    herramienta_id?: SortOrder
    orden_trabajo_id?: SortOrder
    fecha?: SortOrder
    cantidad?: SortOrder
    _count?: movimiento_herramientaCountOrderByAggregateInput
    _avg?: movimiento_herramientaAvgOrderByAggregateInput
    _max?: movimiento_herramientaMaxOrderByAggregateInput
    _min?: movimiento_herramientaMinOrderByAggregateInput
    _sum?: movimiento_herramientaSumOrderByAggregateInput
  }

  export type movimiento_herramientaScalarWhereWithAggregatesInput = {
    AND?: movimiento_herramientaScalarWhereWithAggregatesInput | movimiento_herramientaScalarWhereWithAggregatesInput[]
    OR?: movimiento_herramientaScalarWhereWithAggregatesInput[]
    NOT?: movimiento_herramientaScalarWhereWithAggregatesInput | movimiento_herramientaScalarWhereWithAggregatesInput[]
    herramienta_id?: IntWithAggregatesFilter<"movimiento_herramienta"> | number
    orden_trabajo_id?: BigIntWithAggregatesFilter<"movimiento_herramienta"> | bigint | number
    fecha?: DateTimeWithAggregatesFilter<"movimiento_herramienta"> | Date | string
    cantidad?: IntWithAggregatesFilter<"movimiento_herramienta"> | number
  }

  export type orden_trabajoWhereInput = {
    AND?: orden_trabajoWhereInput | orden_trabajoWhereInput[]
    OR?: orden_trabajoWhereInput[]
    NOT?: orden_trabajoWhereInput | orden_trabajoWhereInput[]
    id?: BigIntFilter<"orden_trabajo"> | bigint | number
    fecha_inicio?: DateTimeFilter<"orden_trabajo"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"orden_trabajo"> | Date | string | null
    estado?: Enumestado_ordenFilter<"orden_trabajo"> | $Enums.estado_orden
    empleado_ci?: IntFilter<"orden_trabajo"> | number
    administrador_id?: IntNullableFilter<"orden_trabajo"> | number | null
    servicio_id?: IntFilter<"orden_trabajo"> | number
    comision?: XOR<ComisionNullableScalarRelationFilter, comisionWhereInput> | null
    movimiento_herramienta?: Movimiento_herramientaListRelationFilter
    administrador?: XOR<AdministradorNullableScalarRelationFilter, administradorWhereInput> | null
    empleado?: XOR<EmpleadoScalarRelationFilter, empleadoWhereInput>
    servicio?: XOR<ServicioScalarRelationFilter, servicioWhereInput>
  }

  export type orden_trabajoOrderByWithRelationInput = {
    id?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    estado?: SortOrder
    empleado_ci?: SortOrder
    administrador_id?: SortOrderInput | SortOrder
    servicio_id?: SortOrder
    comision?: comisionOrderByWithRelationInput
    movimiento_herramienta?: movimiento_herramientaOrderByRelationAggregateInput
    administrador?: administradorOrderByWithRelationInput
    empleado?: empleadoOrderByWithRelationInput
    servicio?: servicioOrderByWithRelationInput
  }

  export type orden_trabajoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: orden_trabajoWhereInput | orden_trabajoWhereInput[]
    OR?: orden_trabajoWhereInput[]
    NOT?: orden_trabajoWhereInput | orden_trabajoWhereInput[]
    fecha_inicio?: DateTimeFilter<"orden_trabajo"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"orden_trabajo"> | Date | string | null
    estado?: Enumestado_ordenFilter<"orden_trabajo"> | $Enums.estado_orden
    empleado_ci?: IntFilter<"orden_trabajo"> | number
    administrador_id?: IntNullableFilter<"orden_trabajo"> | number | null
    servicio_id?: IntFilter<"orden_trabajo"> | number
    comision?: XOR<ComisionNullableScalarRelationFilter, comisionWhereInput> | null
    movimiento_herramienta?: Movimiento_herramientaListRelationFilter
    administrador?: XOR<AdministradorNullableScalarRelationFilter, administradorWhereInput> | null
    empleado?: XOR<EmpleadoScalarRelationFilter, empleadoWhereInput>
    servicio?: XOR<ServicioScalarRelationFilter, servicioWhereInput>
  }, "id">

  export type orden_trabajoOrderByWithAggregationInput = {
    id?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    estado?: SortOrder
    empleado_ci?: SortOrder
    administrador_id?: SortOrderInput | SortOrder
    servicio_id?: SortOrder
    _count?: orden_trabajoCountOrderByAggregateInput
    _avg?: orden_trabajoAvgOrderByAggregateInput
    _max?: orden_trabajoMaxOrderByAggregateInput
    _min?: orden_trabajoMinOrderByAggregateInput
    _sum?: orden_trabajoSumOrderByAggregateInput
  }

  export type orden_trabajoScalarWhereWithAggregatesInput = {
    AND?: orden_trabajoScalarWhereWithAggregatesInput | orden_trabajoScalarWhereWithAggregatesInput[]
    OR?: orden_trabajoScalarWhereWithAggregatesInput[]
    NOT?: orden_trabajoScalarWhereWithAggregatesInput | orden_trabajoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"orden_trabajo"> | bigint | number
    fecha_inicio?: DateTimeWithAggregatesFilter<"orden_trabajo"> | Date | string
    fecha_fin?: DateTimeNullableWithAggregatesFilter<"orden_trabajo"> | Date | string | null
    estado?: Enumestado_ordenWithAggregatesFilter<"orden_trabajo"> | $Enums.estado_orden
    empleado_ci?: IntWithAggregatesFilter<"orden_trabajo"> | number
    administrador_id?: IntNullableWithAggregatesFilter<"orden_trabajo"> | number | null
    servicio_id?: IntWithAggregatesFilter<"orden_trabajo"> | number
  }

  export type proformaWhereInput = {
    AND?: proformaWhereInput | proformaWhereInput[]
    OR?: proformaWhereInput[]
    NOT?: proformaWhereInput | proformaWhereInput[]
    id?: BigIntFilter<"proforma"> | bigint | number
    fecha?: DateTimeFilter<"proforma"> | Date | string
    estado?: Enumestado_proformaFilter<"proforma"> | $Enums.estado_proforma
    total?: DecimalFilter<"proforma"> | Decimal | DecimalJsLike | number | string
    cliente_ci?: IntFilter<"proforma"> | number
    diagnostico_id?: BigIntNullableFilter<"proforma"> | bigint | number | null
    detalle_proforma?: Detalle_proformaListRelationFilter
    cliente?: XOR<ClienteScalarRelationFilter, clienteWhereInput>
    diagnostico?: XOR<DiagnosticoNullableScalarRelationFilter, diagnosticoWhereInput> | null
    proforma_repuesto?: Proforma_repuestoListRelationFilter
  }

  export type proformaOrderByWithRelationInput = {
    id?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    total?: SortOrder
    cliente_ci?: SortOrder
    diagnostico_id?: SortOrderInput | SortOrder
    detalle_proforma?: detalle_proformaOrderByRelationAggregateInput
    cliente?: clienteOrderByWithRelationInput
    diagnostico?: diagnosticoOrderByWithRelationInput
    proforma_repuesto?: proforma_repuestoOrderByRelationAggregateInput
  }

  export type proformaWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    diagnostico_id?: bigint | number
    AND?: proformaWhereInput | proformaWhereInput[]
    OR?: proformaWhereInput[]
    NOT?: proformaWhereInput | proformaWhereInput[]
    fecha?: DateTimeFilter<"proforma"> | Date | string
    estado?: Enumestado_proformaFilter<"proforma"> | $Enums.estado_proforma
    total?: DecimalFilter<"proforma"> | Decimal | DecimalJsLike | number | string
    cliente_ci?: IntFilter<"proforma"> | number
    detalle_proforma?: Detalle_proformaListRelationFilter
    cliente?: XOR<ClienteScalarRelationFilter, clienteWhereInput>
    diagnostico?: XOR<DiagnosticoNullableScalarRelationFilter, diagnosticoWhereInput> | null
    proforma_repuesto?: Proforma_repuestoListRelationFilter
  }, "id" | "diagnostico_id">

  export type proformaOrderByWithAggregationInput = {
    id?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    total?: SortOrder
    cliente_ci?: SortOrder
    diagnostico_id?: SortOrderInput | SortOrder
    _count?: proformaCountOrderByAggregateInput
    _avg?: proformaAvgOrderByAggregateInput
    _max?: proformaMaxOrderByAggregateInput
    _min?: proformaMinOrderByAggregateInput
    _sum?: proformaSumOrderByAggregateInput
  }

  export type proformaScalarWhereWithAggregatesInput = {
    AND?: proformaScalarWhereWithAggregatesInput | proformaScalarWhereWithAggregatesInput[]
    OR?: proformaScalarWhereWithAggregatesInput[]
    NOT?: proformaScalarWhereWithAggregatesInput | proformaScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"proforma"> | bigint | number
    fecha?: DateTimeWithAggregatesFilter<"proforma"> | Date | string
    estado?: Enumestado_proformaWithAggregatesFilter<"proforma"> | $Enums.estado_proforma
    total?: DecimalWithAggregatesFilter<"proforma"> | Decimal | DecimalJsLike | number | string
    cliente_ci?: IntWithAggregatesFilter<"proforma"> | number
    diagnostico_id?: BigIntNullableWithAggregatesFilter<"proforma"> | bigint | number | null
  }

  export type proforma_repuestoWhereInput = {
    AND?: proforma_repuestoWhereInput | proforma_repuestoWhereInput[]
    OR?: proforma_repuestoWhereInput[]
    NOT?: proforma_repuestoWhereInput | proforma_repuestoWhereInput[]
    id?: IntFilter<"proforma_repuesto"> | number
    nombre?: StringFilter<"proforma_repuesto"> | string
    proforma_id?: BigIntFilter<"proforma_repuesto"> | bigint | number
    proforma?: XOR<ProformaScalarRelationFilter, proformaWhereInput>
  }

  export type proforma_repuestoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    proforma_id?: SortOrder
    proforma?: proformaOrderByWithRelationInput
  }

  export type proforma_repuestoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: proforma_repuestoWhereInput | proforma_repuestoWhereInput[]
    OR?: proforma_repuestoWhereInput[]
    NOT?: proforma_repuestoWhereInput | proforma_repuestoWhereInput[]
    nombre?: StringFilter<"proforma_repuesto"> | string
    proforma_id?: BigIntFilter<"proforma_repuesto"> | bigint | number
    proforma?: XOR<ProformaScalarRelationFilter, proformaWhereInput>
  }, "id">

  export type proforma_repuestoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    proforma_id?: SortOrder
    _count?: proforma_repuestoCountOrderByAggregateInput
    _avg?: proforma_repuestoAvgOrderByAggregateInput
    _max?: proforma_repuestoMaxOrderByAggregateInput
    _min?: proforma_repuestoMinOrderByAggregateInput
    _sum?: proforma_repuestoSumOrderByAggregateInput
  }

  export type proforma_repuestoScalarWhereWithAggregatesInput = {
    AND?: proforma_repuestoScalarWhereWithAggregatesInput | proforma_repuestoScalarWhereWithAggregatesInput[]
    OR?: proforma_repuestoScalarWhereWithAggregatesInput[]
    NOT?: proforma_repuestoScalarWhereWithAggregatesInput | proforma_repuestoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"proforma_repuesto"> | number
    nombre?: StringWithAggregatesFilter<"proforma_repuesto"> | string
    proforma_id?: BigIntWithAggregatesFilter<"proforma_repuesto"> | bigint | number
  }

  export type servicioWhereInput = {
    AND?: servicioWhereInput | servicioWhereInput[]
    OR?: servicioWhereInput[]
    NOT?: servicioWhereInput | servicioWhereInput[]
    id?: IntFilter<"servicio"> | number
    descripcion?: StringFilter<"servicio"> | string
    categoria_id?: IntFilter<"servicio"> | number
    detalle_proforma?: Detalle_proformaListRelationFilter
    orden_trabajo?: Orden_trabajoListRelationFilter
    categoria?: XOR<CategoriaScalarRelationFilter, categoriaWhereInput>
  }

  export type servicioOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    categoria_id?: SortOrder
    detalle_proforma?: detalle_proformaOrderByRelationAggregateInput
    orden_trabajo?: orden_trabajoOrderByRelationAggregateInput
    categoria?: categoriaOrderByWithRelationInput
  }

  export type servicioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: servicioWhereInput | servicioWhereInput[]
    OR?: servicioWhereInput[]
    NOT?: servicioWhereInput | servicioWhereInput[]
    descripcion?: StringFilter<"servicio"> | string
    categoria_id?: IntFilter<"servicio"> | number
    detalle_proforma?: Detalle_proformaListRelationFilter
    orden_trabajo?: Orden_trabajoListRelationFilter
    categoria?: XOR<CategoriaScalarRelationFilter, categoriaWhereInput>
  }, "id">

  export type servicioOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    categoria_id?: SortOrder
    _count?: servicioCountOrderByAggregateInput
    _avg?: servicioAvgOrderByAggregateInput
    _max?: servicioMaxOrderByAggregateInput
    _min?: servicioMinOrderByAggregateInput
    _sum?: servicioSumOrderByAggregateInput
  }

  export type servicioScalarWhereWithAggregatesInput = {
    AND?: servicioScalarWhereWithAggregatesInput | servicioScalarWhereWithAggregatesInput[]
    OR?: servicioScalarWhereWithAggregatesInput[]
    NOT?: servicioScalarWhereWithAggregatesInput | servicioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"servicio"> | number
    descripcion?: StringWithAggregatesFilter<"servicio"> | string
    categoria_id?: IntWithAggregatesFilter<"servicio"> | number
  }

  export type usuarioWhereInput = {
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    id?: IntFilter<"usuario"> | number
    empleado_ci?: IntFilter<"usuario"> | number
    usuario?: StringFilter<"usuario"> | string
    contrasena?: StringFilter<"usuario"> | string
    email?: StringNullableFilter<"usuario"> | string | null
    administrador?: XOR<AdministradorNullableScalarRelationFilter, administradorWhereInput> | null
    empleado?: XOR<EmpleadoScalarRelationFilter, empleadoWhereInput>
  }

  export type usuarioOrderByWithRelationInput = {
    id?: SortOrder
    empleado_ci?: SortOrder
    usuario?: SortOrder
    contrasena?: SortOrder
    email?: SortOrderInput | SortOrder
    administrador?: administradorOrderByWithRelationInput
    empleado?: empleadoOrderByWithRelationInput
  }

  export type usuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    empleado_ci?: number
    usuario?: string
    email?: string
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    contrasena?: StringFilter<"usuario"> | string
    administrador?: XOR<AdministradorNullableScalarRelationFilter, administradorWhereInput> | null
    empleado?: XOR<EmpleadoScalarRelationFilter, empleadoWhereInput>
  }, "id" | "empleado_ci" | "usuario" | "email">

  export type usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    empleado_ci?: SortOrder
    usuario?: SortOrder
    contrasena?: SortOrder
    email?: SortOrderInput | SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    OR?: usuarioScalarWhereWithAggregatesInput[]
    NOT?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"usuario"> | number
    empleado_ci?: IntWithAggregatesFilter<"usuario"> | number
    usuario?: StringWithAggregatesFilter<"usuario"> | string
    contrasena?: StringWithAggregatesFilter<"usuario"> | string
    email?: StringNullableWithAggregatesFilter<"usuario"> | string | null
  }

  export type administradorCreateInput = {
    usuario: usuarioCreateNestedOneWithoutAdministradorInput
    orden_trabajo?: orden_trabajoCreateNestedManyWithoutAdministradorInput
  }

  export type administradorUncheckedCreateInput = {
    id?: number
    usuario_id: number
    orden_trabajo?: orden_trabajoUncheckedCreateNestedManyWithoutAdministradorInput
  }

  export type administradorUpdateInput = {
    usuario?: usuarioUpdateOneRequiredWithoutAdministradorNestedInput
    orden_trabajo?: orden_trabajoUpdateManyWithoutAdministradorNestedInput
  }

  export type administradorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    orden_trabajo?: orden_trabajoUncheckedUpdateManyWithoutAdministradorNestedInput
  }

  export type administradorCreateManyInput = {
    id?: number
    usuario_id: number
  }

  export type administradorUpdateManyMutationInput = {

  }

  export type administradorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type categoriaCreateInput = {
    nombre: string
    servicio?: servicioCreateNestedManyWithoutCategoriaInput
  }

  export type categoriaUncheckedCreateInput = {
    id?: number
    nombre: string
    servicio?: servicioUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type categoriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    servicio?: servicioUpdateManyWithoutCategoriaNestedInput
  }

  export type categoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    servicio?: servicioUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type categoriaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type categoriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type categoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type clienteCreateInput = {
    ci: number
    nombre: string
    telefono: string
    direccion: string
    factura?: facturaCreateNestedManyWithoutClienteInput
    proforma?: proformaCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateInput = {
    ci: number
    nombre: string
    telefono: string
    direccion: string
    factura?: facturaUncheckedCreateNestedManyWithoutClienteInput
    proforma?: proformaUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteUpdateInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    factura?: facturaUpdateManyWithoutClienteNestedInput
    proforma?: proformaUpdateManyWithoutClienteNestedInput
  }

  export type clienteUncheckedUpdateInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    factura?: facturaUncheckedUpdateManyWithoutClienteNestedInput
    proforma?: proformaUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type clienteCreateManyInput = {
    ci: number
    nombre: string
    telefono: string
    direccion: string
  }

  export type clienteUpdateManyMutationInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
  }

  export type clienteUncheckedUpdateManyInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
  }

  export type comisionCreateInput = {
    monto: Decimal | DecimalJsLike | number | string
    estado_pago?: $Enums.estado_pago
    fecha_pago?: Date | string | null
    orden_trabajo?: orden_trabajoCreateNestedOneWithoutComisionInput
  }

  export type comisionUncheckedCreateInput = {
    id?: number
    orden_id?: bigint | number | null
    monto: Decimal | DecimalJsLike | number | string
    estado_pago?: $Enums.estado_pago
    fecha_pago?: Date | string | null
  }

  export type comisionUpdateInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_pago?: Enumestado_pagoFieldUpdateOperationsInput | $Enums.estado_pago
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orden_trabajo?: orden_trabajoUpdateOneWithoutComisionNestedInput
  }

  export type comisionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orden_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_pago?: Enumestado_pagoFieldUpdateOperationsInput | $Enums.estado_pago
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type comisionCreateManyInput = {
    id?: number
    orden_id?: bigint | number | null
    monto: Decimal | DecimalJsLike | number | string
    estado_pago?: $Enums.estado_pago
    fecha_pago?: Date | string | null
  }

  export type comisionUpdateManyMutationInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_pago?: Enumestado_pagoFieldUpdateOperationsInput | $Enums.estado_pago
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type comisionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orden_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_pago?: Enumestado_pagoFieldUpdateOperationsInput | $Enums.estado_pago
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type detalle_diagnosticoCreateInput = {
    id?: bigint | number
    descripcion: string
    diagnostico: diagnosticoCreateNestedOneWithoutDetalle_diagnosticoInput
  }

  export type detalle_diagnosticoUncheckedCreateInput = {
    id?: bigint | number
    diagnostico_id: bigint | number
    descripcion: string
  }

  export type detalle_diagnosticoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
    diagnostico?: diagnosticoUpdateOneRequiredWithoutDetalle_diagnosticoNestedInput
  }

  export type detalle_diagnosticoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    diagnostico_id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type detalle_diagnosticoCreateManyInput = {
    id?: bigint | number
    diagnostico_id: bigint | number
    descripcion: string
  }

  export type detalle_diagnosticoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type detalle_diagnosticoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    diagnostico_id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type detalle_proformaCreateInput = {
    id?: bigint | number
    descripcion: string
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    proforma: proformaCreateNestedOneWithoutDetalle_proformaInput
    servicio?: servicioCreateNestedOneWithoutDetalle_proformaInput
  }

  export type detalle_proformaUncheckedCreateInput = {
    id?: bigint | number
    proforma_id: bigint | number
    servicio_id?: number | null
    descripcion: string
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_proformaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proforma?: proformaUpdateOneRequiredWithoutDetalle_proformaNestedInput
    servicio?: servicioUpdateOneWithoutDetalle_proformaNestedInput
  }

  export type detalle_proformaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    proforma_id?: BigIntFieldUpdateOperationsInput | bigint | number
    servicio_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_proformaCreateManyInput = {
    id?: bigint | number
    proforma_id: bigint | number
    servicio_id?: number | null
    descripcion: string
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_proformaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_proformaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    proforma_id?: BigIntFieldUpdateOperationsInput | bigint | number
    servicio_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type diagnosticoCreateInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    detalle_diagnostico?: detalle_diagnosticoCreateNestedManyWithoutDiagnosticoInput
    empleado: empleadoCreateNestedOneWithoutDiagnosticoInput
    moto: motoCreateNestedOneWithoutDiagnosticoInput
    proforma?: proformaCreateNestedOneWithoutDiagnosticoInput
  }

  export type diagnosticoUncheckedCreateInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    placa_moto: string
    empleado_ci: number
    detalle_diagnostico?: detalle_diagnosticoUncheckedCreateNestedManyWithoutDiagnosticoInput
    proforma?: proformaUncheckedCreateNestedOneWithoutDiagnosticoInput
  }

  export type diagnosticoUpdateInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    detalle_diagnostico?: detalle_diagnosticoUpdateManyWithoutDiagnosticoNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutDiagnosticoNestedInput
    moto?: motoUpdateOneRequiredWithoutDiagnosticoNestedInput
    proforma?: proformaUpdateOneWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    placa_moto?: StringFieldUpdateOperationsInput | string
    empleado_ci?: IntFieldUpdateOperationsInput | number
    detalle_diagnostico?: detalle_diagnosticoUncheckedUpdateManyWithoutDiagnosticoNestedInput
    proforma?: proformaUncheckedUpdateOneWithoutDiagnosticoNestedInput
  }

  export type diagnosticoCreateManyInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    placa_moto: string
    empleado_ci: number
  }

  export type diagnosticoUpdateManyMutationInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diagnosticoUncheckedUpdateManyInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    placa_moto?: StringFieldUpdateOperationsInput | string
    empleado_ci?: IntFieldUpdateOperationsInput | number
  }

  export type empleadoCreateInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
    diagnostico?: diagnosticoCreateNestedManyWithoutEmpleadoInput
    horario_empleado?: horario_empleadoCreateNestedManyWithoutEmpleadoInput
    orden_trabajo?: orden_trabajoCreateNestedManyWithoutEmpleadoInput
    usuario?: usuarioCreateNestedOneWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
    diagnostico?: diagnosticoUncheckedCreateNestedManyWithoutEmpleadoInput
    horario_empleado?: horario_empleadoUncheckedCreateNestedManyWithoutEmpleadoInput
    orden_trabajo?: orden_trabajoUncheckedCreateNestedManyWithoutEmpleadoInput
    usuario?: usuarioUncheckedCreateNestedOneWithoutEmpleadoInput
  }

  export type empleadoUpdateInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    diagnostico?: diagnosticoUpdateManyWithoutEmpleadoNestedInput
    horario_empleado?: horario_empleadoUpdateManyWithoutEmpleadoNestedInput
    orden_trabajo?: orden_trabajoUpdateManyWithoutEmpleadoNestedInput
    usuario?: usuarioUpdateOneWithoutEmpleadoNestedInput
  }

  export type empleadoUncheckedUpdateInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    diagnostico?: diagnosticoUncheckedUpdateManyWithoutEmpleadoNestedInput
    horario_empleado?: horario_empleadoUncheckedUpdateManyWithoutEmpleadoNestedInput
    orden_trabajo?: orden_trabajoUncheckedUpdateManyWithoutEmpleadoNestedInput
    usuario?: usuarioUncheckedUpdateOneWithoutEmpleadoNestedInput
  }

  export type empleadoCreateManyInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
  }

  export type empleadoUpdateManyMutationInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
  }

  export type empleadoUncheckedUpdateManyInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
  }

  export type facturaCreateInput = {
    id?: bigint | number
    monto: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    cliente: clienteCreateNestedOneWithoutFacturaInput
  }

  export type facturaUncheckedCreateInput = {
    id?: bigint | number
    monto: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    cliente_ci: number
  }

  export type facturaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: clienteUpdateOneRequiredWithoutFacturaNestedInput
  }

  export type facturaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente_ci?: IntFieldUpdateOperationsInput | number
  }

  export type facturaCreateManyInput = {
    id?: bigint | number
    monto: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
    cliente_ci: number
  }

  export type facturaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type facturaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente_ci?: IntFieldUpdateOperationsInput | number
  }

  export type herramientaCreateInput = {
    nombre: string
    descripcion?: string | null
    marca_herramienta: marca_herramientaCreateNestedOneWithoutHerramientaInput
    movimiento_herramienta?: movimiento_herramientaCreateNestedManyWithoutHerramientaInput
  }

  export type herramientaUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    marca_id: number
    movimiento_herramienta?: movimiento_herramientaUncheckedCreateNestedManyWithoutHerramientaInput
  }

  export type herramientaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    marca_herramienta?: marca_herramientaUpdateOneRequiredWithoutHerramientaNestedInput
    movimiento_herramienta?: movimiento_herramientaUpdateManyWithoutHerramientaNestedInput
  }

  export type herramientaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    marca_id?: IntFieldUpdateOperationsInput | number
    movimiento_herramienta?: movimiento_herramientaUncheckedUpdateManyWithoutHerramientaNestedInput
  }

  export type herramientaCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    marca_id: number
  }

  export type herramientaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type herramientaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    marca_id?: IntFieldUpdateOperationsInput | number
  }

  export type horarioCreateInput = {
    hora_inicio: Date | string
    hora_fin: Date | string
    horario_empleado?: horario_empleadoCreateNestedManyWithoutHorarioInput
  }

  export type horarioUncheckedCreateInput = {
    id?: number
    hora_inicio: Date | string
    hora_fin: Date | string
    horario_empleado?: horario_empleadoUncheckedCreateNestedManyWithoutHorarioInput
  }

  export type horarioUpdateInput = {
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario_empleado?: horario_empleadoUpdateManyWithoutHorarioNestedInput
  }

  export type horarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    horario_empleado?: horario_empleadoUncheckedUpdateManyWithoutHorarioNestedInput
  }

  export type horarioCreateManyInput = {
    id?: number
    hora_inicio: Date | string
    hora_fin: Date | string
  }

  export type horarioUpdateManyMutationInput = {
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type horarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type horario_empleadoCreateInput = {
    fecha: Date | string
    empleado: empleadoCreateNestedOneWithoutHorario_empleadoInput
    horario: horarioCreateNestedOneWithoutHorario_empleadoInput
  }

  export type horario_empleadoUncheckedCreateInput = {
    empleado_ci: number
    horario_id: number
    fecha: Date | string
  }

  export type horario_empleadoUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    empleado?: empleadoUpdateOneRequiredWithoutHorario_empleadoNestedInput
    horario?: horarioUpdateOneRequiredWithoutHorario_empleadoNestedInput
  }

  export type horario_empleadoUncheckedUpdateInput = {
    empleado_ci?: IntFieldUpdateOperationsInput | number
    horario_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type horario_empleadoCreateManyInput = {
    empleado_ci: number
    horario_id: number
    fecha: Date | string
  }

  export type horario_empleadoUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type horario_empleadoUncheckedUpdateManyInput = {
    empleado_ci?: IntFieldUpdateOperationsInput | number
    horario_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type marca_herramientaCreateInput = {
    nombre: string
    herramienta?: herramientaCreateNestedManyWithoutMarca_herramientaInput
  }

  export type marca_herramientaUncheckedCreateInput = {
    id?: number
    nombre: string
    herramienta?: herramientaUncheckedCreateNestedManyWithoutMarca_herramientaInput
  }

  export type marca_herramientaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    herramienta?: herramientaUpdateManyWithoutMarca_herramientaNestedInput
  }

  export type marca_herramientaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    herramienta?: herramientaUncheckedUpdateManyWithoutMarca_herramientaNestedInput
  }

  export type marca_herramientaCreateManyInput = {
    id?: number
    nombre: string
  }

  export type marca_herramientaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type marca_herramientaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type marca_motoCreateInput = {
    nombre: string
    moto?: motoCreateNestedManyWithoutMarca_motoInput
  }

  export type marca_motoUncheckedCreateInput = {
    id?: number
    nombre: string
    moto?: motoUncheckedCreateNestedManyWithoutMarca_motoInput
  }

  export type marca_motoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    moto?: motoUpdateManyWithoutMarca_motoNestedInput
  }

  export type marca_motoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    moto?: motoUncheckedUpdateManyWithoutMarca_motoNestedInput
  }

  export type marca_motoCreateManyInput = {
    id?: number
    nombre: string
  }

  export type marca_motoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type marca_motoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type motoCreateInput = {
    placa: string
    modelo: string
    year: number
    chasis?: string | null
    diagnostico?: diagnosticoCreateNestedManyWithoutMotoInput
    marca_moto: marca_motoCreateNestedOneWithoutMotoInput
  }

  export type motoUncheckedCreateInput = {
    placa: string
    modelo: string
    year: number
    chasis?: string | null
    marca_id: number
    diagnostico?: diagnosticoUncheckedCreateNestedManyWithoutMotoInput
  }

  export type motoUpdateInput = {
    placa?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostico?: diagnosticoUpdateManyWithoutMotoNestedInput
    marca_moto?: marca_motoUpdateOneRequiredWithoutMotoNestedInput
  }

  export type motoUncheckedUpdateInput = {
    placa?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    marca_id?: IntFieldUpdateOperationsInput | number
    diagnostico?: diagnosticoUncheckedUpdateManyWithoutMotoNestedInput
  }

  export type motoCreateManyInput = {
    placa: string
    modelo: string
    year: number
    chasis?: string | null
    marca_id: number
  }

  export type motoUpdateManyMutationInput = {
    placa?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type motoUncheckedUpdateManyInput = {
    placa?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    marca_id?: IntFieldUpdateOperationsInput | number
  }

  export type movimiento_herramientaCreateInput = {
    fecha: Date | string
    cantidad: number
    herramienta: herramientaCreateNestedOneWithoutMovimiento_herramientaInput
    orden_trabajo: orden_trabajoCreateNestedOneWithoutMovimiento_herramientaInput
  }

  export type movimiento_herramientaUncheckedCreateInput = {
    herramienta_id: number
    orden_trabajo_id: bigint | number
    fecha: Date | string
    cantidad: number
  }

  export type movimiento_herramientaUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    herramienta?: herramientaUpdateOneRequiredWithoutMovimiento_herramientaNestedInput
    orden_trabajo?: orden_trabajoUpdateOneRequiredWithoutMovimiento_herramientaNestedInput
  }

  export type movimiento_herramientaUncheckedUpdateInput = {
    herramienta_id?: IntFieldUpdateOperationsInput | number
    orden_trabajo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type movimiento_herramientaCreateManyInput = {
    herramienta_id: number
    orden_trabajo_id: bigint | number
    fecha: Date | string
    cantidad: number
  }

  export type movimiento_herramientaUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type movimiento_herramientaUncheckedUpdateManyInput = {
    herramienta_id?: IntFieldUpdateOperationsInput | number
    orden_trabajo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type orden_trabajoCreateInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    comision?: comisionCreateNestedOneWithoutOrden_trabajoInput
    movimiento_herramienta?: movimiento_herramientaCreateNestedManyWithoutOrden_trabajoInput
    administrador?: administradorCreateNestedOneWithoutOrden_trabajoInput
    empleado: empleadoCreateNestedOneWithoutOrden_trabajoInput
    servicio: servicioCreateNestedOneWithoutOrden_trabajoInput
  }

  export type orden_trabajoUncheckedCreateInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    empleado_ci: number
    administrador_id?: number | null
    servicio_id: number
    comision?: comisionUncheckedCreateNestedOneWithoutOrden_trabajoInput
    movimiento_herramienta?: movimiento_herramientaUncheckedCreateNestedManyWithoutOrden_trabajoInput
  }

  export type orden_trabajoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    comision?: comisionUpdateOneWithoutOrden_trabajoNestedInput
    movimiento_herramienta?: movimiento_herramientaUpdateManyWithoutOrden_trabajoNestedInput
    administrador?: administradorUpdateOneWithoutOrden_trabajoNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutOrden_trabajoNestedInput
    servicio?: servicioUpdateOneRequiredWithoutOrden_trabajoNestedInput
  }

  export type orden_trabajoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    empleado_ci?: IntFieldUpdateOperationsInput | number
    administrador_id?: NullableIntFieldUpdateOperationsInput | number | null
    servicio_id?: IntFieldUpdateOperationsInput | number
    comision?: comisionUncheckedUpdateOneWithoutOrden_trabajoNestedInput
    movimiento_herramienta?: movimiento_herramientaUncheckedUpdateManyWithoutOrden_trabajoNestedInput
  }

  export type orden_trabajoCreateManyInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    empleado_ci: number
    administrador_id?: number | null
    servicio_id: number
  }

  export type orden_trabajoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
  }

  export type orden_trabajoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    empleado_ci?: IntFieldUpdateOperationsInput | number
    administrador_id?: NullableIntFieldUpdateOperationsInput | number | null
    servicio_id?: IntFieldUpdateOperationsInput | number
  }

  export type proformaCreateInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    detalle_proforma?: detalle_proformaCreateNestedManyWithoutProformaInput
    cliente: clienteCreateNestedOneWithoutProformaInput
    diagnostico?: diagnosticoCreateNestedOneWithoutProformaInput
    proforma_repuesto?: proforma_repuestoCreateNestedManyWithoutProformaInput
  }

  export type proformaUncheckedCreateInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    cliente_ci: number
    diagnostico_id?: bigint | number | null
    detalle_proforma?: detalle_proformaUncheckedCreateNestedManyWithoutProformaInput
    proforma_repuesto?: proforma_repuestoUncheckedCreateNestedManyWithoutProformaInput
  }

  export type proformaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_proforma?: detalle_proformaUpdateManyWithoutProformaNestedInput
    cliente?: clienteUpdateOneRequiredWithoutProformaNestedInput
    diagnostico?: diagnosticoUpdateOneWithoutProformaNestedInput
    proforma_repuesto?: proforma_repuestoUpdateManyWithoutProformaNestedInput
  }

  export type proformaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_ci?: IntFieldUpdateOperationsInput | number
    diagnostico_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    detalle_proforma?: detalle_proformaUncheckedUpdateManyWithoutProformaNestedInput
    proforma_repuesto?: proforma_repuestoUncheckedUpdateManyWithoutProformaNestedInput
  }

  export type proformaCreateManyInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    cliente_ci: number
    diagnostico_id?: bigint | number | null
  }

  export type proformaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type proformaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_ci?: IntFieldUpdateOperationsInput | number
    diagnostico_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type proforma_repuestoCreateInput = {
    nombre: string
    proforma: proformaCreateNestedOneWithoutProforma_repuestoInput
  }

  export type proforma_repuestoUncheckedCreateInput = {
    id?: number
    nombre: string
    proforma_id: bigint | number
  }

  export type proforma_repuestoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    proforma?: proformaUpdateOneRequiredWithoutProforma_repuestoNestedInput
  }

  export type proforma_repuestoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    proforma_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type proforma_repuestoCreateManyInput = {
    id?: number
    nombre: string
    proforma_id: bigint | number
  }

  export type proforma_repuestoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type proforma_repuestoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    proforma_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type servicioCreateInput = {
    descripcion: string
    detalle_proforma?: detalle_proformaCreateNestedManyWithoutServicioInput
    orden_trabajo?: orden_trabajoCreateNestedManyWithoutServicioInput
    categoria: categoriaCreateNestedOneWithoutServicioInput
  }

  export type servicioUncheckedCreateInput = {
    id?: number
    descripcion: string
    categoria_id: number
    detalle_proforma?: detalle_proformaUncheckedCreateNestedManyWithoutServicioInput
    orden_trabajo?: orden_trabajoUncheckedCreateNestedManyWithoutServicioInput
  }

  export type servicioUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    detalle_proforma?: detalle_proformaUpdateManyWithoutServicioNestedInput
    orden_trabajo?: orden_trabajoUpdateManyWithoutServicioNestedInput
    categoria?: categoriaUpdateOneRequiredWithoutServicioNestedInput
  }

  export type servicioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria_id?: IntFieldUpdateOperationsInput | number
    detalle_proforma?: detalle_proformaUncheckedUpdateManyWithoutServicioNestedInput
    orden_trabajo?: orden_trabajoUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type servicioCreateManyInput = {
    id?: number
    descripcion: string
    categoria_id: number
  }

  export type servicioUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type servicioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioCreateInput = {
    usuario: string
    contrasena: string
    email?: string | null
    administrador?: administradorCreateNestedOneWithoutUsuarioInput
    empleado: empleadoCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateInput = {
    id?: number
    empleado_ci: number
    usuario: string
    contrasena: string
    email?: string | null
    administrador?: administradorUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUpdateInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    administrador?: administradorUpdateOneWithoutUsuarioNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    empleado_ci?: IntFieldUpdateOperationsInput | number
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    administrador?: administradorUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type usuarioCreateManyInput = {
    id?: number
    empleado_ci: number
    usuario: string
    contrasena: string
    email?: string | null
  }

  export type usuarioUpdateManyMutationInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    empleado_ci?: IntFieldUpdateOperationsInput | number
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UsuarioScalarRelationFilter = {
    is?: usuarioWhereInput
    isNot?: usuarioWhereInput
  }

  export type Orden_trabajoListRelationFilter = {
    every?: orden_trabajoWhereInput
    some?: orden_trabajoWhereInput
    none?: orden_trabajoWhereInput
  }

  export type orden_trabajoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type administradorCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type administradorAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type administradorMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type administradorMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type administradorSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ServicioListRelationFilter = {
    every?: servicioWhereInput
    some?: servicioWhereInput
    none?: servicioWhereInput
  }

  export type servicioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type categoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type categoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type categoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FacturaListRelationFilter = {
    every?: facturaWhereInput
    some?: facturaWhereInput
    none?: facturaWhereInput
  }

  export type ProformaListRelationFilter = {
    every?: proformaWhereInput
    some?: proformaWhereInput
    none?: proformaWhereInput
  }

  export type facturaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proformaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clienteCountOrderByAggregateInput = {
    ci?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
  }

  export type clienteAvgOrderByAggregateInput = {
    ci?: SortOrder
  }

  export type clienteMaxOrderByAggregateInput = {
    ci?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
  }

  export type clienteMinOrderByAggregateInput = {
    ci?: SortOrder
    nombre?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
  }

  export type clienteSumOrderByAggregateInput = {
    ci?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Enumestado_pagoFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_pago | Enumestado_pagoFieldRefInput<$PrismaModel>
    in?: $Enums.estado_pago[] | ListEnumestado_pagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_pago[] | ListEnumestado_pagoFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_pagoFilter<$PrismaModel> | $Enums.estado_pago
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Orden_trabajoNullableScalarRelationFilter = {
    is?: orden_trabajoWhereInput | null
    isNot?: orden_trabajoWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type comisionCountOrderByAggregateInput = {
    id?: SortOrder
    orden_id?: SortOrder
    monto?: SortOrder
    estado_pago?: SortOrder
    fecha_pago?: SortOrder
  }

  export type comisionAvgOrderByAggregateInput = {
    id?: SortOrder
    orden_id?: SortOrder
    monto?: SortOrder
  }

  export type comisionMaxOrderByAggregateInput = {
    id?: SortOrder
    orden_id?: SortOrder
    monto?: SortOrder
    estado_pago?: SortOrder
    fecha_pago?: SortOrder
  }

  export type comisionMinOrderByAggregateInput = {
    id?: SortOrder
    orden_id?: SortOrder
    monto?: SortOrder
    estado_pago?: SortOrder
    fecha_pago?: SortOrder
  }

  export type comisionSumOrderByAggregateInput = {
    id?: SortOrder
    orden_id?: SortOrder
    monto?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Enumestado_pagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_pago | Enumestado_pagoFieldRefInput<$PrismaModel>
    in?: $Enums.estado_pago[] | ListEnumestado_pagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_pago[] | ListEnumestado_pagoFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_pagoWithAggregatesFilter<$PrismaModel> | $Enums.estado_pago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumestado_pagoFilter<$PrismaModel>
    _max?: NestedEnumestado_pagoFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type DiagnosticoScalarRelationFilter = {
    is?: diagnosticoWhereInput
    isNot?: diagnosticoWhereInput
  }

  export type detalle_diagnosticoIdDiagnostico_idCompoundUniqueInput = {
    id: bigint | number
    diagnostico_id: bigint | number
  }

  export type detalle_diagnosticoCountOrderByAggregateInput = {
    id?: SortOrder
    diagnostico_id?: SortOrder
    descripcion?: SortOrder
  }

  export type detalle_diagnosticoAvgOrderByAggregateInput = {
    id?: SortOrder
    diagnostico_id?: SortOrder
  }

  export type detalle_diagnosticoMaxOrderByAggregateInput = {
    id?: SortOrder
    diagnostico_id?: SortOrder
    descripcion?: SortOrder
  }

  export type detalle_diagnosticoMinOrderByAggregateInput = {
    id?: SortOrder
    diagnostico_id?: SortOrder
    descripcion?: SortOrder
  }

  export type detalle_diagnosticoSumOrderByAggregateInput = {
    id?: SortOrder
    diagnostico_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProformaScalarRelationFilter = {
    is?: proformaWhereInput
    isNot?: proformaWhereInput
  }

  export type ServicioNullableScalarRelationFilter = {
    is?: servicioWhereInput | null
    isNot?: servicioWhereInput | null
  }

  export type detalle_proformaIdProforma_idCompoundUniqueInput = {
    id: bigint | number
    proforma_id: bigint | number
  }

  export type detalle_proformaCountOrderByAggregateInput = {
    id?: SortOrder
    proforma_id?: SortOrder
    servicio_id?: SortOrder
    descripcion?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
  }

  export type detalle_proformaAvgOrderByAggregateInput = {
    id?: SortOrder
    proforma_id?: SortOrder
    servicio_id?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
  }

  export type detalle_proformaMaxOrderByAggregateInput = {
    id?: SortOrder
    proforma_id?: SortOrder
    servicio_id?: SortOrder
    descripcion?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
  }

  export type detalle_proformaMinOrderByAggregateInput = {
    id?: SortOrder
    proforma_id?: SortOrder
    servicio_id?: SortOrder
    descripcion?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
  }

  export type detalle_proformaSumOrderByAggregateInput = {
    id?: SortOrder
    proforma_id?: SortOrder
    servicio_id?: SortOrder
    cantidad?: SortOrder
    precio_unit?: SortOrder
    subtotal?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Detalle_diagnosticoListRelationFilter = {
    every?: detalle_diagnosticoWhereInput
    some?: detalle_diagnosticoWhereInput
    none?: detalle_diagnosticoWhereInput
  }

  export type EmpleadoScalarRelationFilter = {
    is?: empleadoWhereInput
    isNot?: empleadoWhereInput
  }

  export type MotoScalarRelationFilter = {
    is?: motoWhereInput
    isNot?: motoWhereInput
  }

  export type ProformaNullableScalarRelationFilter = {
    is?: proformaWhereInput | null
    isNot?: proformaWhereInput | null
  }

  export type detalle_diagnosticoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type diagnosticoPlaca_motoFechaHoraCompoundUniqueInput = {
    placa_moto: string
    fecha: Date | string
    hora: Date | string
  }

  export type diagnosticoCountOrderByAggregateInput = {
    nro?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    placa_moto?: SortOrder
    empleado_ci?: SortOrder
  }

  export type diagnosticoAvgOrderByAggregateInput = {
    nro?: SortOrder
    empleado_ci?: SortOrder
  }

  export type diagnosticoMaxOrderByAggregateInput = {
    nro?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    placa_moto?: SortOrder
    empleado_ci?: SortOrder
  }

  export type diagnosticoMinOrderByAggregateInput = {
    nro?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    placa_moto?: SortOrder
    empleado_ci?: SortOrder
  }

  export type diagnosticoSumOrderByAggregateInput = {
    nro?: SortOrder
    empleado_ci?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DiagnosticoListRelationFilter = {
    every?: diagnosticoWhereInput
    some?: diagnosticoWhereInput
    none?: diagnosticoWhereInput
  }

  export type Horario_empleadoListRelationFilter = {
    every?: horario_empleadoWhereInput
    some?: horario_empleadoWhereInput
    none?: horario_empleadoWhereInput
  }

  export type UsuarioNullableScalarRelationFilter = {
    is?: usuarioWhereInput | null
    isNot?: usuarioWhereInput | null
  }

  export type diagnosticoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type horario_empleadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type empleadoCountOrderByAggregateInput = {
    ci?: SortOrder
    nombre?: SortOrder
    fechanac?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
  }

  export type empleadoAvgOrderByAggregateInput = {
    ci?: SortOrder
    telefono?: SortOrder
  }

  export type empleadoMaxOrderByAggregateInput = {
    ci?: SortOrder
    nombre?: SortOrder
    fechanac?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
  }

  export type empleadoMinOrderByAggregateInput = {
    ci?: SortOrder
    nombre?: SortOrder
    fechanac?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
  }

  export type empleadoSumOrderByAggregateInput = {
    ci?: SortOrder
    telefono?: SortOrder
  }

  export type ClienteScalarRelationFilter = {
    is?: clienteWhereInput
    isNot?: clienteWhereInput
  }

  export type facturaCountOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    cliente_ci?: SortOrder
  }

  export type facturaAvgOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    cliente_ci?: SortOrder
  }

  export type facturaMaxOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    cliente_ci?: SortOrder
  }

  export type facturaMinOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    cliente_ci?: SortOrder
  }

  export type facturaSumOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    cliente_ci?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Marca_herramientaScalarRelationFilter = {
    is?: marca_herramientaWhereInput
    isNot?: marca_herramientaWhereInput
  }

  export type Movimiento_herramientaListRelationFilter = {
    every?: movimiento_herramientaWhereInput
    some?: movimiento_herramientaWhereInput
    none?: movimiento_herramientaWhereInput
  }

  export type movimiento_herramientaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type herramientaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    marca_id?: SortOrder
  }

  export type herramientaAvgOrderByAggregateInput = {
    id?: SortOrder
    marca_id?: SortOrder
  }

  export type herramientaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    marca_id?: SortOrder
  }

  export type herramientaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    marca_id?: SortOrder
  }

  export type herramientaSumOrderByAggregateInput = {
    id?: SortOrder
    marca_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type horarioCountOrderByAggregateInput = {
    id?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
  }

  export type horarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type horarioMaxOrderByAggregateInput = {
    id?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
  }

  export type horarioMinOrderByAggregateInput = {
    id?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
  }

  export type horarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HorarioScalarRelationFilter = {
    is?: horarioWhereInput
    isNot?: horarioWhereInput
  }

  export type horario_empleadoEmpleado_ciHorario_idCompoundUniqueInput = {
    empleado_ci: number
    horario_id: number
  }

  export type horario_empleadoCountOrderByAggregateInput = {
    empleado_ci?: SortOrder
    horario_id?: SortOrder
    fecha?: SortOrder
  }

  export type horario_empleadoAvgOrderByAggregateInput = {
    empleado_ci?: SortOrder
    horario_id?: SortOrder
  }

  export type horario_empleadoMaxOrderByAggregateInput = {
    empleado_ci?: SortOrder
    horario_id?: SortOrder
    fecha?: SortOrder
  }

  export type horario_empleadoMinOrderByAggregateInput = {
    empleado_ci?: SortOrder
    horario_id?: SortOrder
    fecha?: SortOrder
  }

  export type horario_empleadoSumOrderByAggregateInput = {
    empleado_ci?: SortOrder
    horario_id?: SortOrder
  }

  export type HerramientaListRelationFilter = {
    every?: herramientaWhereInput
    some?: herramientaWhereInput
    none?: herramientaWhereInput
  }

  export type herramientaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marca_herramientaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type marca_herramientaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type marca_herramientaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type marca_herramientaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type marca_herramientaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MotoListRelationFilter = {
    every?: motoWhereInput
    some?: motoWhereInput
    none?: motoWhereInput
  }

  export type motoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marca_motoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type marca_motoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type marca_motoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type marca_motoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type marca_motoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Marca_motoScalarRelationFilter = {
    is?: marca_motoWhereInput
    isNot?: marca_motoWhereInput
  }

  export type motoCountOrderByAggregateInput = {
    placa?: SortOrder
    modelo?: SortOrder
    year?: SortOrder
    chasis?: SortOrder
    marca_id?: SortOrder
  }

  export type motoAvgOrderByAggregateInput = {
    year?: SortOrder
    marca_id?: SortOrder
  }

  export type motoMaxOrderByAggregateInput = {
    placa?: SortOrder
    modelo?: SortOrder
    year?: SortOrder
    chasis?: SortOrder
    marca_id?: SortOrder
  }

  export type motoMinOrderByAggregateInput = {
    placa?: SortOrder
    modelo?: SortOrder
    year?: SortOrder
    chasis?: SortOrder
    marca_id?: SortOrder
  }

  export type motoSumOrderByAggregateInput = {
    year?: SortOrder
    marca_id?: SortOrder
  }

  export type HerramientaScalarRelationFilter = {
    is?: herramientaWhereInput
    isNot?: herramientaWhereInput
  }

  export type Orden_trabajoScalarRelationFilter = {
    is?: orden_trabajoWhereInput
    isNot?: orden_trabajoWhereInput
  }

  export type movimiento_herramientaOrden_trabajo_idHerramienta_idCompoundUniqueInput = {
    orden_trabajo_id: bigint | number
    herramienta_id: number
  }

  export type movimiento_herramientaCountOrderByAggregateInput = {
    herramienta_id?: SortOrder
    orden_trabajo_id?: SortOrder
    fecha?: SortOrder
    cantidad?: SortOrder
  }

  export type movimiento_herramientaAvgOrderByAggregateInput = {
    herramienta_id?: SortOrder
    orden_trabajo_id?: SortOrder
    cantidad?: SortOrder
  }

  export type movimiento_herramientaMaxOrderByAggregateInput = {
    herramienta_id?: SortOrder
    orden_trabajo_id?: SortOrder
    fecha?: SortOrder
    cantidad?: SortOrder
  }

  export type movimiento_herramientaMinOrderByAggregateInput = {
    herramienta_id?: SortOrder
    orden_trabajo_id?: SortOrder
    fecha?: SortOrder
    cantidad?: SortOrder
  }

  export type movimiento_herramientaSumOrderByAggregateInput = {
    herramienta_id?: SortOrder
    orden_trabajo_id?: SortOrder
    cantidad?: SortOrder
  }

  export type Enumestado_ordenFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_orden | Enumestado_ordenFieldRefInput<$PrismaModel>
    in?: $Enums.estado_orden[] | ListEnumestado_ordenFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_orden[] | ListEnumestado_ordenFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_ordenFilter<$PrismaModel> | $Enums.estado_orden
  }

  export type ComisionNullableScalarRelationFilter = {
    is?: comisionWhereInput | null
    isNot?: comisionWhereInput | null
  }

  export type AdministradorNullableScalarRelationFilter = {
    is?: administradorWhereInput | null
    isNot?: administradorWhereInput | null
  }

  export type ServicioScalarRelationFilter = {
    is?: servicioWhereInput
    isNot?: servicioWhereInput
  }

  export type orden_trabajoCountOrderByAggregateInput = {
    id?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empleado_ci?: SortOrder
    administrador_id?: SortOrder
    servicio_id?: SortOrder
  }

  export type orden_trabajoAvgOrderByAggregateInput = {
    id?: SortOrder
    empleado_ci?: SortOrder
    administrador_id?: SortOrder
    servicio_id?: SortOrder
  }

  export type orden_trabajoMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empleado_ci?: SortOrder
    administrador_id?: SortOrder
    servicio_id?: SortOrder
  }

  export type orden_trabajoMinOrderByAggregateInput = {
    id?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    estado?: SortOrder
    empleado_ci?: SortOrder
    administrador_id?: SortOrder
    servicio_id?: SortOrder
  }

  export type orden_trabajoSumOrderByAggregateInput = {
    id?: SortOrder
    empleado_ci?: SortOrder
    administrador_id?: SortOrder
    servicio_id?: SortOrder
  }

  export type Enumestado_ordenWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_orden | Enumestado_ordenFieldRefInput<$PrismaModel>
    in?: $Enums.estado_orden[] | ListEnumestado_ordenFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_orden[] | ListEnumestado_ordenFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_ordenWithAggregatesFilter<$PrismaModel> | $Enums.estado_orden
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumestado_ordenFilter<$PrismaModel>
    _max?: NestedEnumestado_ordenFilter<$PrismaModel>
  }

  export type Enumestado_proformaFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_proforma | Enumestado_proformaFieldRefInput<$PrismaModel>
    in?: $Enums.estado_proforma[] | ListEnumestado_proformaFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_proforma[] | ListEnumestado_proformaFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_proformaFilter<$PrismaModel> | $Enums.estado_proforma
  }

  export type Detalle_proformaListRelationFilter = {
    every?: detalle_proformaWhereInput
    some?: detalle_proformaWhereInput
    none?: detalle_proformaWhereInput
  }

  export type DiagnosticoNullableScalarRelationFilter = {
    is?: diagnosticoWhereInput | null
    isNot?: diagnosticoWhereInput | null
  }

  export type Proforma_repuestoListRelationFilter = {
    every?: proforma_repuestoWhereInput
    some?: proforma_repuestoWhereInput
    none?: proforma_repuestoWhereInput
  }

  export type detalle_proformaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proforma_repuestoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proformaCountOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    total?: SortOrder
    cliente_ci?: SortOrder
    diagnostico_id?: SortOrder
  }

  export type proformaAvgOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    cliente_ci?: SortOrder
    diagnostico_id?: SortOrder
  }

  export type proformaMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    total?: SortOrder
    cliente_ci?: SortOrder
    diagnostico_id?: SortOrder
  }

  export type proformaMinOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    total?: SortOrder
    cliente_ci?: SortOrder
    diagnostico_id?: SortOrder
  }

  export type proformaSumOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    cliente_ci?: SortOrder
    diagnostico_id?: SortOrder
  }

  export type Enumestado_proformaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_proforma | Enumestado_proformaFieldRefInput<$PrismaModel>
    in?: $Enums.estado_proforma[] | ListEnumestado_proformaFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_proforma[] | ListEnumestado_proformaFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_proformaWithAggregatesFilter<$PrismaModel> | $Enums.estado_proforma
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumestado_proformaFilter<$PrismaModel>
    _max?: NestedEnumestado_proformaFilter<$PrismaModel>
  }

  export type proforma_repuestoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    proforma_id?: SortOrder
  }

  export type proforma_repuestoAvgOrderByAggregateInput = {
    id?: SortOrder
    proforma_id?: SortOrder
  }

  export type proforma_repuestoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    proforma_id?: SortOrder
  }

  export type proforma_repuestoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    proforma_id?: SortOrder
  }

  export type proforma_repuestoSumOrderByAggregateInput = {
    id?: SortOrder
    proforma_id?: SortOrder
  }

  export type CategoriaScalarRelationFilter = {
    is?: categoriaWhereInput
    isNot?: categoriaWhereInput
  }

  export type servicioCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    categoria_id?: SortOrder
  }

  export type servicioAvgOrderByAggregateInput = {
    id?: SortOrder
    categoria_id?: SortOrder
  }

  export type servicioMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    categoria_id?: SortOrder
  }

  export type servicioMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    categoria_id?: SortOrder
  }

  export type servicioSumOrderByAggregateInput = {
    id?: SortOrder
    categoria_id?: SortOrder
  }

  export type usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    empleado_ci?: SortOrder
    usuario?: SortOrder
    contrasena?: SortOrder
    email?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    empleado_ci?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    empleado_ci?: SortOrder
    usuario?: SortOrder
    contrasena?: SortOrder
    email?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    empleado_ci?: SortOrder
    usuario?: SortOrder
    contrasena?: SortOrder
    email?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    empleado_ci?: SortOrder
  }

  export type usuarioCreateNestedOneWithoutAdministradorInput = {
    create?: XOR<usuarioCreateWithoutAdministradorInput, usuarioUncheckedCreateWithoutAdministradorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutAdministradorInput
    connect?: usuarioWhereUniqueInput
  }

  export type orden_trabajoCreateNestedManyWithoutAdministradorInput = {
    create?: XOR<orden_trabajoCreateWithoutAdministradorInput, orden_trabajoUncheckedCreateWithoutAdministradorInput> | orden_trabajoCreateWithoutAdministradorInput[] | orden_trabajoUncheckedCreateWithoutAdministradorInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutAdministradorInput | orden_trabajoCreateOrConnectWithoutAdministradorInput[]
    createMany?: orden_trabajoCreateManyAdministradorInputEnvelope
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
  }

  export type orden_trabajoUncheckedCreateNestedManyWithoutAdministradorInput = {
    create?: XOR<orden_trabajoCreateWithoutAdministradorInput, orden_trabajoUncheckedCreateWithoutAdministradorInput> | orden_trabajoCreateWithoutAdministradorInput[] | orden_trabajoUncheckedCreateWithoutAdministradorInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutAdministradorInput | orden_trabajoCreateOrConnectWithoutAdministradorInput[]
    createMany?: orden_trabajoCreateManyAdministradorInputEnvelope
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
  }

  export type usuarioUpdateOneRequiredWithoutAdministradorNestedInput = {
    create?: XOR<usuarioCreateWithoutAdministradorInput, usuarioUncheckedCreateWithoutAdministradorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutAdministradorInput
    upsert?: usuarioUpsertWithoutAdministradorInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutAdministradorInput, usuarioUpdateWithoutAdministradorInput>, usuarioUncheckedUpdateWithoutAdministradorInput>
  }

  export type orden_trabajoUpdateManyWithoutAdministradorNestedInput = {
    create?: XOR<orden_trabajoCreateWithoutAdministradorInput, orden_trabajoUncheckedCreateWithoutAdministradorInput> | orden_trabajoCreateWithoutAdministradorInput[] | orden_trabajoUncheckedCreateWithoutAdministradorInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutAdministradorInput | orden_trabajoCreateOrConnectWithoutAdministradorInput[]
    upsert?: orden_trabajoUpsertWithWhereUniqueWithoutAdministradorInput | orden_trabajoUpsertWithWhereUniqueWithoutAdministradorInput[]
    createMany?: orden_trabajoCreateManyAdministradorInputEnvelope
    set?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    disconnect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    delete?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    update?: orden_trabajoUpdateWithWhereUniqueWithoutAdministradorInput | orden_trabajoUpdateWithWhereUniqueWithoutAdministradorInput[]
    updateMany?: orden_trabajoUpdateManyWithWhereWithoutAdministradorInput | orden_trabajoUpdateManyWithWhereWithoutAdministradorInput[]
    deleteMany?: orden_trabajoScalarWhereInput | orden_trabajoScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type orden_trabajoUncheckedUpdateManyWithoutAdministradorNestedInput = {
    create?: XOR<orden_trabajoCreateWithoutAdministradorInput, orden_trabajoUncheckedCreateWithoutAdministradorInput> | orden_trabajoCreateWithoutAdministradorInput[] | orden_trabajoUncheckedCreateWithoutAdministradorInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutAdministradorInput | orden_trabajoCreateOrConnectWithoutAdministradorInput[]
    upsert?: orden_trabajoUpsertWithWhereUniqueWithoutAdministradorInput | orden_trabajoUpsertWithWhereUniqueWithoutAdministradorInput[]
    createMany?: orden_trabajoCreateManyAdministradorInputEnvelope
    set?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    disconnect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    delete?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    update?: orden_trabajoUpdateWithWhereUniqueWithoutAdministradorInput | orden_trabajoUpdateWithWhereUniqueWithoutAdministradorInput[]
    updateMany?: orden_trabajoUpdateManyWithWhereWithoutAdministradorInput | orden_trabajoUpdateManyWithWhereWithoutAdministradorInput[]
    deleteMany?: orden_trabajoScalarWhereInput | orden_trabajoScalarWhereInput[]
  }

  export type servicioCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<servicioCreateWithoutCategoriaInput, servicioUncheckedCreateWithoutCategoriaInput> | servicioCreateWithoutCategoriaInput[] | servicioUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: servicioCreateOrConnectWithoutCategoriaInput | servicioCreateOrConnectWithoutCategoriaInput[]
    createMany?: servicioCreateManyCategoriaInputEnvelope
    connect?: servicioWhereUniqueInput | servicioWhereUniqueInput[]
  }

  export type servicioUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<servicioCreateWithoutCategoriaInput, servicioUncheckedCreateWithoutCategoriaInput> | servicioCreateWithoutCategoriaInput[] | servicioUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: servicioCreateOrConnectWithoutCategoriaInput | servicioCreateOrConnectWithoutCategoriaInput[]
    createMany?: servicioCreateManyCategoriaInputEnvelope
    connect?: servicioWhereUniqueInput | servicioWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type servicioUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<servicioCreateWithoutCategoriaInput, servicioUncheckedCreateWithoutCategoriaInput> | servicioCreateWithoutCategoriaInput[] | servicioUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: servicioCreateOrConnectWithoutCategoriaInput | servicioCreateOrConnectWithoutCategoriaInput[]
    upsert?: servicioUpsertWithWhereUniqueWithoutCategoriaInput | servicioUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: servicioCreateManyCategoriaInputEnvelope
    set?: servicioWhereUniqueInput | servicioWhereUniqueInput[]
    disconnect?: servicioWhereUniqueInput | servicioWhereUniqueInput[]
    delete?: servicioWhereUniqueInput | servicioWhereUniqueInput[]
    connect?: servicioWhereUniqueInput | servicioWhereUniqueInput[]
    update?: servicioUpdateWithWhereUniqueWithoutCategoriaInput | servicioUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: servicioUpdateManyWithWhereWithoutCategoriaInput | servicioUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: servicioScalarWhereInput | servicioScalarWhereInput[]
  }

  export type servicioUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<servicioCreateWithoutCategoriaInput, servicioUncheckedCreateWithoutCategoriaInput> | servicioCreateWithoutCategoriaInput[] | servicioUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: servicioCreateOrConnectWithoutCategoriaInput | servicioCreateOrConnectWithoutCategoriaInput[]
    upsert?: servicioUpsertWithWhereUniqueWithoutCategoriaInput | servicioUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: servicioCreateManyCategoriaInputEnvelope
    set?: servicioWhereUniqueInput | servicioWhereUniqueInput[]
    disconnect?: servicioWhereUniqueInput | servicioWhereUniqueInput[]
    delete?: servicioWhereUniqueInput | servicioWhereUniqueInput[]
    connect?: servicioWhereUniqueInput | servicioWhereUniqueInput[]
    update?: servicioUpdateWithWhereUniqueWithoutCategoriaInput | servicioUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: servicioUpdateManyWithWhereWithoutCategoriaInput | servicioUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: servicioScalarWhereInput | servicioScalarWhereInput[]
  }

  export type facturaCreateNestedManyWithoutClienteInput = {
    create?: XOR<facturaCreateWithoutClienteInput, facturaUncheckedCreateWithoutClienteInput> | facturaCreateWithoutClienteInput[] | facturaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutClienteInput | facturaCreateOrConnectWithoutClienteInput[]
    createMany?: facturaCreateManyClienteInputEnvelope
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
  }

  export type proformaCreateNestedManyWithoutClienteInput = {
    create?: XOR<proformaCreateWithoutClienteInput, proformaUncheckedCreateWithoutClienteInput> | proformaCreateWithoutClienteInput[] | proformaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: proformaCreateOrConnectWithoutClienteInput | proformaCreateOrConnectWithoutClienteInput[]
    createMany?: proformaCreateManyClienteInputEnvelope
    connect?: proformaWhereUniqueInput | proformaWhereUniqueInput[]
  }

  export type facturaUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<facturaCreateWithoutClienteInput, facturaUncheckedCreateWithoutClienteInput> | facturaCreateWithoutClienteInput[] | facturaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutClienteInput | facturaCreateOrConnectWithoutClienteInput[]
    createMany?: facturaCreateManyClienteInputEnvelope
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
  }

  export type proformaUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<proformaCreateWithoutClienteInput, proformaUncheckedCreateWithoutClienteInput> | proformaCreateWithoutClienteInput[] | proformaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: proformaCreateOrConnectWithoutClienteInput | proformaCreateOrConnectWithoutClienteInput[]
    createMany?: proformaCreateManyClienteInputEnvelope
    connect?: proformaWhereUniqueInput | proformaWhereUniqueInput[]
  }

  export type facturaUpdateManyWithoutClienteNestedInput = {
    create?: XOR<facturaCreateWithoutClienteInput, facturaUncheckedCreateWithoutClienteInput> | facturaCreateWithoutClienteInput[] | facturaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutClienteInput | facturaCreateOrConnectWithoutClienteInput[]
    upsert?: facturaUpsertWithWhereUniqueWithoutClienteInput | facturaUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: facturaCreateManyClienteInputEnvelope
    set?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    disconnect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    delete?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    update?: facturaUpdateWithWhereUniqueWithoutClienteInput | facturaUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: facturaUpdateManyWithWhereWithoutClienteInput | facturaUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: facturaScalarWhereInput | facturaScalarWhereInput[]
  }

  export type proformaUpdateManyWithoutClienteNestedInput = {
    create?: XOR<proformaCreateWithoutClienteInput, proformaUncheckedCreateWithoutClienteInput> | proformaCreateWithoutClienteInput[] | proformaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: proformaCreateOrConnectWithoutClienteInput | proformaCreateOrConnectWithoutClienteInput[]
    upsert?: proformaUpsertWithWhereUniqueWithoutClienteInput | proformaUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: proformaCreateManyClienteInputEnvelope
    set?: proformaWhereUniqueInput | proformaWhereUniqueInput[]
    disconnect?: proformaWhereUniqueInput | proformaWhereUniqueInput[]
    delete?: proformaWhereUniqueInput | proformaWhereUniqueInput[]
    connect?: proformaWhereUniqueInput | proformaWhereUniqueInput[]
    update?: proformaUpdateWithWhereUniqueWithoutClienteInput | proformaUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: proformaUpdateManyWithWhereWithoutClienteInput | proformaUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: proformaScalarWhereInput | proformaScalarWhereInput[]
  }

  export type facturaUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<facturaCreateWithoutClienteInput, facturaUncheckedCreateWithoutClienteInput> | facturaCreateWithoutClienteInput[] | facturaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: facturaCreateOrConnectWithoutClienteInput | facturaCreateOrConnectWithoutClienteInput[]
    upsert?: facturaUpsertWithWhereUniqueWithoutClienteInput | facturaUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: facturaCreateManyClienteInputEnvelope
    set?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    disconnect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    delete?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    connect?: facturaWhereUniqueInput | facturaWhereUniqueInput[]
    update?: facturaUpdateWithWhereUniqueWithoutClienteInput | facturaUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: facturaUpdateManyWithWhereWithoutClienteInput | facturaUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: facturaScalarWhereInput | facturaScalarWhereInput[]
  }

  export type proformaUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<proformaCreateWithoutClienteInput, proformaUncheckedCreateWithoutClienteInput> | proformaCreateWithoutClienteInput[] | proformaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: proformaCreateOrConnectWithoutClienteInput | proformaCreateOrConnectWithoutClienteInput[]
    upsert?: proformaUpsertWithWhereUniqueWithoutClienteInput | proformaUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: proformaCreateManyClienteInputEnvelope
    set?: proformaWhereUniqueInput | proformaWhereUniqueInput[]
    disconnect?: proformaWhereUniqueInput | proformaWhereUniqueInput[]
    delete?: proformaWhereUniqueInput | proformaWhereUniqueInput[]
    connect?: proformaWhereUniqueInput | proformaWhereUniqueInput[]
    update?: proformaUpdateWithWhereUniqueWithoutClienteInput | proformaUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: proformaUpdateManyWithWhereWithoutClienteInput | proformaUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: proformaScalarWhereInput | proformaScalarWhereInput[]
  }

  export type orden_trabajoCreateNestedOneWithoutComisionInput = {
    create?: XOR<orden_trabajoCreateWithoutComisionInput, orden_trabajoUncheckedCreateWithoutComisionInput>
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutComisionInput
    connect?: orden_trabajoWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type Enumestado_pagoFieldUpdateOperationsInput = {
    set?: $Enums.estado_pago
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type orden_trabajoUpdateOneWithoutComisionNestedInput = {
    create?: XOR<orden_trabajoCreateWithoutComisionInput, orden_trabajoUncheckedCreateWithoutComisionInput>
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutComisionInput
    upsert?: orden_trabajoUpsertWithoutComisionInput
    disconnect?: orden_trabajoWhereInput | boolean
    delete?: orden_trabajoWhereInput | boolean
    connect?: orden_trabajoWhereUniqueInput
    update?: XOR<XOR<orden_trabajoUpdateToOneWithWhereWithoutComisionInput, orden_trabajoUpdateWithoutComisionInput>, orden_trabajoUncheckedUpdateWithoutComisionInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type diagnosticoCreateNestedOneWithoutDetalle_diagnosticoInput = {
    create?: XOR<diagnosticoCreateWithoutDetalle_diagnosticoInput, diagnosticoUncheckedCreateWithoutDetalle_diagnosticoInput>
    connectOrCreate?: diagnosticoCreateOrConnectWithoutDetalle_diagnosticoInput
    connect?: diagnosticoWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type diagnosticoUpdateOneRequiredWithoutDetalle_diagnosticoNestedInput = {
    create?: XOR<diagnosticoCreateWithoutDetalle_diagnosticoInput, diagnosticoUncheckedCreateWithoutDetalle_diagnosticoInput>
    connectOrCreate?: diagnosticoCreateOrConnectWithoutDetalle_diagnosticoInput
    upsert?: diagnosticoUpsertWithoutDetalle_diagnosticoInput
    connect?: diagnosticoWhereUniqueInput
    update?: XOR<XOR<diagnosticoUpdateToOneWithWhereWithoutDetalle_diagnosticoInput, diagnosticoUpdateWithoutDetalle_diagnosticoInput>, diagnosticoUncheckedUpdateWithoutDetalle_diagnosticoInput>
  }

  export type proformaCreateNestedOneWithoutDetalle_proformaInput = {
    create?: XOR<proformaCreateWithoutDetalle_proformaInput, proformaUncheckedCreateWithoutDetalle_proformaInput>
    connectOrCreate?: proformaCreateOrConnectWithoutDetalle_proformaInput
    connect?: proformaWhereUniqueInput
  }

  export type servicioCreateNestedOneWithoutDetalle_proformaInput = {
    create?: XOR<servicioCreateWithoutDetalle_proformaInput, servicioUncheckedCreateWithoutDetalle_proformaInput>
    connectOrCreate?: servicioCreateOrConnectWithoutDetalle_proformaInput
    connect?: servicioWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type proformaUpdateOneRequiredWithoutDetalle_proformaNestedInput = {
    create?: XOR<proformaCreateWithoutDetalle_proformaInput, proformaUncheckedCreateWithoutDetalle_proformaInput>
    connectOrCreate?: proformaCreateOrConnectWithoutDetalle_proformaInput
    upsert?: proformaUpsertWithoutDetalle_proformaInput
    connect?: proformaWhereUniqueInput
    update?: XOR<XOR<proformaUpdateToOneWithWhereWithoutDetalle_proformaInput, proformaUpdateWithoutDetalle_proformaInput>, proformaUncheckedUpdateWithoutDetalle_proformaInput>
  }

  export type servicioUpdateOneWithoutDetalle_proformaNestedInput = {
    create?: XOR<servicioCreateWithoutDetalle_proformaInput, servicioUncheckedCreateWithoutDetalle_proformaInput>
    connectOrCreate?: servicioCreateOrConnectWithoutDetalle_proformaInput
    upsert?: servicioUpsertWithoutDetalle_proformaInput
    disconnect?: servicioWhereInput | boolean
    delete?: servicioWhereInput | boolean
    connect?: servicioWhereUniqueInput
    update?: XOR<XOR<servicioUpdateToOneWithWhereWithoutDetalle_proformaInput, servicioUpdateWithoutDetalle_proformaInput>, servicioUncheckedUpdateWithoutDetalle_proformaInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type detalle_diagnosticoCreateNestedManyWithoutDiagnosticoInput = {
    create?: XOR<detalle_diagnosticoCreateWithoutDiagnosticoInput, detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput> | detalle_diagnosticoCreateWithoutDiagnosticoInput[] | detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput[]
    connectOrCreate?: detalle_diagnosticoCreateOrConnectWithoutDiagnosticoInput | detalle_diagnosticoCreateOrConnectWithoutDiagnosticoInput[]
    createMany?: detalle_diagnosticoCreateManyDiagnosticoInputEnvelope
    connect?: detalle_diagnosticoWhereUniqueInput | detalle_diagnosticoWhereUniqueInput[]
  }

  export type empleadoCreateNestedOneWithoutDiagnosticoInput = {
    create?: XOR<empleadoCreateWithoutDiagnosticoInput, empleadoUncheckedCreateWithoutDiagnosticoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutDiagnosticoInput
    connect?: empleadoWhereUniqueInput
  }

  export type motoCreateNestedOneWithoutDiagnosticoInput = {
    create?: XOR<motoCreateWithoutDiagnosticoInput, motoUncheckedCreateWithoutDiagnosticoInput>
    connectOrCreate?: motoCreateOrConnectWithoutDiagnosticoInput
    connect?: motoWhereUniqueInput
  }

  export type proformaCreateNestedOneWithoutDiagnosticoInput = {
    create?: XOR<proformaCreateWithoutDiagnosticoInput, proformaUncheckedCreateWithoutDiagnosticoInput>
    connectOrCreate?: proformaCreateOrConnectWithoutDiagnosticoInput
    connect?: proformaWhereUniqueInput
  }

  export type detalle_diagnosticoUncheckedCreateNestedManyWithoutDiagnosticoInput = {
    create?: XOR<detalle_diagnosticoCreateWithoutDiagnosticoInput, detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput> | detalle_diagnosticoCreateWithoutDiagnosticoInput[] | detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput[]
    connectOrCreate?: detalle_diagnosticoCreateOrConnectWithoutDiagnosticoInput | detalle_diagnosticoCreateOrConnectWithoutDiagnosticoInput[]
    createMany?: detalle_diagnosticoCreateManyDiagnosticoInputEnvelope
    connect?: detalle_diagnosticoWhereUniqueInput | detalle_diagnosticoWhereUniqueInput[]
  }

  export type proformaUncheckedCreateNestedOneWithoutDiagnosticoInput = {
    create?: XOR<proformaCreateWithoutDiagnosticoInput, proformaUncheckedCreateWithoutDiagnosticoInput>
    connectOrCreate?: proformaCreateOrConnectWithoutDiagnosticoInput
    connect?: proformaWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type detalle_diagnosticoUpdateManyWithoutDiagnosticoNestedInput = {
    create?: XOR<detalle_diagnosticoCreateWithoutDiagnosticoInput, detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput> | detalle_diagnosticoCreateWithoutDiagnosticoInput[] | detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput[]
    connectOrCreate?: detalle_diagnosticoCreateOrConnectWithoutDiagnosticoInput | detalle_diagnosticoCreateOrConnectWithoutDiagnosticoInput[]
    upsert?: detalle_diagnosticoUpsertWithWhereUniqueWithoutDiagnosticoInput | detalle_diagnosticoUpsertWithWhereUniqueWithoutDiagnosticoInput[]
    createMany?: detalle_diagnosticoCreateManyDiagnosticoInputEnvelope
    set?: detalle_diagnosticoWhereUniqueInput | detalle_diagnosticoWhereUniqueInput[]
    disconnect?: detalle_diagnosticoWhereUniqueInput | detalle_diagnosticoWhereUniqueInput[]
    delete?: detalle_diagnosticoWhereUniqueInput | detalle_diagnosticoWhereUniqueInput[]
    connect?: detalle_diagnosticoWhereUniqueInput | detalle_diagnosticoWhereUniqueInput[]
    update?: detalle_diagnosticoUpdateWithWhereUniqueWithoutDiagnosticoInput | detalle_diagnosticoUpdateWithWhereUniqueWithoutDiagnosticoInput[]
    updateMany?: detalle_diagnosticoUpdateManyWithWhereWithoutDiagnosticoInput | detalle_diagnosticoUpdateManyWithWhereWithoutDiagnosticoInput[]
    deleteMany?: detalle_diagnosticoScalarWhereInput | detalle_diagnosticoScalarWhereInput[]
  }

  export type empleadoUpdateOneRequiredWithoutDiagnosticoNestedInput = {
    create?: XOR<empleadoCreateWithoutDiagnosticoInput, empleadoUncheckedCreateWithoutDiagnosticoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutDiagnosticoInput
    upsert?: empleadoUpsertWithoutDiagnosticoInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<XOR<empleadoUpdateToOneWithWhereWithoutDiagnosticoInput, empleadoUpdateWithoutDiagnosticoInput>, empleadoUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type motoUpdateOneRequiredWithoutDiagnosticoNestedInput = {
    create?: XOR<motoCreateWithoutDiagnosticoInput, motoUncheckedCreateWithoutDiagnosticoInput>
    connectOrCreate?: motoCreateOrConnectWithoutDiagnosticoInput
    upsert?: motoUpsertWithoutDiagnosticoInput
    connect?: motoWhereUniqueInput
    update?: XOR<XOR<motoUpdateToOneWithWhereWithoutDiagnosticoInput, motoUpdateWithoutDiagnosticoInput>, motoUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type proformaUpdateOneWithoutDiagnosticoNestedInput = {
    create?: XOR<proformaCreateWithoutDiagnosticoInput, proformaUncheckedCreateWithoutDiagnosticoInput>
    connectOrCreate?: proformaCreateOrConnectWithoutDiagnosticoInput
    upsert?: proformaUpsertWithoutDiagnosticoInput
    disconnect?: proformaWhereInput | boolean
    delete?: proformaWhereInput | boolean
    connect?: proformaWhereUniqueInput
    update?: XOR<XOR<proformaUpdateToOneWithWhereWithoutDiagnosticoInput, proformaUpdateWithoutDiagnosticoInput>, proformaUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type detalle_diagnosticoUncheckedUpdateManyWithoutDiagnosticoNestedInput = {
    create?: XOR<detalle_diagnosticoCreateWithoutDiagnosticoInput, detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput> | detalle_diagnosticoCreateWithoutDiagnosticoInput[] | detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput[]
    connectOrCreate?: detalle_diagnosticoCreateOrConnectWithoutDiagnosticoInput | detalle_diagnosticoCreateOrConnectWithoutDiagnosticoInput[]
    upsert?: detalle_diagnosticoUpsertWithWhereUniqueWithoutDiagnosticoInput | detalle_diagnosticoUpsertWithWhereUniqueWithoutDiagnosticoInput[]
    createMany?: detalle_diagnosticoCreateManyDiagnosticoInputEnvelope
    set?: detalle_diagnosticoWhereUniqueInput | detalle_diagnosticoWhereUniqueInput[]
    disconnect?: detalle_diagnosticoWhereUniqueInput | detalle_diagnosticoWhereUniqueInput[]
    delete?: detalle_diagnosticoWhereUniqueInput | detalle_diagnosticoWhereUniqueInput[]
    connect?: detalle_diagnosticoWhereUniqueInput | detalle_diagnosticoWhereUniqueInput[]
    update?: detalle_diagnosticoUpdateWithWhereUniqueWithoutDiagnosticoInput | detalle_diagnosticoUpdateWithWhereUniqueWithoutDiagnosticoInput[]
    updateMany?: detalle_diagnosticoUpdateManyWithWhereWithoutDiagnosticoInput | detalle_diagnosticoUpdateManyWithWhereWithoutDiagnosticoInput[]
    deleteMany?: detalle_diagnosticoScalarWhereInput | detalle_diagnosticoScalarWhereInput[]
  }

  export type proformaUncheckedUpdateOneWithoutDiagnosticoNestedInput = {
    create?: XOR<proformaCreateWithoutDiagnosticoInput, proformaUncheckedCreateWithoutDiagnosticoInput>
    connectOrCreate?: proformaCreateOrConnectWithoutDiagnosticoInput
    upsert?: proformaUpsertWithoutDiagnosticoInput
    disconnect?: proformaWhereInput | boolean
    delete?: proformaWhereInput | boolean
    connect?: proformaWhereUniqueInput
    update?: XOR<XOR<proformaUpdateToOneWithWhereWithoutDiagnosticoInput, proformaUpdateWithoutDiagnosticoInput>, proformaUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type diagnosticoCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<diagnosticoCreateWithoutEmpleadoInput, diagnosticoUncheckedCreateWithoutEmpleadoInput> | diagnosticoCreateWithoutEmpleadoInput[] | diagnosticoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutEmpleadoInput | diagnosticoCreateOrConnectWithoutEmpleadoInput[]
    createMany?: diagnosticoCreateManyEmpleadoInputEnvelope
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
  }

  export type horario_empleadoCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<horario_empleadoCreateWithoutEmpleadoInput, horario_empleadoUncheckedCreateWithoutEmpleadoInput> | horario_empleadoCreateWithoutEmpleadoInput[] | horario_empleadoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: horario_empleadoCreateOrConnectWithoutEmpleadoInput | horario_empleadoCreateOrConnectWithoutEmpleadoInput[]
    createMany?: horario_empleadoCreateManyEmpleadoInputEnvelope
    connect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
  }

  export type orden_trabajoCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<orden_trabajoCreateWithoutEmpleadoInput, orden_trabajoUncheckedCreateWithoutEmpleadoInput> | orden_trabajoCreateWithoutEmpleadoInput[] | orden_trabajoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutEmpleadoInput | orden_trabajoCreateOrConnectWithoutEmpleadoInput[]
    createMany?: orden_trabajoCreateManyEmpleadoInputEnvelope
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
  }

  export type usuarioCreateNestedOneWithoutEmpleadoInput = {
    create?: XOR<usuarioCreateWithoutEmpleadoInput, usuarioUncheckedCreateWithoutEmpleadoInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutEmpleadoInput
    connect?: usuarioWhereUniqueInput
  }

  export type diagnosticoUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<diagnosticoCreateWithoutEmpleadoInput, diagnosticoUncheckedCreateWithoutEmpleadoInput> | diagnosticoCreateWithoutEmpleadoInput[] | diagnosticoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutEmpleadoInput | diagnosticoCreateOrConnectWithoutEmpleadoInput[]
    createMany?: diagnosticoCreateManyEmpleadoInputEnvelope
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
  }

  export type horario_empleadoUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<horario_empleadoCreateWithoutEmpleadoInput, horario_empleadoUncheckedCreateWithoutEmpleadoInput> | horario_empleadoCreateWithoutEmpleadoInput[] | horario_empleadoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: horario_empleadoCreateOrConnectWithoutEmpleadoInput | horario_empleadoCreateOrConnectWithoutEmpleadoInput[]
    createMany?: horario_empleadoCreateManyEmpleadoInputEnvelope
    connect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
  }

  export type orden_trabajoUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<orden_trabajoCreateWithoutEmpleadoInput, orden_trabajoUncheckedCreateWithoutEmpleadoInput> | orden_trabajoCreateWithoutEmpleadoInput[] | orden_trabajoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutEmpleadoInput | orden_trabajoCreateOrConnectWithoutEmpleadoInput[]
    createMany?: orden_trabajoCreateManyEmpleadoInputEnvelope
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
  }

  export type usuarioUncheckedCreateNestedOneWithoutEmpleadoInput = {
    create?: XOR<usuarioCreateWithoutEmpleadoInput, usuarioUncheckedCreateWithoutEmpleadoInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutEmpleadoInput
    connect?: usuarioWhereUniqueInput
  }

  export type diagnosticoUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<diagnosticoCreateWithoutEmpleadoInput, diagnosticoUncheckedCreateWithoutEmpleadoInput> | diagnosticoCreateWithoutEmpleadoInput[] | diagnosticoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutEmpleadoInput | diagnosticoCreateOrConnectWithoutEmpleadoInput[]
    upsert?: diagnosticoUpsertWithWhereUniqueWithoutEmpleadoInput | diagnosticoUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: diagnosticoCreateManyEmpleadoInputEnvelope
    set?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    disconnect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    delete?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    update?: diagnosticoUpdateWithWhereUniqueWithoutEmpleadoInput | diagnosticoUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: diagnosticoUpdateManyWithWhereWithoutEmpleadoInput | diagnosticoUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: diagnosticoScalarWhereInput | diagnosticoScalarWhereInput[]
  }

  export type horario_empleadoUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<horario_empleadoCreateWithoutEmpleadoInput, horario_empleadoUncheckedCreateWithoutEmpleadoInput> | horario_empleadoCreateWithoutEmpleadoInput[] | horario_empleadoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: horario_empleadoCreateOrConnectWithoutEmpleadoInput | horario_empleadoCreateOrConnectWithoutEmpleadoInput[]
    upsert?: horario_empleadoUpsertWithWhereUniqueWithoutEmpleadoInput | horario_empleadoUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: horario_empleadoCreateManyEmpleadoInputEnvelope
    set?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    disconnect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    delete?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    connect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    update?: horario_empleadoUpdateWithWhereUniqueWithoutEmpleadoInput | horario_empleadoUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: horario_empleadoUpdateManyWithWhereWithoutEmpleadoInput | horario_empleadoUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: horario_empleadoScalarWhereInput | horario_empleadoScalarWhereInput[]
  }

  export type orden_trabajoUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<orden_trabajoCreateWithoutEmpleadoInput, orden_trabajoUncheckedCreateWithoutEmpleadoInput> | orden_trabajoCreateWithoutEmpleadoInput[] | orden_trabajoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutEmpleadoInput | orden_trabajoCreateOrConnectWithoutEmpleadoInput[]
    upsert?: orden_trabajoUpsertWithWhereUniqueWithoutEmpleadoInput | orden_trabajoUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: orden_trabajoCreateManyEmpleadoInputEnvelope
    set?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    disconnect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    delete?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    update?: orden_trabajoUpdateWithWhereUniqueWithoutEmpleadoInput | orden_trabajoUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: orden_trabajoUpdateManyWithWhereWithoutEmpleadoInput | orden_trabajoUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: orden_trabajoScalarWhereInput | orden_trabajoScalarWhereInput[]
  }

  export type usuarioUpdateOneWithoutEmpleadoNestedInput = {
    create?: XOR<usuarioCreateWithoutEmpleadoInput, usuarioUncheckedCreateWithoutEmpleadoInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutEmpleadoInput
    upsert?: usuarioUpsertWithoutEmpleadoInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutEmpleadoInput, usuarioUpdateWithoutEmpleadoInput>, usuarioUncheckedUpdateWithoutEmpleadoInput>
  }

  export type diagnosticoUncheckedUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<diagnosticoCreateWithoutEmpleadoInput, diagnosticoUncheckedCreateWithoutEmpleadoInput> | diagnosticoCreateWithoutEmpleadoInput[] | diagnosticoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutEmpleadoInput | diagnosticoCreateOrConnectWithoutEmpleadoInput[]
    upsert?: diagnosticoUpsertWithWhereUniqueWithoutEmpleadoInput | diagnosticoUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: diagnosticoCreateManyEmpleadoInputEnvelope
    set?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    disconnect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    delete?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    update?: diagnosticoUpdateWithWhereUniqueWithoutEmpleadoInput | diagnosticoUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: diagnosticoUpdateManyWithWhereWithoutEmpleadoInput | diagnosticoUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: diagnosticoScalarWhereInput | diagnosticoScalarWhereInput[]
  }

  export type horario_empleadoUncheckedUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<horario_empleadoCreateWithoutEmpleadoInput, horario_empleadoUncheckedCreateWithoutEmpleadoInput> | horario_empleadoCreateWithoutEmpleadoInput[] | horario_empleadoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: horario_empleadoCreateOrConnectWithoutEmpleadoInput | horario_empleadoCreateOrConnectWithoutEmpleadoInput[]
    upsert?: horario_empleadoUpsertWithWhereUniqueWithoutEmpleadoInput | horario_empleadoUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: horario_empleadoCreateManyEmpleadoInputEnvelope
    set?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    disconnect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    delete?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    connect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    update?: horario_empleadoUpdateWithWhereUniqueWithoutEmpleadoInput | horario_empleadoUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: horario_empleadoUpdateManyWithWhereWithoutEmpleadoInput | horario_empleadoUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: horario_empleadoScalarWhereInput | horario_empleadoScalarWhereInput[]
  }

  export type orden_trabajoUncheckedUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<orden_trabajoCreateWithoutEmpleadoInput, orden_trabajoUncheckedCreateWithoutEmpleadoInput> | orden_trabajoCreateWithoutEmpleadoInput[] | orden_trabajoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutEmpleadoInput | orden_trabajoCreateOrConnectWithoutEmpleadoInput[]
    upsert?: orden_trabajoUpsertWithWhereUniqueWithoutEmpleadoInput | orden_trabajoUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: orden_trabajoCreateManyEmpleadoInputEnvelope
    set?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    disconnect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    delete?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    update?: orden_trabajoUpdateWithWhereUniqueWithoutEmpleadoInput | orden_trabajoUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: orden_trabajoUpdateManyWithWhereWithoutEmpleadoInput | orden_trabajoUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: orden_trabajoScalarWhereInput | orden_trabajoScalarWhereInput[]
  }

  export type usuarioUncheckedUpdateOneWithoutEmpleadoNestedInput = {
    create?: XOR<usuarioCreateWithoutEmpleadoInput, usuarioUncheckedCreateWithoutEmpleadoInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutEmpleadoInput
    upsert?: usuarioUpsertWithoutEmpleadoInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutEmpleadoInput, usuarioUpdateWithoutEmpleadoInput>, usuarioUncheckedUpdateWithoutEmpleadoInput>
  }

  export type clienteCreateNestedOneWithoutFacturaInput = {
    create?: XOR<clienteCreateWithoutFacturaInput, clienteUncheckedCreateWithoutFacturaInput>
    connectOrCreate?: clienteCreateOrConnectWithoutFacturaInput
    connect?: clienteWhereUniqueInput
  }

  export type clienteUpdateOneRequiredWithoutFacturaNestedInput = {
    create?: XOR<clienteCreateWithoutFacturaInput, clienteUncheckedCreateWithoutFacturaInput>
    connectOrCreate?: clienteCreateOrConnectWithoutFacturaInput
    upsert?: clienteUpsertWithoutFacturaInput
    connect?: clienteWhereUniqueInput
    update?: XOR<XOR<clienteUpdateToOneWithWhereWithoutFacturaInput, clienteUpdateWithoutFacturaInput>, clienteUncheckedUpdateWithoutFacturaInput>
  }

  export type marca_herramientaCreateNestedOneWithoutHerramientaInput = {
    create?: XOR<marca_herramientaCreateWithoutHerramientaInput, marca_herramientaUncheckedCreateWithoutHerramientaInput>
    connectOrCreate?: marca_herramientaCreateOrConnectWithoutHerramientaInput
    connect?: marca_herramientaWhereUniqueInput
  }

  export type movimiento_herramientaCreateNestedManyWithoutHerramientaInput = {
    create?: XOR<movimiento_herramientaCreateWithoutHerramientaInput, movimiento_herramientaUncheckedCreateWithoutHerramientaInput> | movimiento_herramientaCreateWithoutHerramientaInput[] | movimiento_herramientaUncheckedCreateWithoutHerramientaInput[]
    connectOrCreate?: movimiento_herramientaCreateOrConnectWithoutHerramientaInput | movimiento_herramientaCreateOrConnectWithoutHerramientaInput[]
    createMany?: movimiento_herramientaCreateManyHerramientaInputEnvelope
    connect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
  }

  export type movimiento_herramientaUncheckedCreateNestedManyWithoutHerramientaInput = {
    create?: XOR<movimiento_herramientaCreateWithoutHerramientaInput, movimiento_herramientaUncheckedCreateWithoutHerramientaInput> | movimiento_herramientaCreateWithoutHerramientaInput[] | movimiento_herramientaUncheckedCreateWithoutHerramientaInput[]
    connectOrCreate?: movimiento_herramientaCreateOrConnectWithoutHerramientaInput | movimiento_herramientaCreateOrConnectWithoutHerramientaInput[]
    createMany?: movimiento_herramientaCreateManyHerramientaInputEnvelope
    connect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type marca_herramientaUpdateOneRequiredWithoutHerramientaNestedInput = {
    create?: XOR<marca_herramientaCreateWithoutHerramientaInput, marca_herramientaUncheckedCreateWithoutHerramientaInput>
    connectOrCreate?: marca_herramientaCreateOrConnectWithoutHerramientaInput
    upsert?: marca_herramientaUpsertWithoutHerramientaInput
    connect?: marca_herramientaWhereUniqueInput
    update?: XOR<XOR<marca_herramientaUpdateToOneWithWhereWithoutHerramientaInput, marca_herramientaUpdateWithoutHerramientaInput>, marca_herramientaUncheckedUpdateWithoutHerramientaInput>
  }

  export type movimiento_herramientaUpdateManyWithoutHerramientaNestedInput = {
    create?: XOR<movimiento_herramientaCreateWithoutHerramientaInput, movimiento_herramientaUncheckedCreateWithoutHerramientaInput> | movimiento_herramientaCreateWithoutHerramientaInput[] | movimiento_herramientaUncheckedCreateWithoutHerramientaInput[]
    connectOrCreate?: movimiento_herramientaCreateOrConnectWithoutHerramientaInput | movimiento_herramientaCreateOrConnectWithoutHerramientaInput[]
    upsert?: movimiento_herramientaUpsertWithWhereUniqueWithoutHerramientaInput | movimiento_herramientaUpsertWithWhereUniqueWithoutHerramientaInput[]
    createMany?: movimiento_herramientaCreateManyHerramientaInputEnvelope
    set?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    disconnect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    delete?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    connect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    update?: movimiento_herramientaUpdateWithWhereUniqueWithoutHerramientaInput | movimiento_herramientaUpdateWithWhereUniqueWithoutHerramientaInput[]
    updateMany?: movimiento_herramientaUpdateManyWithWhereWithoutHerramientaInput | movimiento_herramientaUpdateManyWithWhereWithoutHerramientaInput[]
    deleteMany?: movimiento_herramientaScalarWhereInput | movimiento_herramientaScalarWhereInput[]
  }

  export type movimiento_herramientaUncheckedUpdateManyWithoutHerramientaNestedInput = {
    create?: XOR<movimiento_herramientaCreateWithoutHerramientaInput, movimiento_herramientaUncheckedCreateWithoutHerramientaInput> | movimiento_herramientaCreateWithoutHerramientaInput[] | movimiento_herramientaUncheckedCreateWithoutHerramientaInput[]
    connectOrCreate?: movimiento_herramientaCreateOrConnectWithoutHerramientaInput | movimiento_herramientaCreateOrConnectWithoutHerramientaInput[]
    upsert?: movimiento_herramientaUpsertWithWhereUniqueWithoutHerramientaInput | movimiento_herramientaUpsertWithWhereUniqueWithoutHerramientaInput[]
    createMany?: movimiento_herramientaCreateManyHerramientaInputEnvelope
    set?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    disconnect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    delete?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    connect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    update?: movimiento_herramientaUpdateWithWhereUniqueWithoutHerramientaInput | movimiento_herramientaUpdateWithWhereUniqueWithoutHerramientaInput[]
    updateMany?: movimiento_herramientaUpdateManyWithWhereWithoutHerramientaInput | movimiento_herramientaUpdateManyWithWhereWithoutHerramientaInput[]
    deleteMany?: movimiento_herramientaScalarWhereInput | movimiento_herramientaScalarWhereInput[]
  }

  export type horario_empleadoCreateNestedManyWithoutHorarioInput = {
    create?: XOR<horario_empleadoCreateWithoutHorarioInput, horario_empleadoUncheckedCreateWithoutHorarioInput> | horario_empleadoCreateWithoutHorarioInput[] | horario_empleadoUncheckedCreateWithoutHorarioInput[]
    connectOrCreate?: horario_empleadoCreateOrConnectWithoutHorarioInput | horario_empleadoCreateOrConnectWithoutHorarioInput[]
    createMany?: horario_empleadoCreateManyHorarioInputEnvelope
    connect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
  }

  export type horario_empleadoUncheckedCreateNestedManyWithoutHorarioInput = {
    create?: XOR<horario_empleadoCreateWithoutHorarioInput, horario_empleadoUncheckedCreateWithoutHorarioInput> | horario_empleadoCreateWithoutHorarioInput[] | horario_empleadoUncheckedCreateWithoutHorarioInput[]
    connectOrCreate?: horario_empleadoCreateOrConnectWithoutHorarioInput | horario_empleadoCreateOrConnectWithoutHorarioInput[]
    createMany?: horario_empleadoCreateManyHorarioInputEnvelope
    connect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
  }

  export type horario_empleadoUpdateManyWithoutHorarioNestedInput = {
    create?: XOR<horario_empleadoCreateWithoutHorarioInput, horario_empleadoUncheckedCreateWithoutHorarioInput> | horario_empleadoCreateWithoutHorarioInput[] | horario_empleadoUncheckedCreateWithoutHorarioInput[]
    connectOrCreate?: horario_empleadoCreateOrConnectWithoutHorarioInput | horario_empleadoCreateOrConnectWithoutHorarioInput[]
    upsert?: horario_empleadoUpsertWithWhereUniqueWithoutHorarioInput | horario_empleadoUpsertWithWhereUniqueWithoutHorarioInput[]
    createMany?: horario_empleadoCreateManyHorarioInputEnvelope
    set?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    disconnect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    delete?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    connect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    update?: horario_empleadoUpdateWithWhereUniqueWithoutHorarioInput | horario_empleadoUpdateWithWhereUniqueWithoutHorarioInput[]
    updateMany?: horario_empleadoUpdateManyWithWhereWithoutHorarioInput | horario_empleadoUpdateManyWithWhereWithoutHorarioInput[]
    deleteMany?: horario_empleadoScalarWhereInput | horario_empleadoScalarWhereInput[]
  }

  export type horario_empleadoUncheckedUpdateManyWithoutHorarioNestedInput = {
    create?: XOR<horario_empleadoCreateWithoutHorarioInput, horario_empleadoUncheckedCreateWithoutHorarioInput> | horario_empleadoCreateWithoutHorarioInput[] | horario_empleadoUncheckedCreateWithoutHorarioInput[]
    connectOrCreate?: horario_empleadoCreateOrConnectWithoutHorarioInput | horario_empleadoCreateOrConnectWithoutHorarioInput[]
    upsert?: horario_empleadoUpsertWithWhereUniqueWithoutHorarioInput | horario_empleadoUpsertWithWhereUniqueWithoutHorarioInput[]
    createMany?: horario_empleadoCreateManyHorarioInputEnvelope
    set?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    disconnect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    delete?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    connect?: horario_empleadoWhereUniqueInput | horario_empleadoWhereUniqueInput[]
    update?: horario_empleadoUpdateWithWhereUniqueWithoutHorarioInput | horario_empleadoUpdateWithWhereUniqueWithoutHorarioInput[]
    updateMany?: horario_empleadoUpdateManyWithWhereWithoutHorarioInput | horario_empleadoUpdateManyWithWhereWithoutHorarioInput[]
    deleteMany?: horario_empleadoScalarWhereInput | horario_empleadoScalarWhereInput[]
  }

  export type empleadoCreateNestedOneWithoutHorario_empleadoInput = {
    create?: XOR<empleadoCreateWithoutHorario_empleadoInput, empleadoUncheckedCreateWithoutHorario_empleadoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutHorario_empleadoInput
    connect?: empleadoWhereUniqueInput
  }

  export type horarioCreateNestedOneWithoutHorario_empleadoInput = {
    create?: XOR<horarioCreateWithoutHorario_empleadoInput, horarioUncheckedCreateWithoutHorario_empleadoInput>
    connectOrCreate?: horarioCreateOrConnectWithoutHorario_empleadoInput
    connect?: horarioWhereUniqueInput
  }

  export type empleadoUpdateOneRequiredWithoutHorario_empleadoNestedInput = {
    create?: XOR<empleadoCreateWithoutHorario_empleadoInput, empleadoUncheckedCreateWithoutHorario_empleadoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutHorario_empleadoInput
    upsert?: empleadoUpsertWithoutHorario_empleadoInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<XOR<empleadoUpdateToOneWithWhereWithoutHorario_empleadoInput, empleadoUpdateWithoutHorario_empleadoInput>, empleadoUncheckedUpdateWithoutHorario_empleadoInput>
  }

  export type horarioUpdateOneRequiredWithoutHorario_empleadoNestedInput = {
    create?: XOR<horarioCreateWithoutHorario_empleadoInput, horarioUncheckedCreateWithoutHorario_empleadoInput>
    connectOrCreate?: horarioCreateOrConnectWithoutHorario_empleadoInput
    upsert?: horarioUpsertWithoutHorario_empleadoInput
    connect?: horarioWhereUniqueInput
    update?: XOR<XOR<horarioUpdateToOneWithWhereWithoutHorario_empleadoInput, horarioUpdateWithoutHorario_empleadoInput>, horarioUncheckedUpdateWithoutHorario_empleadoInput>
  }

  export type herramientaCreateNestedManyWithoutMarca_herramientaInput = {
    create?: XOR<herramientaCreateWithoutMarca_herramientaInput, herramientaUncheckedCreateWithoutMarca_herramientaInput> | herramientaCreateWithoutMarca_herramientaInput[] | herramientaUncheckedCreateWithoutMarca_herramientaInput[]
    connectOrCreate?: herramientaCreateOrConnectWithoutMarca_herramientaInput | herramientaCreateOrConnectWithoutMarca_herramientaInput[]
    createMany?: herramientaCreateManyMarca_herramientaInputEnvelope
    connect?: herramientaWhereUniqueInput | herramientaWhereUniqueInput[]
  }

  export type herramientaUncheckedCreateNestedManyWithoutMarca_herramientaInput = {
    create?: XOR<herramientaCreateWithoutMarca_herramientaInput, herramientaUncheckedCreateWithoutMarca_herramientaInput> | herramientaCreateWithoutMarca_herramientaInput[] | herramientaUncheckedCreateWithoutMarca_herramientaInput[]
    connectOrCreate?: herramientaCreateOrConnectWithoutMarca_herramientaInput | herramientaCreateOrConnectWithoutMarca_herramientaInput[]
    createMany?: herramientaCreateManyMarca_herramientaInputEnvelope
    connect?: herramientaWhereUniqueInput | herramientaWhereUniqueInput[]
  }

  export type herramientaUpdateManyWithoutMarca_herramientaNestedInput = {
    create?: XOR<herramientaCreateWithoutMarca_herramientaInput, herramientaUncheckedCreateWithoutMarca_herramientaInput> | herramientaCreateWithoutMarca_herramientaInput[] | herramientaUncheckedCreateWithoutMarca_herramientaInput[]
    connectOrCreate?: herramientaCreateOrConnectWithoutMarca_herramientaInput | herramientaCreateOrConnectWithoutMarca_herramientaInput[]
    upsert?: herramientaUpsertWithWhereUniqueWithoutMarca_herramientaInput | herramientaUpsertWithWhereUniqueWithoutMarca_herramientaInput[]
    createMany?: herramientaCreateManyMarca_herramientaInputEnvelope
    set?: herramientaWhereUniqueInput | herramientaWhereUniqueInput[]
    disconnect?: herramientaWhereUniqueInput | herramientaWhereUniqueInput[]
    delete?: herramientaWhereUniqueInput | herramientaWhereUniqueInput[]
    connect?: herramientaWhereUniqueInput | herramientaWhereUniqueInput[]
    update?: herramientaUpdateWithWhereUniqueWithoutMarca_herramientaInput | herramientaUpdateWithWhereUniqueWithoutMarca_herramientaInput[]
    updateMany?: herramientaUpdateManyWithWhereWithoutMarca_herramientaInput | herramientaUpdateManyWithWhereWithoutMarca_herramientaInput[]
    deleteMany?: herramientaScalarWhereInput | herramientaScalarWhereInput[]
  }

  export type herramientaUncheckedUpdateManyWithoutMarca_herramientaNestedInput = {
    create?: XOR<herramientaCreateWithoutMarca_herramientaInput, herramientaUncheckedCreateWithoutMarca_herramientaInput> | herramientaCreateWithoutMarca_herramientaInput[] | herramientaUncheckedCreateWithoutMarca_herramientaInput[]
    connectOrCreate?: herramientaCreateOrConnectWithoutMarca_herramientaInput | herramientaCreateOrConnectWithoutMarca_herramientaInput[]
    upsert?: herramientaUpsertWithWhereUniqueWithoutMarca_herramientaInput | herramientaUpsertWithWhereUniqueWithoutMarca_herramientaInput[]
    createMany?: herramientaCreateManyMarca_herramientaInputEnvelope
    set?: herramientaWhereUniqueInput | herramientaWhereUniqueInput[]
    disconnect?: herramientaWhereUniqueInput | herramientaWhereUniqueInput[]
    delete?: herramientaWhereUniqueInput | herramientaWhereUniqueInput[]
    connect?: herramientaWhereUniqueInput | herramientaWhereUniqueInput[]
    update?: herramientaUpdateWithWhereUniqueWithoutMarca_herramientaInput | herramientaUpdateWithWhereUniqueWithoutMarca_herramientaInput[]
    updateMany?: herramientaUpdateManyWithWhereWithoutMarca_herramientaInput | herramientaUpdateManyWithWhereWithoutMarca_herramientaInput[]
    deleteMany?: herramientaScalarWhereInput | herramientaScalarWhereInput[]
  }

  export type motoCreateNestedManyWithoutMarca_motoInput = {
    create?: XOR<motoCreateWithoutMarca_motoInput, motoUncheckedCreateWithoutMarca_motoInput> | motoCreateWithoutMarca_motoInput[] | motoUncheckedCreateWithoutMarca_motoInput[]
    connectOrCreate?: motoCreateOrConnectWithoutMarca_motoInput | motoCreateOrConnectWithoutMarca_motoInput[]
    createMany?: motoCreateManyMarca_motoInputEnvelope
    connect?: motoWhereUniqueInput | motoWhereUniqueInput[]
  }

  export type motoUncheckedCreateNestedManyWithoutMarca_motoInput = {
    create?: XOR<motoCreateWithoutMarca_motoInput, motoUncheckedCreateWithoutMarca_motoInput> | motoCreateWithoutMarca_motoInput[] | motoUncheckedCreateWithoutMarca_motoInput[]
    connectOrCreate?: motoCreateOrConnectWithoutMarca_motoInput | motoCreateOrConnectWithoutMarca_motoInput[]
    createMany?: motoCreateManyMarca_motoInputEnvelope
    connect?: motoWhereUniqueInput | motoWhereUniqueInput[]
  }

  export type motoUpdateManyWithoutMarca_motoNestedInput = {
    create?: XOR<motoCreateWithoutMarca_motoInput, motoUncheckedCreateWithoutMarca_motoInput> | motoCreateWithoutMarca_motoInput[] | motoUncheckedCreateWithoutMarca_motoInput[]
    connectOrCreate?: motoCreateOrConnectWithoutMarca_motoInput | motoCreateOrConnectWithoutMarca_motoInput[]
    upsert?: motoUpsertWithWhereUniqueWithoutMarca_motoInput | motoUpsertWithWhereUniqueWithoutMarca_motoInput[]
    createMany?: motoCreateManyMarca_motoInputEnvelope
    set?: motoWhereUniqueInput | motoWhereUniqueInput[]
    disconnect?: motoWhereUniqueInput | motoWhereUniqueInput[]
    delete?: motoWhereUniqueInput | motoWhereUniqueInput[]
    connect?: motoWhereUniqueInput | motoWhereUniqueInput[]
    update?: motoUpdateWithWhereUniqueWithoutMarca_motoInput | motoUpdateWithWhereUniqueWithoutMarca_motoInput[]
    updateMany?: motoUpdateManyWithWhereWithoutMarca_motoInput | motoUpdateManyWithWhereWithoutMarca_motoInput[]
    deleteMany?: motoScalarWhereInput | motoScalarWhereInput[]
  }

  export type motoUncheckedUpdateManyWithoutMarca_motoNestedInput = {
    create?: XOR<motoCreateWithoutMarca_motoInput, motoUncheckedCreateWithoutMarca_motoInput> | motoCreateWithoutMarca_motoInput[] | motoUncheckedCreateWithoutMarca_motoInput[]
    connectOrCreate?: motoCreateOrConnectWithoutMarca_motoInput | motoCreateOrConnectWithoutMarca_motoInput[]
    upsert?: motoUpsertWithWhereUniqueWithoutMarca_motoInput | motoUpsertWithWhereUniqueWithoutMarca_motoInput[]
    createMany?: motoCreateManyMarca_motoInputEnvelope
    set?: motoWhereUniqueInput | motoWhereUniqueInput[]
    disconnect?: motoWhereUniqueInput | motoWhereUniqueInput[]
    delete?: motoWhereUniqueInput | motoWhereUniqueInput[]
    connect?: motoWhereUniqueInput | motoWhereUniqueInput[]
    update?: motoUpdateWithWhereUniqueWithoutMarca_motoInput | motoUpdateWithWhereUniqueWithoutMarca_motoInput[]
    updateMany?: motoUpdateManyWithWhereWithoutMarca_motoInput | motoUpdateManyWithWhereWithoutMarca_motoInput[]
    deleteMany?: motoScalarWhereInput | motoScalarWhereInput[]
  }

  export type diagnosticoCreateNestedManyWithoutMotoInput = {
    create?: XOR<diagnosticoCreateWithoutMotoInput, diagnosticoUncheckedCreateWithoutMotoInput> | diagnosticoCreateWithoutMotoInput[] | diagnosticoUncheckedCreateWithoutMotoInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutMotoInput | diagnosticoCreateOrConnectWithoutMotoInput[]
    createMany?: diagnosticoCreateManyMotoInputEnvelope
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
  }

  export type marca_motoCreateNestedOneWithoutMotoInput = {
    create?: XOR<marca_motoCreateWithoutMotoInput, marca_motoUncheckedCreateWithoutMotoInput>
    connectOrCreate?: marca_motoCreateOrConnectWithoutMotoInput
    connect?: marca_motoWhereUniqueInput
  }

  export type diagnosticoUncheckedCreateNestedManyWithoutMotoInput = {
    create?: XOR<diagnosticoCreateWithoutMotoInput, diagnosticoUncheckedCreateWithoutMotoInput> | diagnosticoCreateWithoutMotoInput[] | diagnosticoUncheckedCreateWithoutMotoInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutMotoInput | diagnosticoCreateOrConnectWithoutMotoInput[]
    createMany?: diagnosticoCreateManyMotoInputEnvelope
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
  }

  export type diagnosticoUpdateManyWithoutMotoNestedInput = {
    create?: XOR<diagnosticoCreateWithoutMotoInput, diagnosticoUncheckedCreateWithoutMotoInput> | diagnosticoCreateWithoutMotoInput[] | diagnosticoUncheckedCreateWithoutMotoInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutMotoInput | diagnosticoCreateOrConnectWithoutMotoInput[]
    upsert?: diagnosticoUpsertWithWhereUniqueWithoutMotoInput | diagnosticoUpsertWithWhereUniqueWithoutMotoInput[]
    createMany?: diagnosticoCreateManyMotoInputEnvelope
    set?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    disconnect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    delete?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    update?: diagnosticoUpdateWithWhereUniqueWithoutMotoInput | diagnosticoUpdateWithWhereUniqueWithoutMotoInput[]
    updateMany?: diagnosticoUpdateManyWithWhereWithoutMotoInput | diagnosticoUpdateManyWithWhereWithoutMotoInput[]
    deleteMany?: diagnosticoScalarWhereInput | diagnosticoScalarWhereInput[]
  }

  export type marca_motoUpdateOneRequiredWithoutMotoNestedInput = {
    create?: XOR<marca_motoCreateWithoutMotoInput, marca_motoUncheckedCreateWithoutMotoInput>
    connectOrCreate?: marca_motoCreateOrConnectWithoutMotoInput
    upsert?: marca_motoUpsertWithoutMotoInput
    connect?: marca_motoWhereUniqueInput
    update?: XOR<XOR<marca_motoUpdateToOneWithWhereWithoutMotoInput, marca_motoUpdateWithoutMotoInput>, marca_motoUncheckedUpdateWithoutMotoInput>
  }

  export type diagnosticoUncheckedUpdateManyWithoutMotoNestedInput = {
    create?: XOR<diagnosticoCreateWithoutMotoInput, diagnosticoUncheckedCreateWithoutMotoInput> | diagnosticoCreateWithoutMotoInput[] | diagnosticoUncheckedCreateWithoutMotoInput[]
    connectOrCreate?: diagnosticoCreateOrConnectWithoutMotoInput | diagnosticoCreateOrConnectWithoutMotoInput[]
    upsert?: diagnosticoUpsertWithWhereUniqueWithoutMotoInput | diagnosticoUpsertWithWhereUniqueWithoutMotoInput[]
    createMany?: diagnosticoCreateManyMotoInputEnvelope
    set?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    disconnect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    delete?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    connect?: diagnosticoWhereUniqueInput | diagnosticoWhereUniqueInput[]
    update?: diagnosticoUpdateWithWhereUniqueWithoutMotoInput | diagnosticoUpdateWithWhereUniqueWithoutMotoInput[]
    updateMany?: diagnosticoUpdateManyWithWhereWithoutMotoInput | diagnosticoUpdateManyWithWhereWithoutMotoInput[]
    deleteMany?: diagnosticoScalarWhereInput | diagnosticoScalarWhereInput[]
  }

  export type herramientaCreateNestedOneWithoutMovimiento_herramientaInput = {
    create?: XOR<herramientaCreateWithoutMovimiento_herramientaInput, herramientaUncheckedCreateWithoutMovimiento_herramientaInput>
    connectOrCreate?: herramientaCreateOrConnectWithoutMovimiento_herramientaInput
    connect?: herramientaWhereUniqueInput
  }

  export type orden_trabajoCreateNestedOneWithoutMovimiento_herramientaInput = {
    create?: XOR<orden_trabajoCreateWithoutMovimiento_herramientaInput, orden_trabajoUncheckedCreateWithoutMovimiento_herramientaInput>
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutMovimiento_herramientaInput
    connect?: orden_trabajoWhereUniqueInput
  }

  export type herramientaUpdateOneRequiredWithoutMovimiento_herramientaNestedInput = {
    create?: XOR<herramientaCreateWithoutMovimiento_herramientaInput, herramientaUncheckedCreateWithoutMovimiento_herramientaInput>
    connectOrCreate?: herramientaCreateOrConnectWithoutMovimiento_herramientaInput
    upsert?: herramientaUpsertWithoutMovimiento_herramientaInput
    connect?: herramientaWhereUniqueInput
    update?: XOR<XOR<herramientaUpdateToOneWithWhereWithoutMovimiento_herramientaInput, herramientaUpdateWithoutMovimiento_herramientaInput>, herramientaUncheckedUpdateWithoutMovimiento_herramientaInput>
  }

  export type orden_trabajoUpdateOneRequiredWithoutMovimiento_herramientaNestedInput = {
    create?: XOR<orden_trabajoCreateWithoutMovimiento_herramientaInput, orden_trabajoUncheckedCreateWithoutMovimiento_herramientaInput>
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutMovimiento_herramientaInput
    upsert?: orden_trabajoUpsertWithoutMovimiento_herramientaInput
    connect?: orden_trabajoWhereUniqueInput
    update?: XOR<XOR<orden_trabajoUpdateToOneWithWhereWithoutMovimiento_herramientaInput, orden_trabajoUpdateWithoutMovimiento_herramientaInput>, orden_trabajoUncheckedUpdateWithoutMovimiento_herramientaInput>
  }

  export type comisionCreateNestedOneWithoutOrden_trabajoInput = {
    create?: XOR<comisionCreateWithoutOrden_trabajoInput, comisionUncheckedCreateWithoutOrden_trabajoInput>
    connectOrCreate?: comisionCreateOrConnectWithoutOrden_trabajoInput
    connect?: comisionWhereUniqueInput
  }

  export type movimiento_herramientaCreateNestedManyWithoutOrden_trabajoInput = {
    create?: XOR<movimiento_herramientaCreateWithoutOrden_trabajoInput, movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput> | movimiento_herramientaCreateWithoutOrden_trabajoInput[] | movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput[]
    connectOrCreate?: movimiento_herramientaCreateOrConnectWithoutOrden_trabajoInput | movimiento_herramientaCreateOrConnectWithoutOrden_trabajoInput[]
    createMany?: movimiento_herramientaCreateManyOrden_trabajoInputEnvelope
    connect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
  }

  export type administradorCreateNestedOneWithoutOrden_trabajoInput = {
    create?: XOR<administradorCreateWithoutOrden_trabajoInput, administradorUncheckedCreateWithoutOrden_trabajoInput>
    connectOrCreate?: administradorCreateOrConnectWithoutOrden_trabajoInput
    connect?: administradorWhereUniqueInput
  }

  export type empleadoCreateNestedOneWithoutOrden_trabajoInput = {
    create?: XOR<empleadoCreateWithoutOrden_trabajoInput, empleadoUncheckedCreateWithoutOrden_trabajoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutOrden_trabajoInput
    connect?: empleadoWhereUniqueInput
  }

  export type servicioCreateNestedOneWithoutOrden_trabajoInput = {
    create?: XOR<servicioCreateWithoutOrden_trabajoInput, servicioUncheckedCreateWithoutOrden_trabajoInput>
    connectOrCreate?: servicioCreateOrConnectWithoutOrden_trabajoInput
    connect?: servicioWhereUniqueInput
  }

  export type comisionUncheckedCreateNestedOneWithoutOrden_trabajoInput = {
    create?: XOR<comisionCreateWithoutOrden_trabajoInput, comisionUncheckedCreateWithoutOrden_trabajoInput>
    connectOrCreate?: comisionCreateOrConnectWithoutOrden_trabajoInput
    connect?: comisionWhereUniqueInput
  }

  export type movimiento_herramientaUncheckedCreateNestedManyWithoutOrden_trabajoInput = {
    create?: XOR<movimiento_herramientaCreateWithoutOrden_trabajoInput, movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput> | movimiento_herramientaCreateWithoutOrden_trabajoInput[] | movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput[]
    connectOrCreate?: movimiento_herramientaCreateOrConnectWithoutOrden_trabajoInput | movimiento_herramientaCreateOrConnectWithoutOrden_trabajoInput[]
    createMany?: movimiento_herramientaCreateManyOrden_trabajoInputEnvelope
    connect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
  }

  export type Enumestado_ordenFieldUpdateOperationsInput = {
    set?: $Enums.estado_orden
  }

  export type comisionUpdateOneWithoutOrden_trabajoNestedInput = {
    create?: XOR<comisionCreateWithoutOrden_trabajoInput, comisionUncheckedCreateWithoutOrden_trabajoInput>
    connectOrCreate?: comisionCreateOrConnectWithoutOrden_trabajoInput
    upsert?: comisionUpsertWithoutOrden_trabajoInput
    disconnect?: comisionWhereInput | boolean
    delete?: comisionWhereInput | boolean
    connect?: comisionWhereUniqueInput
    update?: XOR<XOR<comisionUpdateToOneWithWhereWithoutOrden_trabajoInput, comisionUpdateWithoutOrden_trabajoInput>, comisionUncheckedUpdateWithoutOrden_trabajoInput>
  }

  export type movimiento_herramientaUpdateManyWithoutOrden_trabajoNestedInput = {
    create?: XOR<movimiento_herramientaCreateWithoutOrden_trabajoInput, movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput> | movimiento_herramientaCreateWithoutOrden_trabajoInput[] | movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput[]
    connectOrCreate?: movimiento_herramientaCreateOrConnectWithoutOrden_trabajoInput | movimiento_herramientaCreateOrConnectWithoutOrden_trabajoInput[]
    upsert?: movimiento_herramientaUpsertWithWhereUniqueWithoutOrden_trabajoInput | movimiento_herramientaUpsertWithWhereUniqueWithoutOrden_trabajoInput[]
    createMany?: movimiento_herramientaCreateManyOrden_trabajoInputEnvelope
    set?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    disconnect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    delete?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    connect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    update?: movimiento_herramientaUpdateWithWhereUniqueWithoutOrden_trabajoInput | movimiento_herramientaUpdateWithWhereUniqueWithoutOrden_trabajoInput[]
    updateMany?: movimiento_herramientaUpdateManyWithWhereWithoutOrden_trabajoInput | movimiento_herramientaUpdateManyWithWhereWithoutOrden_trabajoInput[]
    deleteMany?: movimiento_herramientaScalarWhereInput | movimiento_herramientaScalarWhereInput[]
  }

  export type administradorUpdateOneWithoutOrden_trabajoNestedInput = {
    create?: XOR<administradorCreateWithoutOrden_trabajoInput, administradorUncheckedCreateWithoutOrden_trabajoInput>
    connectOrCreate?: administradorCreateOrConnectWithoutOrden_trabajoInput
    upsert?: administradorUpsertWithoutOrden_trabajoInput
    disconnect?: administradorWhereInput | boolean
    delete?: administradorWhereInput | boolean
    connect?: administradorWhereUniqueInput
    update?: XOR<XOR<administradorUpdateToOneWithWhereWithoutOrden_trabajoInput, administradorUpdateWithoutOrden_trabajoInput>, administradorUncheckedUpdateWithoutOrden_trabajoInput>
  }

  export type empleadoUpdateOneRequiredWithoutOrden_trabajoNestedInput = {
    create?: XOR<empleadoCreateWithoutOrden_trabajoInput, empleadoUncheckedCreateWithoutOrden_trabajoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutOrden_trabajoInput
    upsert?: empleadoUpsertWithoutOrden_trabajoInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<XOR<empleadoUpdateToOneWithWhereWithoutOrden_trabajoInput, empleadoUpdateWithoutOrden_trabajoInput>, empleadoUncheckedUpdateWithoutOrden_trabajoInput>
  }

  export type servicioUpdateOneRequiredWithoutOrden_trabajoNestedInput = {
    create?: XOR<servicioCreateWithoutOrden_trabajoInput, servicioUncheckedCreateWithoutOrden_trabajoInput>
    connectOrCreate?: servicioCreateOrConnectWithoutOrden_trabajoInput
    upsert?: servicioUpsertWithoutOrden_trabajoInput
    connect?: servicioWhereUniqueInput
    update?: XOR<XOR<servicioUpdateToOneWithWhereWithoutOrden_trabajoInput, servicioUpdateWithoutOrden_trabajoInput>, servicioUncheckedUpdateWithoutOrden_trabajoInput>
  }

  export type comisionUncheckedUpdateOneWithoutOrden_trabajoNestedInput = {
    create?: XOR<comisionCreateWithoutOrden_trabajoInput, comisionUncheckedCreateWithoutOrden_trabajoInput>
    connectOrCreate?: comisionCreateOrConnectWithoutOrden_trabajoInput
    upsert?: comisionUpsertWithoutOrden_trabajoInput
    disconnect?: comisionWhereInput | boolean
    delete?: comisionWhereInput | boolean
    connect?: comisionWhereUniqueInput
    update?: XOR<XOR<comisionUpdateToOneWithWhereWithoutOrden_trabajoInput, comisionUpdateWithoutOrden_trabajoInput>, comisionUncheckedUpdateWithoutOrden_trabajoInput>
  }

  export type movimiento_herramientaUncheckedUpdateManyWithoutOrden_trabajoNestedInput = {
    create?: XOR<movimiento_herramientaCreateWithoutOrden_trabajoInput, movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput> | movimiento_herramientaCreateWithoutOrden_trabajoInput[] | movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput[]
    connectOrCreate?: movimiento_herramientaCreateOrConnectWithoutOrden_trabajoInput | movimiento_herramientaCreateOrConnectWithoutOrden_trabajoInput[]
    upsert?: movimiento_herramientaUpsertWithWhereUniqueWithoutOrden_trabajoInput | movimiento_herramientaUpsertWithWhereUniqueWithoutOrden_trabajoInput[]
    createMany?: movimiento_herramientaCreateManyOrden_trabajoInputEnvelope
    set?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    disconnect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    delete?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    connect?: movimiento_herramientaWhereUniqueInput | movimiento_herramientaWhereUniqueInput[]
    update?: movimiento_herramientaUpdateWithWhereUniqueWithoutOrden_trabajoInput | movimiento_herramientaUpdateWithWhereUniqueWithoutOrden_trabajoInput[]
    updateMany?: movimiento_herramientaUpdateManyWithWhereWithoutOrden_trabajoInput | movimiento_herramientaUpdateManyWithWhereWithoutOrden_trabajoInput[]
    deleteMany?: movimiento_herramientaScalarWhereInput | movimiento_herramientaScalarWhereInput[]
  }

  export type detalle_proformaCreateNestedManyWithoutProformaInput = {
    create?: XOR<detalle_proformaCreateWithoutProformaInput, detalle_proformaUncheckedCreateWithoutProformaInput> | detalle_proformaCreateWithoutProformaInput[] | detalle_proformaUncheckedCreateWithoutProformaInput[]
    connectOrCreate?: detalle_proformaCreateOrConnectWithoutProformaInput | detalle_proformaCreateOrConnectWithoutProformaInput[]
    createMany?: detalle_proformaCreateManyProformaInputEnvelope
    connect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
  }

  export type clienteCreateNestedOneWithoutProformaInput = {
    create?: XOR<clienteCreateWithoutProformaInput, clienteUncheckedCreateWithoutProformaInput>
    connectOrCreate?: clienteCreateOrConnectWithoutProformaInput
    connect?: clienteWhereUniqueInput
  }

  export type diagnosticoCreateNestedOneWithoutProformaInput = {
    create?: XOR<diagnosticoCreateWithoutProformaInput, diagnosticoUncheckedCreateWithoutProformaInput>
    connectOrCreate?: diagnosticoCreateOrConnectWithoutProformaInput
    connect?: diagnosticoWhereUniqueInput
  }

  export type proforma_repuestoCreateNestedManyWithoutProformaInput = {
    create?: XOR<proforma_repuestoCreateWithoutProformaInput, proforma_repuestoUncheckedCreateWithoutProformaInput> | proforma_repuestoCreateWithoutProformaInput[] | proforma_repuestoUncheckedCreateWithoutProformaInput[]
    connectOrCreate?: proforma_repuestoCreateOrConnectWithoutProformaInput | proforma_repuestoCreateOrConnectWithoutProformaInput[]
    createMany?: proforma_repuestoCreateManyProformaInputEnvelope
    connect?: proforma_repuestoWhereUniqueInput | proforma_repuestoWhereUniqueInput[]
  }

  export type detalle_proformaUncheckedCreateNestedManyWithoutProformaInput = {
    create?: XOR<detalle_proformaCreateWithoutProformaInput, detalle_proformaUncheckedCreateWithoutProformaInput> | detalle_proformaCreateWithoutProformaInput[] | detalle_proformaUncheckedCreateWithoutProformaInput[]
    connectOrCreate?: detalle_proformaCreateOrConnectWithoutProformaInput | detalle_proformaCreateOrConnectWithoutProformaInput[]
    createMany?: detalle_proformaCreateManyProformaInputEnvelope
    connect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
  }

  export type proforma_repuestoUncheckedCreateNestedManyWithoutProformaInput = {
    create?: XOR<proforma_repuestoCreateWithoutProformaInput, proforma_repuestoUncheckedCreateWithoutProformaInput> | proforma_repuestoCreateWithoutProformaInput[] | proforma_repuestoUncheckedCreateWithoutProformaInput[]
    connectOrCreate?: proforma_repuestoCreateOrConnectWithoutProformaInput | proforma_repuestoCreateOrConnectWithoutProformaInput[]
    createMany?: proforma_repuestoCreateManyProformaInputEnvelope
    connect?: proforma_repuestoWhereUniqueInput | proforma_repuestoWhereUniqueInput[]
  }

  export type Enumestado_proformaFieldUpdateOperationsInput = {
    set?: $Enums.estado_proforma
  }

  export type detalle_proformaUpdateManyWithoutProformaNestedInput = {
    create?: XOR<detalle_proformaCreateWithoutProformaInput, detalle_proformaUncheckedCreateWithoutProformaInput> | detalle_proformaCreateWithoutProformaInput[] | detalle_proformaUncheckedCreateWithoutProformaInput[]
    connectOrCreate?: detalle_proformaCreateOrConnectWithoutProformaInput | detalle_proformaCreateOrConnectWithoutProformaInput[]
    upsert?: detalle_proformaUpsertWithWhereUniqueWithoutProformaInput | detalle_proformaUpsertWithWhereUniqueWithoutProformaInput[]
    createMany?: detalle_proformaCreateManyProformaInputEnvelope
    set?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    disconnect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    delete?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    connect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    update?: detalle_proformaUpdateWithWhereUniqueWithoutProformaInput | detalle_proformaUpdateWithWhereUniqueWithoutProformaInput[]
    updateMany?: detalle_proformaUpdateManyWithWhereWithoutProformaInput | detalle_proformaUpdateManyWithWhereWithoutProformaInput[]
    deleteMany?: detalle_proformaScalarWhereInput | detalle_proformaScalarWhereInput[]
  }

  export type clienteUpdateOneRequiredWithoutProformaNestedInput = {
    create?: XOR<clienteCreateWithoutProformaInput, clienteUncheckedCreateWithoutProformaInput>
    connectOrCreate?: clienteCreateOrConnectWithoutProformaInput
    upsert?: clienteUpsertWithoutProformaInput
    connect?: clienteWhereUniqueInput
    update?: XOR<XOR<clienteUpdateToOneWithWhereWithoutProformaInput, clienteUpdateWithoutProformaInput>, clienteUncheckedUpdateWithoutProformaInput>
  }

  export type diagnosticoUpdateOneWithoutProformaNestedInput = {
    create?: XOR<diagnosticoCreateWithoutProformaInput, diagnosticoUncheckedCreateWithoutProformaInput>
    connectOrCreate?: diagnosticoCreateOrConnectWithoutProformaInput
    upsert?: diagnosticoUpsertWithoutProformaInput
    disconnect?: diagnosticoWhereInput | boolean
    delete?: diagnosticoWhereInput | boolean
    connect?: diagnosticoWhereUniqueInput
    update?: XOR<XOR<diagnosticoUpdateToOneWithWhereWithoutProformaInput, diagnosticoUpdateWithoutProformaInput>, diagnosticoUncheckedUpdateWithoutProformaInput>
  }

  export type proforma_repuestoUpdateManyWithoutProformaNestedInput = {
    create?: XOR<proforma_repuestoCreateWithoutProformaInput, proforma_repuestoUncheckedCreateWithoutProformaInput> | proforma_repuestoCreateWithoutProformaInput[] | proforma_repuestoUncheckedCreateWithoutProformaInput[]
    connectOrCreate?: proforma_repuestoCreateOrConnectWithoutProformaInput | proforma_repuestoCreateOrConnectWithoutProformaInput[]
    upsert?: proforma_repuestoUpsertWithWhereUniqueWithoutProformaInput | proforma_repuestoUpsertWithWhereUniqueWithoutProformaInput[]
    createMany?: proforma_repuestoCreateManyProformaInputEnvelope
    set?: proforma_repuestoWhereUniqueInput | proforma_repuestoWhereUniqueInput[]
    disconnect?: proforma_repuestoWhereUniqueInput | proforma_repuestoWhereUniqueInput[]
    delete?: proforma_repuestoWhereUniqueInput | proforma_repuestoWhereUniqueInput[]
    connect?: proforma_repuestoWhereUniqueInput | proforma_repuestoWhereUniqueInput[]
    update?: proforma_repuestoUpdateWithWhereUniqueWithoutProformaInput | proforma_repuestoUpdateWithWhereUniqueWithoutProformaInput[]
    updateMany?: proforma_repuestoUpdateManyWithWhereWithoutProformaInput | proforma_repuestoUpdateManyWithWhereWithoutProformaInput[]
    deleteMany?: proforma_repuestoScalarWhereInput | proforma_repuestoScalarWhereInput[]
  }

  export type detalle_proformaUncheckedUpdateManyWithoutProformaNestedInput = {
    create?: XOR<detalle_proformaCreateWithoutProformaInput, detalle_proformaUncheckedCreateWithoutProformaInput> | detalle_proformaCreateWithoutProformaInput[] | detalle_proformaUncheckedCreateWithoutProformaInput[]
    connectOrCreate?: detalle_proformaCreateOrConnectWithoutProformaInput | detalle_proformaCreateOrConnectWithoutProformaInput[]
    upsert?: detalle_proformaUpsertWithWhereUniqueWithoutProformaInput | detalle_proformaUpsertWithWhereUniqueWithoutProformaInput[]
    createMany?: detalle_proformaCreateManyProformaInputEnvelope
    set?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    disconnect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    delete?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    connect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    update?: detalle_proformaUpdateWithWhereUniqueWithoutProformaInput | detalle_proformaUpdateWithWhereUniqueWithoutProformaInput[]
    updateMany?: detalle_proformaUpdateManyWithWhereWithoutProformaInput | detalle_proformaUpdateManyWithWhereWithoutProformaInput[]
    deleteMany?: detalle_proformaScalarWhereInput | detalle_proformaScalarWhereInput[]
  }

  export type proforma_repuestoUncheckedUpdateManyWithoutProformaNestedInput = {
    create?: XOR<proforma_repuestoCreateWithoutProformaInput, proforma_repuestoUncheckedCreateWithoutProformaInput> | proforma_repuestoCreateWithoutProformaInput[] | proforma_repuestoUncheckedCreateWithoutProformaInput[]
    connectOrCreate?: proforma_repuestoCreateOrConnectWithoutProformaInput | proforma_repuestoCreateOrConnectWithoutProformaInput[]
    upsert?: proforma_repuestoUpsertWithWhereUniqueWithoutProformaInput | proforma_repuestoUpsertWithWhereUniqueWithoutProformaInput[]
    createMany?: proforma_repuestoCreateManyProformaInputEnvelope
    set?: proforma_repuestoWhereUniqueInput | proforma_repuestoWhereUniqueInput[]
    disconnect?: proforma_repuestoWhereUniqueInput | proforma_repuestoWhereUniqueInput[]
    delete?: proforma_repuestoWhereUniqueInput | proforma_repuestoWhereUniqueInput[]
    connect?: proforma_repuestoWhereUniqueInput | proforma_repuestoWhereUniqueInput[]
    update?: proforma_repuestoUpdateWithWhereUniqueWithoutProformaInput | proforma_repuestoUpdateWithWhereUniqueWithoutProformaInput[]
    updateMany?: proforma_repuestoUpdateManyWithWhereWithoutProformaInput | proforma_repuestoUpdateManyWithWhereWithoutProformaInput[]
    deleteMany?: proforma_repuestoScalarWhereInput | proforma_repuestoScalarWhereInput[]
  }

  export type proformaCreateNestedOneWithoutProforma_repuestoInput = {
    create?: XOR<proformaCreateWithoutProforma_repuestoInput, proformaUncheckedCreateWithoutProforma_repuestoInput>
    connectOrCreate?: proformaCreateOrConnectWithoutProforma_repuestoInput
    connect?: proformaWhereUniqueInput
  }

  export type proformaUpdateOneRequiredWithoutProforma_repuestoNestedInput = {
    create?: XOR<proformaCreateWithoutProforma_repuestoInput, proformaUncheckedCreateWithoutProforma_repuestoInput>
    connectOrCreate?: proformaCreateOrConnectWithoutProforma_repuestoInput
    upsert?: proformaUpsertWithoutProforma_repuestoInput
    connect?: proformaWhereUniqueInput
    update?: XOR<XOR<proformaUpdateToOneWithWhereWithoutProforma_repuestoInput, proformaUpdateWithoutProforma_repuestoInput>, proformaUncheckedUpdateWithoutProforma_repuestoInput>
  }

  export type detalle_proformaCreateNestedManyWithoutServicioInput = {
    create?: XOR<detalle_proformaCreateWithoutServicioInput, detalle_proformaUncheckedCreateWithoutServicioInput> | detalle_proformaCreateWithoutServicioInput[] | detalle_proformaUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: detalle_proformaCreateOrConnectWithoutServicioInput | detalle_proformaCreateOrConnectWithoutServicioInput[]
    createMany?: detalle_proformaCreateManyServicioInputEnvelope
    connect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
  }

  export type orden_trabajoCreateNestedManyWithoutServicioInput = {
    create?: XOR<orden_trabajoCreateWithoutServicioInput, orden_trabajoUncheckedCreateWithoutServicioInput> | orden_trabajoCreateWithoutServicioInput[] | orden_trabajoUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutServicioInput | orden_trabajoCreateOrConnectWithoutServicioInput[]
    createMany?: orden_trabajoCreateManyServicioInputEnvelope
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
  }

  export type categoriaCreateNestedOneWithoutServicioInput = {
    create?: XOR<categoriaCreateWithoutServicioInput, categoriaUncheckedCreateWithoutServicioInput>
    connectOrCreate?: categoriaCreateOrConnectWithoutServicioInput
    connect?: categoriaWhereUniqueInput
  }

  export type detalle_proformaUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<detalle_proformaCreateWithoutServicioInput, detalle_proformaUncheckedCreateWithoutServicioInput> | detalle_proformaCreateWithoutServicioInput[] | detalle_proformaUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: detalle_proformaCreateOrConnectWithoutServicioInput | detalle_proformaCreateOrConnectWithoutServicioInput[]
    createMany?: detalle_proformaCreateManyServicioInputEnvelope
    connect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
  }

  export type orden_trabajoUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<orden_trabajoCreateWithoutServicioInput, orden_trabajoUncheckedCreateWithoutServicioInput> | orden_trabajoCreateWithoutServicioInput[] | orden_trabajoUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutServicioInput | orden_trabajoCreateOrConnectWithoutServicioInput[]
    createMany?: orden_trabajoCreateManyServicioInputEnvelope
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
  }

  export type detalle_proformaUpdateManyWithoutServicioNestedInput = {
    create?: XOR<detalle_proformaCreateWithoutServicioInput, detalle_proformaUncheckedCreateWithoutServicioInput> | detalle_proformaCreateWithoutServicioInput[] | detalle_proformaUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: detalle_proformaCreateOrConnectWithoutServicioInput | detalle_proformaCreateOrConnectWithoutServicioInput[]
    upsert?: detalle_proformaUpsertWithWhereUniqueWithoutServicioInput | detalle_proformaUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: detalle_proformaCreateManyServicioInputEnvelope
    set?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    disconnect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    delete?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    connect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    update?: detalle_proformaUpdateWithWhereUniqueWithoutServicioInput | detalle_proformaUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: detalle_proformaUpdateManyWithWhereWithoutServicioInput | detalle_proformaUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: detalle_proformaScalarWhereInput | detalle_proformaScalarWhereInput[]
  }

  export type orden_trabajoUpdateManyWithoutServicioNestedInput = {
    create?: XOR<orden_trabajoCreateWithoutServicioInput, orden_trabajoUncheckedCreateWithoutServicioInput> | orden_trabajoCreateWithoutServicioInput[] | orden_trabajoUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutServicioInput | orden_trabajoCreateOrConnectWithoutServicioInput[]
    upsert?: orden_trabajoUpsertWithWhereUniqueWithoutServicioInput | orden_trabajoUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: orden_trabajoCreateManyServicioInputEnvelope
    set?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    disconnect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    delete?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    update?: orden_trabajoUpdateWithWhereUniqueWithoutServicioInput | orden_trabajoUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: orden_trabajoUpdateManyWithWhereWithoutServicioInput | orden_trabajoUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: orden_trabajoScalarWhereInput | orden_trabajoScalarWhereInput[]
  }

  export type categoriaUpdateOneRequiredWithoutServicioNestedInput = {
    create?: XOR<categoriaCreateWithoutServicioInput, categoriaUncheckedCreateWithoutServicioInput>
    connectOrCreate?: categoriaCreateOrConnectWithoutServicioInput
    upsert?: categoriaUpsertWithoutServicioInput
    connect?: categoriaWhereUniqueInput
    update?: XOR<XOR<categoriaUpdateToOneWithWhereWithoutServicioInput, categoriaUpdateWithoutServicioInput>, categoriaUncheckedUpdateWithoutServicioInput>
  }

  export type detalle_proformaUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<detalle_proformaCreateWithoutServicioInput, detalle_proformaUncheckedCreateWithoutServicioInput> | detalle_proformaCreateWithoutServicioInput[] | detalle_proformaUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: detalle_proformaCreateOrConnectWithoutServicioInput | detalle_proformaCreateOrConnectWithoutServicioInput[]
    upsert?: detalle_proformaUpsertWithWhereUniqueWithoutServicioInput | detalle_proformaUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: detalle_proformaCreateManyServicioInputEnvelope
    set?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    disconnect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    delete?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    connect?: detalle_proformaWhereUniqueInput | detalle_proformaWhereUniqueInput[]
    update?: detalle_proformaUpdateWithWhereUniqueWithoutServicioInput | detalle_proformaUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: detalle_proformaUpdateManyWithWhereWithoutServicioInput | detalle_proformaUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: detalle_proformaScalarWhereInput | detalle_proformaScalarWhereInput[]
  }

  export type orden_trabajoUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<orden_trabajoCreateWithoutServicioInput, orden_trabajoUncheckedCreateWithoutServicioInput> | orden_trabajoCreateWithoutServicioInput[] | orden_trabajoUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: orden_trabajoCreateOrConnectWithoutServicioInput | orden_trabajoCreateOrConnectWithoutServicioInput[]
    upsert?: orden_trabajoUpsertWithWhereUniqueWithoutServicioInput | orden_trabajoUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: orden_trabajoCreateManyServicioInputEnvelope
    set?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    disconnect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    delete?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    connect?: orden_trabajoWhereUniqueInput | orden_trabajoWhereUniqueInput[]
    update?: orden_trabajoUpdateWithWhereUniqueWithoutServicioInput | orden_trabajoUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: orden_trabajoUpdateManyWithWhereWithoutServicioInput | orden_trabajoUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: orden_trabajoScalarWhereInput | orden_trabajoScalarWhereInput[]
  }

  export type administradorCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: administradorCreateOrConnectWithoutUsuarioInput
    connect?: administradorWhereUniqueInput
  }

  export type empleadoCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<empleadoCreateWithoutUsuarioInput, empleadoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutUsuarioInput
    connect?: empleadoWhereUniqueInput
  }

  export type administradorUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: administradorCreateOrConnectWithoutUsuarioInput
    connect?: administradorWhereUniqueInput
  }

  export type administradorUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: administradorCreateOrConnectWithoutUsuarioInput
    upsert?: administradorUpsertWithoutUsuarioInput
    disconnect?: administradorWhereInput | boolean
    delete?: administradorWhereInput | boolean
    connect?: administradorWhereUniqueInput
    update?: XOR<XOR<administradorUpdateToOneWithWhereWithoutUsuarioInput, administradorUpdateWithoutUsuarioInput>, administradorUncheckedUpdateWithoutUsuarioInput>
  }

  export type empleadoUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<empleadoCreateWithoutUsuarioInput, empleadoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutUsuarioInput
    upsert?: empleadoUpsertWithoutUsuarioInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<XOR<empleadoUpdateToOneWithWhereWithoutUsuarioInput, empleadoUpdateWithoutUsuarioInput>, empleadoUncheckedUpdateWithoutUsuarioInput>
  }

  export type administradorUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: administradorCreateOrConnectWithoutUsuarioInput
    upsert?: administradorUpsertWithoutUsuarioInput
    disconnect?: administradorWhereInput | boolean
    delete?: administradorWhereInput | boolean
    connect?: administradorWhereUniqueInput
    update?: XOR<XOR<administradorUpdateToOneWithWhereWithoutUsuarioInput, administradorUpdateWithoutUsuarioInput>, administradorUncheckedUpdateWithoutUsuarioInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumestado_pagoFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_pago | Enumestado_pagoFieldRefInput<$PrismaModel>
    in?: $Enums.estado_pago[] | ListEnumestado_pagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_pago[] | ListEnumestado_pagoFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_pagoFilter<$PrismaModel> | $Enums.estado_pago
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumestado_pagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_pago | Enumestado_pagoFieldRefInput<$PrismaModel>
    in?: $Enums.estado_pago[] | ListEnumestado_pagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_pago[] | ListEnumestado_pagoFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_pagoWithAggregatesFilter<$PrismaModel> | $Enums.estado_pago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumestado_pagoFilter<$PrismaModel>
    _max?: NestedEnumestado_pagoFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumestado_ordenFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_orden | Enumestado_ordenFieldRefInput<$PrismaModel>
    in?: $Enums.estado_orden[] | ListEnumestado_ordenFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_orden[] | ListEnumestado_ordenFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_ordenFilter<$PrismaModel> | $Enums.estado_orden
  }

  export type NestedEnumestado_ordenWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_orden | Enumestado_ordenFieldRefInput<$PrismaModel>
    in?: $Enums.estado_orden[] | ListEnumestado_ordenFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_orden[] | ListEnumestado_ordenFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_ordenWithAggregatesFilter<$PrismaModel> | $Enums.estado_orden
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumestado_ordenFilter<$PrismaModel>
    _max?: NestedEnumestado_ordenFilter<$PrismaModel>
  }

  export type NestedEnumestado_proformaFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_proforma | Enumestado_proformaFieldRefInput<$PrismaModel>
    in?: $Enums.estado_proforma[] | ListEnumestado_proformaFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_proforma[] | ListEnumestado_proformaFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_proformaFilter<$PrismaModel> | $Enums.estado_proforma
  }

  export type NestedEnumestado_proformaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.estado_proforma | Enumestado_proformaFieldRefInput<$PrismaModel>
    in?: $Enums.estado_proforma[] | ListEnumestado_proformaFieldRefInput<$PrismaModel>
    notIn?: $Enums.estado_proforma[] | ListEnumestado_proformaFieldRefInput<$PrismaModel>
    not?: NestedEnumestado_proformaWithAggregatesFilter<$PrismaModel> | $Enums.estado_proforma
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumestado_proformaFilter<$PrismaModel>
    _max?: NestedEnumestado_proformaFilter<$PrismaModel>
  }

  export type usuarioCreateWithoutAdministradorInput = {
    usuario: string
    contrasena: string
    email?: string | null
    empleado: empleadoCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutAdministradorInput = {
    id?: number
    empleado_ci: number
    usuario: string
    contrasena: string
    email?: string | null
  }

  export type usuarioCreateOrConnectWithoutAdministradorInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutAdministradorInput, usuarioUncheckedCreateWithoutAdministradorInput>
  }

  export type orden_trabajoCreateWithoutAdministradorInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    comision?: comisionCreateNestedOneWithoutOrden_trabajoInput
    movimiento_herramienta?: movimiento_herramientaCreateNestedManyWithoutOrden_trabajoInput
    empleado: empleadoCreateNestedOneWithoutOrden_trabajoInput
    servicio: servicioCreateNestedOneWithoutOrden_trabajoInput
  }

  export type orden_trabajoUncheckedCreateWithoutAdministradorInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    empleado_ci: number
    servicio_id: number
    comision?: comisionUncheckedCreateNestedOneWithoutOrden_trabajoInput
    movimiento_herramienta?: movimiento_herramientaUncheckedCreateNestedManyWithoutOrden_trabajoInput
  }

  export type orden_trabajoCreateOrConnectWithoutAdministradorInput = {
    where: orden_trabajoWhereUniqueInput
    create: XOR<orden_trabajoCreateWithoutAdministradorInput, orden_trabajoUncheckedCreateWithoutAdministradorInput>
  }

  export type orden_trabajoCreateManyAdministradorInputEnvelope = {
    data: orden_trabajoCreateManyAdministradorInput | orden_trabajoCreateManyAdministradorInput[]
    skipDuplicates?: boolean
  }

  export type usuarioUpsertWithoutAdministradorInput = {
    update: XOR<usuarioUpdateWithoutAdministradorInput, usuarioUncheckedUpdateWithoutAdministradorInput>
    create: XOR<usuarioCreateWithoutAdministradorInput, usuarioUncheckedCreateWithoutAdministradorInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutAdministradorInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutAdministradorInput, usuarioUncheckedUpdateWithoutAdministradorInput>
  }

  export type usuarioUpdateWithoutAdministradorInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    empleado?: empleadoUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutAdministradorInput = {
    id?: IntFieldUpdateOperationsInput | number
    empleado_ci?: IntFieldUpdateOperationsInput | number
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type orden_trabajoUpsertWithWhereUniqueWithoutAdministradorInput = {
    where: orden_trabajoWhereUniqueInput
    update: XOR<orden_trabajoUpdateWithoutAdministradorInput, orden_trabajoUncheckedUpdateWithoutAdministradorInput>
    create: XOR<orden_trabajoCreateWithoutAdministradorInput, orden_trabajoUncheckedCreateWithoutAdministradorInput>
  }

  export type orden_trabajoUpdateWithWhereUniqueWithoutAdministradorInput = {
    where: orden_trabajoWhereUniqueInput
    data: XOR<orden_trabajoUpdateWithoutAdministradorInput, orden_trabajoUncheckedUpdateWithoutAdministradorInput>
  }

  export type orden_trabajoUpdateManyWithWhereWithoutAdministradorInput = {
    where: orden_trabajoScalarWhereInput
    data: XOR<orden_trabajoUpdateManyMutationInput, orden_trabajoUncheckedUpdateManyWithoutAdministradorInput>
  }

  export type orden_trabajoScalarWhereInput = {
    AND?: orden_trabajoScalarWhereInput | orden_trabajoScalarWhereInput[]
    OR?: orden_trabajoScalarWhereInput[]
    NOT?: orden_trabajoScalarWhereInput | orden_trabajoScalarWhereInput[]
    id?: BigIntFilter<"orden_trabajo"> | bigint | number
    fecha_inicio?: DateTimeFilter<"orden_trabajo"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"orden_trabajo"> | Date | string | null
    estado?: Enumestado_ordenFilter<"orden_trabajo"> | $Enums.estado_orden
    empleado_ci?: IntFilter<"orden_trabajo"> | number
    administrador_id?: IntNullableFilter<"orden_trabajo"> | number | null
    servicio_id?: IntFilter<"orden_trabajo"> | number
  }

  export type servicioCreateWithoutCategoriaInput = {
    descripcion: string
    detalle_proforma?: detalle_proformaCreateNestedManyWithoutServicioInput
    orden_trabajo?: orden_trabajoCreateNestedManyWithoutServicioInput
  }

  export type servicioUncheckedCreateWithoutCategoriaInput = {
    id?: number
    descripcion: string
    detalle_proforma?: detalle_proformaUncheckedCreateNestedManyWithoutServicioInput
    orden_trabajo?: orden_trabajoUncheckedCreateNestedManyWithoutServicioInput
  }

  export type servicioCreateOrConnectWithoutCategoriaInput = {
    where: servicioWhereUniqueInput
    create: XOR<servicioCreateWithoutCategoriaInput, servicioUncheckedCreateWithoutCategoriaInput>
  }

  export type servicioCreateManyCategoriaInputEnvelope = {
    data: servicioCreateManyCategoriaInput | servicioCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type servicioUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: servicioWhereUniqueInput
    update: XOR<servicioUpdateWithoutCategoriaInput, servicioUncheckedUpdateWithoutCategoriaInput>
    create: XOR<servicioCreateWithoutCategoriaInput, servicioUncheckedCreateWithoutCategoriaInput>
  }

  export type servicioUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: servicioWhereUniqueInput
    data: XOR<servicioUpdateWithoutCategoriaInput, servicioUncheckedUpdateWithoutCategoriaInput>
  }

  export type servicioUpdateManyWithWhereWithoutCategoriaInput = {
    where: servicioScalarWhereInput
    data: XOR<servicioUpdateManyMutationInput, servicioUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type servicioScalarWhereInput = {
    AND?: servicioScalarWhereInput | servicioScalarWhereInput[]
    OR?: servicioScalarWhereInput[]
    NOT?: servicioScalarWhereInput | servicioScalarWhereInput[]
    id?: IntFilter<"servicio"> | number
    descripcion?: StringFilter<"servicio"> | string
    categoria_id?: IntFilter<"servicio"> | number
  }

  export type facturaCreateWithoutClienteInput = {
    id?: bigint | number
    monto: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
  }

  export type facturaUncheckedCreateWithoutClienteInput = {
    id?: bigint | number
    monto: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
  }

  export type facturaCreateOrConnectWithoutClienteInput = {
    where: facturaWhereUniqueInput
    create: XOR<facturaCreateWithoutClienteInput, facturaUncheckedCreateWithoutClienteInput>
  }

  export type facturaCreateManyClienteInputEnvelope = {
    data: facturaCreateManyClienteInput | facturaCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type proformaCreateWithoutClienteInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    detalle_proforma?: detalle_proformaCreateNestedManyWithoutProformaInput
    diagnostico?: diagnosticoCreateNestedOneWithoutProformaInput
    proforma_repuesto?: proforma_repuestoCreateNestedManyWithoutProformaInput
  }

  export type proformaUncheckedCreateWithoutClienteInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    diagnostico_id?: bigint | number | null
    detalle_proforma?: detalle_proformaUncheckedCreateNestedManyWithoutProformaInput
    proforma_repuesto?: proforma_repuestoUncheckedCreateNestedManyWithoutProformaInput
  }

  export type proformaCreateOrConnectWithoutClienteInput = {
    where: proformaWhereUniqueInput
    create: XOR<proformaCreateWithoutClienteInput, proformaUncheckedCreateWithoutClienteInput>
  }

  export type proformaCreateManyClienteInputEnvelope = {
    data: proformaCreateManyClienteInput | proformaCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type facturaUpsertWithWhereUniqueWithoutClienteInput = {
    where: facturaWhereUniqueInput
    update: XOR<facturaUpdateWithoutClienteInput, facturaUncheckedUpdateWithoutClienteInput>
    create: XOR<facturaCreateWithoutClienteInput, facturaUncheckedCreateWithoutClienteInput>
  }

  export type facturaUpdateWithWhereUniqueWithoutClienteInput = {
    where: facturaWhereUniqueInput
    data: XOR<facturaUpdateWithoutClienteInput, facturaUncheckedUpdateWithoutClienteInput>
  }

  export type facturaUpdateManyWithWhereWithoutClienteInput = {
    where: facturaScalarWhereInput
    data: XOR<facturaUpdateManyMutationInput, facturaUncheckedUpdateManyWithoutClienteInput>
  }

  export type facturaScalarWhereInput = {
    AND?: facturaScalarWhereInput | facturaScalarWhereInput[]
    OR?: facturaScalarWhereInput[]
    NOT?: facturaScalarWhereInput | facturaScalarWhereInput[]
    id?: BigIntFilter<"factura"> | bigint | number
    monto?: DecimalFilter<"factura"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"factura"> | Date | string
    cliente_ci?: IntFilter<"factura"> | number
  }

  export type proformaUpsertWithWhereUniqueWithoutClienteInput = {
    where: proformaWhereUniqueInput
    update: XOR<proformaUpdateWithoutClienteInput, proformaUncheckedUpdateWithoutClienteInput>
    create: XOR<proformaCreateWithoutClienteInput, proformaUncheckedCreateWithoutClienteInput>
  }

  export type proformaUpdateWithWhereUniqueWithoutClienteInput = {
    where: proformaWhereUniqueInput
    data: XOR<proformaUpdateWithoutClienteInput, proformaUncheckedUpdateWithoutClienteInput>
  }

  export type proformaUpdateManyWithWhereWithoutClienteInput = {
    where: proformaScalarWhereInput
    data: XOR<proformaUpdateManyMutationInput, proformaUncheckedUpdateManyWithoutClienteInput>
  }

  export type proformaScalarWhereInput = {
    AND?: proformaScalarWhereInput | proformaScalarWhereInput[]
    OR?: proformaScalarWhereInput[]
    NOT?: proformaScalarWhereInput | proformaScalarWhereInput[]
    id?: BigIntFilter<"proforma"> | bigint | number
    fecha?: DateTimeFilter<"proforma"> | Date | string
    estado?: Enumestado_proformaFilter<"proforma"> | $Enums.estado_proforma
    total?: DecimalFilter<"proforma"> | Decimal | DecimalJsLike | number | string
    cliente_ci?: IntFilter<"proforma"> | number
    diagnostico_id?: BigIntNullableFilter<"proforma"> | bigint | number | null
  }

  export type orden_trabajoCreateWithoutComisionInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    movimiento_herramienta?: movimiento_herramientaCreateNestedManyWithoutOrden_trabajoInput
    administrador?: administradorCreateNestedOneWithoutOrden_trabajoInput
    empleado: empleadoCreateNestedOneWithoutOrden_trabajoInput
    servicio: servicioCreateNestedOneWithoutOrden_trabajoInput
  }

  export type orden_trabajoUncheckedCreateWithoutComisionInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    empleado_ci: number
    administrador_id?: number | null
    servicio_id: number
    movimiento_herramienta?: movimiento_herramientaUncheckedCreateNestedManyWithoutOrden_trabajoInput
  }

  export type orden_trabajoCreateOrConnectWithoutComisionInput = {
    where: orden_trabajoWhereUniqueInput
    create: XOR<orden_trabajoCreateWithoutComisionInput, orden_trabajoUncheckedCreateWithoutComisionInput>
  }

  export type orden_trabajoUpsertWithoutComisionInput = {
    update: XOR<orden_trabajoUpdateWithoutComisionInput, orden_trabajoUncheckedUpdateWithoutComisionInput>
    create: XOR<orden_trabajoCreateWithoutComisionInput, orden_trabajoUncheckedCreateWithoutComisionInput>
    where?: orden_trabajoWhereInput
  }

  export type orden_trabajoUpdateToOneWithWhereWithoutComisionInput = {
    where?: orden_trabajoWhereInput
    data: XOR<orden_trabajoUpdateWithoutComisionInput, orden_trabajoUncheckedUpdateWithoutComisionInput>
  }

  export type orden_trabajoUpdateWithoutComisionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    movimiento_herramienta?: movimiento_herramientaUpdateManyWithoutOrden_trabajoNestedInput
    administrador?: administradorUpdateOneWithoutOrden_trabajoNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutOrden_trabajoNestedInput
    servicio?: servicioUpdateOneRequiredWithoutOrden_trabajoNestedInput
  }

  export type orden_trabajoUncheckedUpdateWithoutComisionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    empleado_ci?: IntFieldUpdateOperationsInput | number
    administrador_id?: NullableIntFieldUpdateOperationsInput | number | null
    servicio_id?: IntFieldUpdateOperationsInput | number
    movimiento_herramienta?: movimiento_herramientaUncheckedUpdateManyWithoutOrden_trabajoNestedInput
  }

  export type diagnosticoCreateWithoutDetalle_diagnosticoInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    empleado: empleadoCreateNestedOneWithoutDiagnosticoInput
    moto: motoCreateNestedOneWithoutDiagnosticoInput
    proforma?: proformaCreateNestedOneWithoutDiagnosticoInput
  }

  export type diagnosticoUncheckedCreateWithoutDetalle_diagnosticoInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    placa_moto: string
    empleado_ci: number
    proforma?: proformaUncheckedCreateNestedOneWithoutDiagnosticoInput
  }

  export type diagnosticoCreateOrConnectWithoutDetalle_diagnosticoInput = {
    where: diagnosticoWhereUniqueInput
    create: XOR<diagnosticoCreateWithoutDetalle_diagnosticoInput, diagnosticoUncheckedCreateWithoutDetalle_diagnosticoInput>
  }

  export type diagnosticoUpsertWithoutDetalle_diagnosticoInput = {
    update: XOR<diagnosticoUpdateWithoutDetalle_diagnosticoInput, diagnosticoUncheckedUpdateWithoutDetalle_diagnosticoInput>
    create: XOR<diagnosticoCreateWithoutDetalle_diagnosticoInput, diagnosticoUncheckedCreateWithoutDetalle_diagnosticoInput>
    where?: diagnosticoWhereInput
  }

  export type diagnosticoUpdateToOneWithWhereWithoutDetalle_diagnosticoInput = {
    where?: diagnosticoWhereInput
    data: XOR<diagnosticoUpdateWithoutDetalle_diagnosticoInput, diagnosticoUncheckedUpdateWithoutDetalle_diagnosticoInput>
  }

  export type diagnosticoUpdateWithoutDetalle_diagnosticoInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    empleado?: empleadoUpdateOneRequiredWithoutDiagnosticoNestedInput
    moto?: motoUpdateOneRequiredWithoutDiagnosticoNestedInput
    proforma?: proformaUpdateOneWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateWithoutDetalle_diagnosticoInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    placa_moto?: StringFieldUpdateOperationsInput | string
    empleado_ci?: IntFieldUpdateOperationsInput | number
    proforma?: proformaUncheckedUpdateOneWithoutDiagnosticoNestedInput
  }

  export type proformaCreateWithoutDetalle_proformaInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    cliente: clienteCreateNestedOneWithoutProformaInput
    diagnostico?: diagnosticoCreateNestedOneWithoutProformaInput
    proforma_repuesto?: proforma_repuestoCreateNestedManyWithoutProformaInput
  }

  export type proformaUncheckedCreateWithoutDetalle_proformaInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    cliente_ci: number
    diagnostico_id?: bigint | number | null
    proforma_repuesto?: proforma_repuestoUncheckedCreateNestedManyWithoutProformaInput
  }

  export type proformaCreateOrConnectWithoutDetalle_proformaInput = {
    where: proformaWhereUniqueInput
    create: XOR<proformaCreateWithoutDetalle_proformaInput, proformaUncheckedCreateWithoutDetalle_proformaInput>
  }

  export type servicioCreateWithoutDetalle_proformaInput = {
    descripcion: string
    orden_trabajo?: orden_trabajoCreateNestedManyWithoutServicioInput
    categoria: categoriaCreateNestedOneWithoutServicioInput
  }

  export type servicioUncheckedCreateWithoutDetalle_proformaInput = {
    id?: number
    descripcion: string
    categoria_id: number
    orden_trabajo?: orden_trabajoUncheckedCreateNestedManyWithoutServicioInput
  }

  export type servicioCreateOrConnectWithoutDetalle_proformaInput = {
    where: servicioWhereUniqueInput
    create: XOR<servicioCreateWithoutDetalle_proformaInput, servicioUncheckedCreateWithoutDetalle_proformaInput>
  }

  export type proformaUpsertWithoutDetalle_proformaInput = {
    update: XOR<proformaUpdateWithoutDetalle_proformaInput, proformaUncheckedUpdateWithoutDetalle_proformaInput>
    create: XOR<proformaCreateWithoutDetalle_proformaInput, proformaUncheckedCreateWithoutDetalle_proformaInput>
    where?: proformaWhereInput
  }

  export type proformaUpdateToOneWithWhereWithoutDetalle_proformaInput = {
    where?: proformaWhereInput
    data: XOR<proformaUpdateWithoutDetalle_proformaInput, proformaUncheckedUpdateWithoutDetalle_proformaInput>
  }

  export type proformaUpdateWithoutDetalle_proformaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente?: clienteUpdateOneRequiredWithoutProformaNestedInput
    diagnostico?: diagnosticoUpdateOneWithoutProformaNestedInput
    proforma_repuesto?: proforma_repuestoUpdateManyWithoutProformaNestedInput
  }

  export type proformaUncheckedUpdateWithoutDetalle_proformaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_ci?: IntFieldUpdateOperationsInput | number
    diagnostico_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    proforma_repuesto?: proforma_repuestoUncheckedUpdateManyWithoutProformaNestedInput
  }

  export type servicioUpsertWithoutDetalle_proformaInput = {
    update: XOR<servicioUpdateWithoutDetalle_proformaInput, servicioUncheckedUpdateWithoutDetalle_proformaInput>
    create: XOR<servicioCreateWithoutDetalle_proformaInput, servicioUncheckedCreateWithoutDetalle_proformaInput>
    where?: servicioWhereInput
  }

  export type servicioUpdateToOneWithWhereWithoutDetalle_proformaInput = {
    where?: servicioWhereInput
    data: XOR<servicioUpdateWithoutDetalle_proformaInput, servicioUncheckedUpdateWithoutDetalle_proformaInput>
  }

  export type servicioUpdateWithoutDetalle_proformaInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    orden_trabajo?: orden_trabajoUpdateManyWithoutServicioNestedInput
    categoria?: categoriaUpdateOneRequiredWithoutServicioNestedInput
  }

  export type servicioUncheckedUpdateWithoutDetalle_proformaInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria_id?: IntFieldUpdateOperationsInput | number
    orden_trabajo?: orden_trabajoUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type detalle_diagnosticoCreateWithoutDiagnosticoInput = {
    id?: bigint | number
    descripcion: string
  }

  export type detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput = {
    id?: bigint | number
    descripcion: string
  }

  export type detalle_diagnosticoCreateOrConnectWithoutDiagnosticoInput = {
    where: detalle_diagnosticoWhereUniqueInput
    create: XOR<detalle_diagnosticoCreateWithoutDiagnosticoInput, detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput>
  }

  export type detalle_diagnosticoCreateManyDiagnosticoInputEnvelope = {
    data: detalle_diagnosticoCreateManyDiagnosticoInput | detalle_diagnosticoCreateManyDiagnosticoInput[]
    skipDuplicates?: boolean
  }

  export type empleadoCreateWithoutDiagnosticoInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
    horario_empleado?: horario_empleadoCreateNestedManyWithoutEmpleadoInput
    orden_trabajo?: orden_trabajoCreateNestedManyWithoutEmpleadoInput
    usuario?: usuarioCreateNestedOneWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutDiagnosticoInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
    horario_empleado?: horario_empleadoUncheckedCreateNestedManyWithoutEmpleadoInput
    orden_trabajo?: orden_trabajoUncheckedCreateNestedManyWithoutEmpleadoInput
    usuario?: usuarioUncheckedCreateNestedOneWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutDiagnosticoInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutDiagnosticoInput, empleadoUncheckedCreateWithoutDiagnosticoInput>
  }

  export type motoCreateWithoutDiagnosticoInput = {
    placa: string
    modelo: string
    year: number
    chasis?: string | null
    marca_moto: marca_motoCreateNestedOneWithoutMotoInput
  }

  export type motoUncheckedCreateWithoutDiagnosticoInput = {
    placa: string
    modelo: string
    year: number
    chasis?: string | null
    marca_id: number
  }

  export type motoCreateOrConnectWithoutDiagnosticoInput = {
    where: motoWhereUniqueInput
    create: XOR<motoCreateWithoutDiagnosticoInput, motoUncheckedCreateWithoutDiagnosticoInput>
  }

  export type proformaCreateWithoutDiagnosticoInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    detalle_proforma?: detalle_proformaCreateNestedManyWithoutProformaInput
    cliente: clienteCreateNestedOneWithoutProformaInput
    proforma_repuesto?: proforma_repuestoCreateNestedManyWithoutProformaInput
  }

  export type proformaUncheckedCreateWithoutDiagnosticoInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    cliente_ci: number
    detalle_proforma?: detalle_proformaUncheckedCreateNestedManyWithoutProformaInput
    proforma_repuesto?: proforma_repuestoUncheckedCreateNestedManyWithoutProformaInput
  }

  export type proformaCreateOrConnectWithoutDiagnosticoInput = {
    where: proformaWhereUniqueInput
    create: XOR<proformaCreateWithoutDiagnosticoInput, proformaUncheckedCreateWithoutDiagnosticoInput>
  }

  export type detalle_diagnosticoUpsertWithWhereUniqueWithoutDiagnosticoInput = {
    where: detalle_diagnosticoWhereUniqueInput
    update: XOR<detalle_diagnosticoUpdateWithoutDiagnosticoInput, detalle_diagnosticoUncheckedUpdateWithoutDiagnosticoInput>
    create: XOR<detalle_diagnosticoCreateWithoutDiagnosticoInput, detalle_diagnosticoUncheckedCreateWithoutDiagnosticoInput>
  }

  export type detalle_diagnosticoUpdateWithWhereUniqueWithoutDiagnosticoInput = {
    where: detalle_diagnosticoWhereUniqueInput
    data: XOR<detalle_diagnosticoUpdateWithoutDiagnosticoInput, detalle_diagnosticoUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type detalle_diagnosticoUpdateManyWithWhereWithoutDiagnosticoInput = {
    where: detalle_diagnosticoScalarWhereInput
    data: XOR<detalle_diagnosticoUpdateManyMutationInput, detalle_diagnosticoUncheckedUpdateManyWithoutDiagnosticoInput>
  }

  export type detalle_diagnosticoScalarWhereInput = {
    AND?: detalle_diagnosticoScalarWhereInput | detalle_diagnosticoScalarWhereInput[]
    OR?: detalle_diagnosticoScalarWhereInput[]
    NOT?: detalle_diagnosticoScalarWhereInput | detalle_diagnosticoScalarWhereInput[]
    id?: BigIntFilter<"detalle_diagnostico"> | bigint | number
    diagnostico_id?: BigIntFilter<"detalle_diagnostico"> | bigint | number
    descripcion?: StringFilter<"detalle_diagnostico"> | string
  }

  export type empleadoUpsertWithoutDiagnosticoInput = {
    update: XOR<empleadoUpdateWithoutDiagnosticoInput, empleadoUncheckedUpdateWithoutDiagnosticoInput>
    create: XOR<empleadoCreateWithoutDiagnosticoInput, empleadoUncheckedCreateWithoutDiagnosticoInput>
    where?: empleadoWhereInput
  }

  export type empleadoUpdateToOneWithWhereWithoutDiagnosticoInput = {
    where?: empleadoWhereInput
    data: XOR<empleadoUpdateWithoutDiagnosticoInput, empleadoUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type empleadoUpdateWithoutDiagnosticoInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    horario_empleado?: horario_empleadoUpdateManyWithoutEmpleadoNestedInput
    orden_trabajo?: orden_trabajoUpdateManyWithoutEmpleadoNestedInput
    usuario?: usuarioUpdateOneWithoutEmpleadoNestedInput
  }

  export type empleadoUncheckedUpdateWithoutDiagnosticoInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    horario_empleado?: horario_empleadoUncheckedUpdateManyWithoutEmpleadoNestedInput
    orden_trabajo?: orden_trabajoUncheckedUpdateManyWithoutEmpleadoNestedInput
    usuario?: usuarioUncheckedUpdateOneWithoutEmpleadoNestedInput
  }

  export type motoUpsertWithoutDiagnosticoInput = {
    update: XOR<motoUpdateWithoutDiagnosticoInput, motoUncheckedUpdateWithoutDiagnosticoInput>
    create: XOR<motoCreateWithoutDiagnosticoInput, motoUncheckedCreateWithoutDiagnosticoInput>
    where?: motoWhereInput
  }

  export type motoUpdateToOneWithWhereWithoutDiagnosticoInput = {
    where?: motoWhereInput
    data: XOR<motoUpdateWithoutDiagnosticoInput, motoUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type motoUpdateWithoutDiagnosticoInput = {
    placa?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    marca_moto?: marca_motoUpdateOneRequiredWithoutMotoNestedInput
  }

  export type motoUncheckedUpdateWithoutDiagnosticoInput = {
    placa?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    marca_id?: IntFieldUpdateOperationsInput | number
  }

  export type proformaUpsertWithoutDiagnosticoInput = {
    update: XOR<proformaUpdateWithoutDiagnosticoInput, proformaUncheckedUpdateWithoutDiagnosticoInput>
    create: XOR<proformaCreateWithoutDiagnosticoInput, proformaUncheckedCreateWithoutDiagnosticoInput>
    where?: proformaWhereInput
  }

  export type proformaUpdateToOneWithWhereWithoutDiagnosticoInput = {
    where?: proformaWhereInput
    data: XOR<proformaUpdateWithoutDiagnosticoInput, proformaUncheckedUpdateWithoutDiagnosticoInput>
  }

  export type proformaUpdateWithoutDiagnosticoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_proforma?: detalle_proformaUpdateManyWithoutProformaNestedInput
    cliente?: clienteUpdateOneRequiredWithoutProformaNestedInput
    proforma_repuesto?: proforma_repuestoUpdateManyWithoutProformaNestedInput
  }

  export type proformaUncheckedUpdateWithoutDiagnosticoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_ci?: IntFieldUpdateOperationsInput | number
    detalle_proforma?: detalle_proformaUncheckedUpdateManyWithoutProformaNestedInput
    proforma_repuesto?: proforma_repuestoUncheckedUpdateManyWithoutProformaNestedInput
  }

  export type diagnosticoCreateWithoutEmpleadoInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    detalle_diagnostico?: detalle_diagnosticoCreateNestedManyWithoutDiagnosticoInput
    moto: motoCreateNestedOneWithoutDiagnosticoInput
    proforma?: proformaCreateNestedOneWithoutDiagnosticoInput
  }

  export type diagnosticoUncheckedCreateWithoutEmpleadoInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    placa_moto: string
    detalle_diagnostico?: detalle_diagnosticoUncheckedCreateNestedManyWithoutDiagnosticoInput
    proforma?: proformaUncheckedCreateNestedOneWithoutDiagnosticoInput
  }

  export type diagnosticoCreateOrConnectWithoutEmpleadoInput = {
    where: diagnosticoWhereUniqueInput
    create: XOR<diagnosticoCreateWithoutEmpleadoInput, diagnosticoUncheckedCreateWithoutEmpleadoInput>
  }

  export type diagnosticoCreateManyEmpleadoInputEnvelope = {
    data: diagnosticoCreateManyEmpleadoInput | diagnosticoCreateManyEmpleadoInput[]
    skipDuplicates?: boolean
  }

  export type horario_empleadoCreateWithoutEmpleadoInput = {
    fecha: Date | string
    horario: horarioCreateNestedOneWithoutHorario_empleadoInput
  }

  export type horario_empleadoUncheckedCreateWithoutEmpleadoInput = {
    horario_id: number
    fecha: Date | string
  }

  export type horario_empleadoCreateOrConnectWithoutEmpleadoInput = {
    where: horario_empleadoWhereUniqueInput
    create: XOR<horario_empleadoCreateWithoutEmpleadoInput, horario_empleadoUncheckedCreateWithoutEmpleadoInput>
  }

  export type horario_empleadoCreateManyEmpleadoInputEnvelope = {
    data: horario_empleadoCreateManyEmpleadoInput | horario_empleadoCreateManyEmpleadoInput[]
    skipDuplicates?: boolean
  }

  export type orden_trabajoCreateWithoutEmpleadoInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    comision?: comisionCreateNestedOneWithoutOrden_trabajoInput
    movimiento_herramienta?: movimiento_herramientaCreateNestedManyWithoutOrden_trabajoInput
    administrador?: administradorCreateNestedOneWithoutOrden_trabajoInput
    servicio: servicioCreateNestedOneWithoutOrden_trabajoInput
  }

  export type orden_trabajoUncheckedCreateWithoutEmpleadoInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    administrador_id?: number | null
    servicio_id: number
    comision?: comisionUncheckedCreateNestedOneWithoutOrden_trabajoInput
    movimiento_herramienta?: movimiento_herramientaUncheckedCreateNestedManyWithoutOrden_trabajoInput
  }

  export type orden_trabajoCreateOrConnectWithoutEmpleadoInput = {
    where: orden_trabajoWhereUniqueInput
    create: XOR<orden_trabajoCreateWithoutEmpleadoInput, orden_trabajoUncheckedCreateWithoutEmpleadoInput>
  }

  export type orden_trabajoCreateManyEmpleadoInputEnvelope = {
    data: orden_trabajoCreateManyEmpleadoInput | orden_trabajoCreateManyEmpleadoInput[]
    skipDuplicates?: boolean
  }

  export type usuarioCreateWithoutEmpleadoInput = {
    usuario: string
    contrasena: string
    email?: string | null
    administrador?: administradorCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutEmpleadoInput = {
    id?: number
    usuario: string
    contrasena: string
    email?: string | null
    administrador?: administradorUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutEmpleadoInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutEmpleadoInput, usuarioUncheckedCreateWithoutEmpleadoInput>
  }

  export type diagnosticoUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: diagnosticoWhereUniqueInput
    update: XOR<diagnosticoUpdateWithoutEmpleadoInput, diagnosticoUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<diagnosticoCreateWithoutEmpleadoInput, diagnosticoUncheckedCreateWithoutEmpleadoInput>
  }

  export type diagnosticoUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: diagnosticoWhereUniqueInput
    data: XOR<diagnosticoUpdateWithoutEmpleadoInput, diagnosticoUncheckedUpdateWithoutEmpleadoInput>
  }

  export type diagnosticoUpdateManyWithWhereWithoutEmpleadoInput = {
    where: diagnosticoScalarWhereInput
    data: XOR<diagnosticoUpdateManyMutationInput, diagnosticoUncheckedUpdateManyWithoutEmpleadoInput>
  }

  export type diagnosticoScalarWhereInput = {
    AND?: diagnosticoScalarWhereInput | diagnosticoScalarWhereInput[]
    OR?: diagnosticoScalarWhereInput[]
    NOT?: diagnosticoScalarWhereInput | diagnosticoScalarWhereInput[]
    nro?: BigIntFilter<"diagnostico"> | bigint | number
    fecha?: DateTimeFilter<"diagnostico"> | Date | string
    hora?: DateTimeFilter<"diagnostico"> | Date | string
    placa_moto?: StringFilter<"diagnostico"> | string
    empleado_ci?: IntFilter<"diagnostico"> | number
  }

  export type horario_empleadoUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: horario_empleadoWhereUniqueInput
    update: XOR<horario_empleadoUpdateWithoutEmpleadoInput, horario_empleadoUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<horario_empleadoCreateWithoutEmpleadoInput, horario_empleadoUncheckedCreateWithoutEmpleadoInput>
  }

  export type horario_empleadoUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: horario_empleadoWhereUniqueInput
    data: XOR<horario_empleadoUpdateWithoutEmpleadoInput, horario_empleadoUncheckedUpdateWithoutEmpleadoInput>
  }

  export type horario_empleadoUpdateManyWithWhereWithoutEmpleadoInput = {
    where: horario_empleadoScalarWhereInput
    data: XOR<horario_empleadoUpdateManyMutationInput, horario_empleadoUncheckedUpdateManyWithoutEmpleadoInput>
  }

  export type horario_empleadoScalarWhereInput = {
    AND?: horario_empleadoScalarWhereInput | horario_empleadoScalarWhereInput[]
    OR?: horario_empleadoScalarWhereInput[]
    NOT?: horario_empleadoScalarWhereInput | horario_empleadoScalarWhereInput[]
    empleado_ci?: IntFilter<"horario_empleado"> | number
    horario_id?: IntFilter<"horario_empleado"> | number
    fecha?: DateTimeFilter<"horario_empleado"> | Date | string
  }

  export type orden_trabajoUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: orden_trabajoWhereUniqueInput
    update: XOR<orden_trabajoUpdateWithoutEmpleadoInput, orden_trabajoUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<orden_trabajoCreateWithoutEmpleadoInput, orden_trabajoUncheckedCreateWithoutEmpleadoInput>
  }

  export type orden_trabajoUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: orden_trabajoWhereUniqueInput
    data: XOR<orden_trabajoUpdateWithoutEmpleadoInput, orden_trabajoUncheckedUpdateWithoutEmpleadoInput>
  }

  export type orden_trabajoUpdateManyWithWhereWithoutEmpleadoInput = {
    where: orden_trabajoScalarWhereInput
    data: XOR<orden_trabajoUpdateManyMutationInput, orden_trabajoUncheckedUpdateManyWithoutEmpleadoInput>
  }

  export type usuarioUpsertWithoutEmpleadoInput = {
    update: XOR<usuarioUpdateWithoutEmpleadoInput, usuarioUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<usuarioCreateWithoutEmpleadoInput, usuarioUncheckedCreateWithoutEmpleadoInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutEmpleadoInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutEmpleadoInput, usuarioUncheckedUpdateWithoutEmpleadoInput>
  }

  export type usuarioUpdateWithoutEmpleadoInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    administrador?: administradorUpdateOneWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutEmpleadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    administrador?: administradorUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type clienteCreateWithoutFacturaInput = {
    ci: number
    nombre: string
    telefono: string
    direccion: string
    proforma?: proformaCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateWithoutFacturaInput = {
    ci: number
    nombre: string
    telefono: string
    direccion: string
    proforma?: proformaUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteCreateOrConnectWithoutFacturaInput = {
    where: clienteWhereUniqueInput
    create: XOR<clienteCreateWithoutFacturaInput, clienteUncheckedCreateWithoutFacturaInput>
  }

  export type clienteUpsertWithoutFacturaInput = {
    update: XOR<clienteUpdateWithoutFacturaInput, clienteUncheckedUpdateWithoutFacturaInput>
    create: XOR<clienteCreateWithoutFacturaInput, clienteUncheckedCreateWithoutFacturaInput>
    where?: clienteWhereInput
  }

  export type clienteUpdateToOneWithWhereWithoutFacturaInput = {
    where?: clienteWhereInput
    data: XOR<clienteUpdateWithoutFacturaInput, clienteUncheckedUpdateWithoutFacturaInput>
  }

  export type clienteUpdateWithoutFacturaInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    proforma?: proformaUpdateManyWithoutClienteNestedInput
  }

  export type clienteUncheckedUpdateWithoutFacturaInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    proforma?: proformaUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type marca_herramientaCreateWithoutHerramientaInput = {
    nombre: string
  }

  export type marca_herramientaUncheckedCreateWithoutHerramientaInput = {
    id?: number
    nombre: string
  }

  export type marca_herramientaCreateOrConnectWithoutHerramientaInput = {
    where: marca_herramientaWhereUniqueInput
    create: XOR<marca_herramientaCreateWithoutHerramientaInput, marca_herramientaUncheckedCreateWithoutHerramientaInput>
  }

  export type movimiento_herramientaCreateWithoutHerramientaInput = {
    fecha: Date | string
    cantidad: number
    orden_trabajo: orden_trabajoCreateNestedOneWithoutMovimiento_herramientaInput
  }

  export type movimiento_herramientaUncheckedCreateWithoutHerramientaInput = {
    orden_trabajo_id: bigint | number
    fecha: Date | string
    cantidad: number
  }

  export type movimiento_herramientaCreateOrConnectWithoutHerramientaInput = {
    where: movimiento_herramientaWhereUniqueInput
    create: XOR<movimiento_herramientaCreateWithoutHerramientaInput, movimiento_herramientaUncheckedCreateWithoutHerramientaInput>
  }

  export type movimiento_herramientaCreateManyHerramientaInputEnvelope = {
    data: movimiento_herramientaCreateManyHerramientaInput | movimiento_herramientaCreateManyHerramientaInput[]
    skipDuplicates?: boolean
  }

  export type marca_herramientaUpsertWithoutHerramientaInput = {
    update: XOR<marca_herramientaUpdateWithoutHerramientaInput, marca_herramientaUncheckedUpdateWithoutHerramientaInput>
    create: XOR<marca_herramientaCreateWithoutHerramientaInput, marca_herramientaUncheckedCreateWithoutHerramientaInput>
    where?: marca_herramientaWhereInput
  }

  export type marca_herramientaUpdateToOneWithWhereWithoutHerramientaInput = {
    where?: marca_herramientaWhereInput
    data: XOR<marca_herramientaUpdateWithoutHerramientaInput, marca_herramientaUncheckedUpdateWithoutHerramientaInput>
  }

  export type marca_herramientaUpdateWithoutHerramientaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type marca_herramientaUncheckedUpdateWithoutHerramientaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type movimiento_herramientaUpsertWithWhereUniqueWithoutHerramientaInput = {
    where: movimiento_herramientaWhereUniqueInput
    update: XOR<movimiento_herramientaUpdateWithoutHerramientaInput, movimiento_herramientaUncheckedUpdateWithoutHerramientaInput>
    create: XOR<movimiento_herramientaCreateWithoutHerramientaInput, movimiento_herramientaUncheckedCreateWithoutHerramientaInput>
  }

  export type movimiento_herramientaUpdateWithWhereUniqueWithoutHerramientaInput = {
    where: movimiento_herramientaWhereUniqueInput
    data: XOR<movimiento_herramientaUpdateWithoutHerramientaInput, movimiento_herramientaUncheckedUpdateWithoutHerramientaInput>
  }

  export type movimiento_herramientaUpdateManyWithWhereWithoutHerramientaInput = {
    where: movimiento_herramientaScalarWhereInput
    data: XOR<movimiento_herramientaUpdateManyMutationInput, movimiento_herramientaUncheckedUpdateManyWithoutHerramientaInput>
  }

  export type movimiento_herramientaScalarWhereInput = {
    AND?: movimiento_herramientaScalarWhereInput | movimiento_herramientaScalarWhereInput[]
    OR?: movimiento_herramientaScalarWhereInput[]
    NOT?: movimiento_herramientaScalarWhereInput | movimiento_herramientaScalarWhereInput[]
    herramienta_id?: IntFilter<"movimiento_herramienta"> | number
    orden_trabajo_id?: BigIntFilter<"movimiento_herramienta"> | bigint | number
    fecha?: DateTimeFilter<"movimiento_herramienta"> | Date | string
    cantidad?: IntFilter<"movimiento_herramienta"> | number
  }

  export type horario_empleadoCreateWithoutHorarioInput = {
    fecha: Date | string
    empleado: empleadoCreateNestedOneWithoutHorario_empleadoInput
  }

  export type horario_empleadoUncheckedCreateWithoutHorarioInput = {
    empleado_ci: number
    fecha: Date | string
  }

  export type horario_empleadoCreateOrConnectWithoutHorarioInput = {
    where: horario_empleadoWhereUniqueInput
    create: XOR<horario_empleadoCreateWithoutHorarioInput, horario_empleadoUncheckedCreateWithoutHorarioInput>
  }

  export type horario_empleadoCreateManyHorarioInputEnvelope = {
    data: horario_empleadoCreateManyHorarioInput | horario_empleadoCreateManyHorarioInput[]
    skipDuplicates?: boolean
  }

  export type horario_empleadoUpsertWithWhereUniqueWithoutHorarioInput = {
    where: horario_empleadoWhereUniqueInput
    update: XOR<horario_empleadoUpdateWithoutHorarioInput, horario_empleadoUncheckedUpdateWithoutHorarioInput>
    create: XOR<horario_empleadoCreateWithoutHorarioInput, horario_empleadoUncheckedCreateWithoutHorarioInput>
  }

  export type horario_empleadoUpdateWithWhereUniqueWithoutHorarioInput = {
    where: horario_empleadoWhereUniqueInput
    data: XOR<horario_empleadoUpdateWithoutHorarioInput, horario_empleadoUncheckedUpdateWithoutHorarioInput>
  }

  export type horario_empleadoUpdateManyWithWhereWithoutHorarioInput = {
    where: horario_empleadoScalarWhereInput
    data: XOR<horario_empleadoUpdateManyMutationInput, horario_empleadoUncheckedUpdateManyWithoutHorarioInput>
  }

  export type empleadoCreateWithoutHorario_empleadoInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
    diagnostico?: diagnosticoCreateNestedManyWithoutEmpleadoInput
    orden_trabajo?: orden_trabajoCreateNestedManyWithoutEmpleadoInput
    usuario?: usuarioCreateNestedOneWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutHorario_empleadoInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
    diagnostico?: diagnosticoUncheckedCreateNestedManyWithoutEmpleadoInput
    orden_trabajo?: orden_trabajoUncheckedCreateNestedManyWithoutEmpleadoInput
    usuario?: usuarioUncheckedCreateNestedOneWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutHorario_empleadoInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutHorario_empleadoInput, empleadoUncheckedCreateWithoutHorario_empleadoInput>
  }

  export type horarioCreateWithoutHorario_empleadoInput = {
    hora_inicio: Date | string
    hora_fin: Date | string
  }

  export type horarioUncheckedCreateWithoutHorario_empleadoInput = {
    id?: number
    hora_inicio: Date | string
    hora_fin: Date | string
  }

  export type horarioCreateOrConnectWithoutHorario_empleadoInput = {
    where: horarioWhereUniqueInput
    create: XOR<horarioCreateWithoutHorario_empleadoInput, horarioUncheckedCreateWithoutHorario_empleadoInput>
  }

  export type empleadoUpsertWithoutHorario_empleadoInput = {
    update: XOR<empleadoUpdateWithoutHorario_empleadoInput, empleadoUncheckedUpdateWithoutHorario_empleadoInput>
    create: XOR<empleadoCreateWithoutHorario_empleadoInput, empleadoUncheckedCreateWithoutHorario_empleadoInput>
    where?: empleadoWhereInput
  }

  export type empleadoUpdateToOneWithWhereWithoutHorario_empleadoInput = {
    where?: empleadoWhereInput
    data: XOR<empleadoUpdateWithoutHorario_empleadoInput, empleadoUncheckedUpdateWithoutHorario_empleadoInput>
  }

  export type empleadoUpdateWithoutHorario_empleadoInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    diagnostico?: diagnosticoUpdateManyWithoutEmpleadoNestedInput
    orden_trabajo?: orden_trabajoUpdateManyWithoutEmpleadoNestedInput
    usuario?: usuarioUpdateOneWithoutEmpleadoNestedInput
  }

  export type empleadoUncheckedUpdateWithoutHorario_empleadoInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    diagnostico?: diagnosticoUncheckedUpdateManyWithoutEmpleadoNestedInput
    orden_trabajo?: orden_trabajoUncheckedUpdateManyWithoutEmpleadoNestedInput
    usuario?: usuarioUncheckedUpdateOneWithoutEmpleadoNestedInput
  }

  export type horarioUpsertWithoutHorario_empleadoInput = {
    update: XOR<horarioUpdateWithoutHorario_empleadoInput, horarioUncheckedUpdateWithoutHorario_empleadoInput>
    create: XOR<horarioCreateWithoutHorario_empleadoInput, horarioUncheckedCreateWithoutHorario_empleadoInput>
    where?: horarioWhereInput
  }

  export type horarioUpdateToOneWithWhereWithoutHorario_empleadoInput = {
    where?: horarioWhereInput
    data: XOR<horarioUpdateWithoutHorario_empleadoInput, horarioUncheckedUpdateWithoutHorario_empleadoInput>
  }

  export type horarioUpdateWithoutHorario_empleadoInput = {
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type horarioUncheckedUpdateWithoutHorario_empleadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    hora_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora_fin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type herramientaCreateWithoutMarca_herramientaInput = {
    nombre: string
    descripcion?: string | null
    movimiento_herramienta?: movimiento_herramientaCreateNestedManyWithoutHerramientaInput
  }

  export type herramientaUncheckedCreateWithoutMarca_herramientaInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    movimiento_herramienta?: movimiento_herramientaUncheckedCreateNestedManyWithoutHerramientaInput
  }

  export type herramientaCreateOrConnectWithoutMarca_herramientaInput = {
    where: herramientaWhereUniqueInput
    create: XOR<herramientaCreateWithoutMarca_herramientaInput, herramientaUncheckedCreateWithoutMarca_herramientaInput>
  }

  export type herramientaCreateManyMarca_herramientaInputEnvelope = {
    data: herramientaCreateManyMarca_herramientaInput | herramientaCreateManyMarca_herramientaInput[]
    skipDuplicates?: boolean
  }

  export type herramientaUpsertWithWhereUniqueWithoutMarca_herramientaInput = {
    where: herramientaWhereUniqueInput
    update: XOR<herramientaUpdateWithoutMarca_herramientaInput, herramientaUncheckedUpdateWithoutMarca_herramientaInput>
    create: XOR<herramientaCreateWithoutMarca_herramientaInput, herramientaUncheckedCreateWithoutMarca_herramientaInput>
  }

  export type herramientaUpdateWithWhereUniqueWithoutMarca_herramientaInput = {
    where: herramientaWhereUniqueInput
    data: XOR<herramientaUpdateWithoutMarca_herramientaInput, herramientaUncheckedUpdateWithoutMarca_herramientaInput>
  }

  export type herramientaUpdateManyWithWhereWithoutMarca_herramientaInput = {
    where: herramientaScalarWhereInput
    data: XOR<herramientaUpdateManyMutationInput, herramientaUncheckedUpdateManyWithoutMarca_herramientaInput>
  }

  export type herramientaScalarWhereInput = {
    AND?: herramientaScalarWhereInput | herramientaScalarWhereInput[]
    OR?: herramientaScalarWhereInput[]
    NOT?: herramientaScalarWhereInput | herramientaScalarWhereInput[]
    id?: IntFilter<"herramienta"> | number
    nombre?: StringFilter<"herramienta"> | string
    descripcion?: StringNullableFilter<"herramienta"> | string | null
    marca_id?: IntFilter<"herramienta"> | number
  }

  export type motoCreateWithoutMarca_motoInput = {
    placa: string
    modelo: string
    year: number
    chasis?: string | null
    diagnostico?: diagnosticoCreateNestedManyWithoutMotoInput
  }

  export type motoUncheckedCreateWithoutMarca_motoInput = {
    placa: string
    modelo: string
    year: number
    chasis?: string | null
    diagnostico?: diagnosticoUncheckedCreateNestedManyWithoutMotoInput
  }

  export type motoCreateOrConnectWithoutMarca_motoInput = {
    where: motoWhereUniqueInput
    create: XOR<motoCreateWithoutMarca_motoInput, motoUncheckedCreateWithoutMarca_motoInput>
  }

  export type motoCreateManyMarca_motoInputEnvelope = {
    data: motoCreateManyMarca_motoInput | motoCreateManyMarca_motoInput[]
    skipDuplicates?: boolean
  }

  export type motoUpsertWithWhereUniqueWithoutMarca_motoInput = {
    where: motoWhereUniqueInput
    update: XOR<motoUpdateWithoutMarca_motoInput, motoUncheckedUpdateWithoutMarca_motoInput>
    create: XOR<motoCreateWithoutMarca_motoInput, motoUncheckedCreateWithoutMarca_motoInput>
  }

  export type motoUpdateWithWhereUniqueWithoutMarca_motoInput = {
    where: motoWhereUniqueInput
    data: XOR<motoUpdateWithoutMarca_motoInput, motoUncheckedUpdateWithoutMarca_motoInput>
  }

  export type motoUpdateManyWithWhereWithoutMarca_motoInput = {
    where: motoScalarWhereInput
    data: XOR<motoUpdateManyMutationInput, motoUncheckedUpdateManyWithoutMarca_motoInput>
  }

  export type motoScalarWhereInput = {
    AND?: motoScalarWhereInput | motoScalarWhereInput[]
    OR?: motoScalarWhereInput[]
    NOT?: motoScalarWhereInput | motoScalarWhereInput[]
    placa?: StringFilter<"moto"> | string
    modelo?: StringFilter<"moto"> | string
    year?: IntFilter<"moto"> | number
    chasis?: StringNullableFilter<"moto"> | string | null
    marca_id?: IntFilter<"moto"> | number
  }

  export type diagnosticoCreateWithoutMotoInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    detalle_diagnostico?: detalle_diagnosticoCreateNestedManyWithoutDiagnosticoInput
    empleado: empleadoCreateNestedOneWithoutDiagnosticoInput
    proforma?: proformaCreateNestedOneWithoutDiagnosticoInput
  }

  export type diagnosticoUncheckedCreateWithoutMotoInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    empleado_ci: number
    detalle_diagnostico?: detalle_diagnosticoUncheckedCreateNestedManyWithoutDiagnosticoInput
    proforma?: proformaUncheckedCreateNestedOneWithoutDiagnosticoInput
  }

  export type diagnosticoCreateOrConnectWithoutMotoInput = {
    where: diagnosticoWhereUniqueInput
    create: XOR<diagnosticoCreateWithoutMotoInput, diagnosticoUncheckedCreateWithoutMotoInput>
  }

  export type diagnosticoCreateManyMotoInputEnvelope = {
    data: diagnosticoCreateManyMotoInput | diagnosticoCreateManyMotoInput[]
    skipDuplicates?: boolean
  }

  export type marca_motoCreateWithoutMotoInput = {
    nombre: string
  }

  export type marca_motoUncheckedCreateWithoutMotoInput = {
    id?: number
    nombre: string
  }

  export type marca_motoCreateOrConnectWithoutMotoInput = {
    where: marca_motoWhereUniqueInput
    create: XOR<marca_motoCreateWithoutMotoInput, marca_motoUncheckedCreateWithoutMotoInput>
  }

  export type diagnosticoUpsertWithWhereUniqueWithoutMotoInput = {
    where: diagnosticoWhereUniqueInput
    update: XOR<diagnosticoUpdateWithoutMotoInput, diagnosticoUncheckedUpdateWithoutMotoInput>
    create: XOR<diagnosticoCreateWithoutMotoInput, diagnosticoUncheckedCreateWithoutMotoInput>
  }

  export type diagnosticoUpdateWithWhereUniqueWithoutMotoInput = {
    where: diagnosticoWhereUniqueInput
    data: XOR<diagnosticoUpdateWithoutMotoInput, diagnosticoUncheckedUpdateWithoutMotoInput>
  }

  export type diagnosticoUpdateManyWithWhereWithoutMotoInput = {
    where: diagnosticoScalarWhereInput
    data: XOR<diagnosticoUpdateManyMutationInput, diagnosticoUncheckedUpdateManyWithoutMotoInput>
  }

  export type marca_motoUpsertWithoutMotoInput = {
    update: XOR<marca_motoUpdateWithoutMotoInput, marca_motoUncheckedUpdateWithoutMotoInput>
    create: XOR<marca_motoCreateWithoutMotoInput, marca_motoUncheckedCreateWithoutMotoInput>
    where?: marca_motoWhereInput
  }

  export type marca_motoUpdateToOneWithWhereWithoutMotoInput = {
    where?: marca_motoWhereInput
    data: XOR<marca_motoUpdateWithoutMotoInput, marca_motoUncheckedUpdateWithoutMotoInput>
  }

  export type marca_motoUpdateWithoutMotoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type marca_motoUncheckedUpdateWithoutMotoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type herramientaCreateWithoutMovimiento_herramientaInput = {
    nombre: string
    descripcion?: string | null
    marca_herramienta: marca_herramientaCreateNestedOneWithoutHerramientaInput
  }

  export type herramientaUncheckedCreateWithoutMovimiento_herramientaInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    marca_id: number
  }

  export type herramientaCreateOrConnectWithoutMovimiento_herramientaInput = {
    where: herramientaWhereUniqueInput
    create: XOR<herramientaCreateWithoutMovimiento_herramientaInput, herramientaUncheckedCreateWithoutMovimiento_herramientaInput>
  }

  export type orden_trabajoCreateWithoutMovimiento_herramientaInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    comision?: comisionCreateNestedOneWithoutOrden_trabajoInput
    administrador?: administradorCreateNestedOneWithoutOrden_trabajoInput
    empleado: empleadoCreateNestedOneWithoutOrden_trabajoInput
    servicio: servicioCreateNestedOneWithoutOrden_trabajoInput
  }

  export type orden_trabajoUncheckedCreateWithoutMovimiento_herramientaInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    empleado_ci: number
    administrador_id?: number | null
    servicio_id: number
    comision?: comisionUncheckedCreateNestedOneWithoutOrden_trabajoInput
  }

  export type orden_trabajoCreateOrConnectWithoutMovimiento_herramientaInput = {
    where: orden_trabajoWhereUniqueInput
    create: XOR<orden_trabajoCreateWithoutMovimiento_herramientaInput, orden_trabajoUncheckedCreateWithoutMovimiento_herramientaInput>
  }

  export type herramientaUpsertWithoutMovimiento_herramientaInput = {
    update: XOR<herramientaUpdateWithoutMovimiento_herramientaInput, herramientaUncheckedUpdateWithoutMovimiento_herramientaInput>
    create: XOR<herramientaCreateWithoutMovimiento_herramientaInput, herramientaUncheckedCreateWithoutMovimiento_herramientaInput>
    where?: herramientaWhereInput
  }

  export type herramientaUpdateToOneWithWhereWithoutMovimiento_herramientaInput = {
    where?: herramientaWhereInput
    data: XOR<herramientaUpdateWithoutMovimiento_herramientaInput, herramientaUncheckedUpdateWithoutMovimiento_herramientaInput>
  }

  export type herramientaUpdateWithoutMovimiento_herramientaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    marca_herramienta?: marca_herramientaUpdateOneRequiredWithoutHerramientaNestedInput
  }

  export type herramientaUncheckedUpdateWithoutMovimiento_herramientaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    marca_id?: IntFieldUpdateOperationsInput | number
  }

  export type orden_trabajoUpsertWithoutMovimiento_herramientaInput = {
    update: XOR<orden_trabajoUpdateWithoutMovimiento_herramientaInput, orden_trabajoUncheckedUpdateWithoutMovimiento_herramientaInput>
    create: XOR<orden_trabajoCreateWithoutMovimiento_herramientaInput, orden_trabajoUncheckedCreateWithoutMovimiento_herramientaInput>
    where?: orden_trabajoWhereInput
  }

  export type orden_trabajoUpdateToOneWithWhereWithoutMovimiento_herramientaInput = {
    where?: orden_trabajoWhereInput
    data: XOR<orden_trabajoUpdateWithoutMovimiento_herramientaInput, orden_trabajoUncheckedUpdateWithoutMovimiento_herramientaInput>
  }

  export type orden_trabajoUpdateWithoutMovimiento_herramientaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    comision?: comisionUpdateOneWithoutOrden_trabajoNestedInput
    administrador?: administradorUpdateOneWithoutOrden_trabajoNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutOrden_trabajoNestedInput
    servicio?: servicioUpdateOneRequiredWithoutOrden_trabajoNestedInput
  }

  export type orden_trabajoUncheckedUpdateWithoutMovimiento_herramientaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    empleado_ci?: IntFieldUpdateOperationsInput | number
    administrador_id?: NullableIntFieldUpdateOperationsInput | number | null
    servicio_id?: IntFieldUpdateOperationsInput | number
    comision?: comisionUncheckedUpdateOneWithoutOrden_trabajoNestedInput
  }

  export type comisionCreateWithoutOrden_trabajoInput = {
    monto: Decimal | DecimalJsLike | number | string
    estado_pago?: $Enums.estado_pago
    fecha_pago?: Date | string | null
  }

  export type comisionUncheckedCreateWithoutOrden_trabajoInput = {
    id?: number
    monto: Decimal | DecimalJsLike | number | string
    estado_pago?: $Enums.estado_pago
    fecha_pago?: Date | string | null
  }

  export type comisionCreateOrConnectWithoutOrden_trabajoInput = {
    where: comisionWhereUniqueInput
    create: XOR<comisionCreateWithoutOrden_trabajoInput, comisionUncheckedCreateWithoutOrden_trabajoInput>
  }

  export type movimiento_herramientaCreateWithoutOrden_trabajoInput = {
    fecha: Date | string
    cantidad: number
    herramienta: herramientaCreateNestedOneWithoutMovimiento_herramientaInput
  }

  export type movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput = {
    herramienta_id: number
    fecha: Date | string
    cantidad: number
  }

  export type movimiento_herramientaCreateOrConnectWithoutOrden_trabajoInput = {
    where: movimiento_herramientaWhereUniqueInput
    create: XOR<movimiento_herramientaCreateWithoutOrden_trabajoInput, movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput>
  }

  export type movimiento_herramientaCreateManyOrden_trabajoInputEnvelope = {
    data: movimiento_herramientaCreateManyOrden_trabajoInput | movimiento_herramientaCreateManyOrden_trabajoInput[]
    skipDuplicates?: boolean
  }

  export type administradorCreateWithoutOrden_trabajoInput = {
    usuario: usuarioCreateNestedOneWithoutAdministradorInput
  }

  export type administradorUncheckedCreateWithoutOrden_trabajoInput = {
    id?: number
    usuario_id: number
  }

  export type administradorCreateOrConnectWithoutOrden_trabajoInput = {
    where: administradorWhereUniqueInput
    create: XOR<administradorCreateWithoutOrden_trabajoInput, administradorUncheckedCreateWithoutOrden_trabajoInput>
  }

  export type empleadoCreateWithoutOrden_trabajoInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
    diagnostico?: diagnosticoCreateNestedManyWithoutEmpleadoInput
    horario_empleado?: horario_empleadoCreateNestedManyWithoutEmpleadoInput
    usuario?: usuarioCreateNestedOneWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutOrden_trabajoInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
    diagnostico?: diagnosticoUncheckedCreateNestedManyWithoutEmpleadoInput
    horario_empleado?: horario_empleadoUncheckedCreateNestedManyWithoutEmpleadoInput
    usuario?: usuarioUncheckedCreateNestedOneWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutOrden_trabajoInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutOrden_trabajoInput, empleadoUncheckedCreateWithoutOrden_trabajoInput>
  }

  export type servicioCreateWithoutOrden_trabajoInput = {
    descripcion: string
    detalle_proforma?: detalle_proformaCreateNestedManyWithoutServicioInput
    categoria: categoriaCreateNestedOneWithoutServicioInput
  }

  export type servicioUncheckedCreateWithoutOrden_trabajoInput = {
    id?: number
    descripcion: string
    categoria_id: number
    detalle_proforma?: detalle_proformaUncheckedCreateNestedManyWithoutServicioInput
  }

  export type servicioCreateOrConnectWithoutOrden_trabajoInput = {
    where: servicioWhereUniqueInput
    create: XOR<servicioCreateWithoutOrden_trabajoInput, servicioUncheckedCreateWithoutOrden_trabajoInput>
  }

  export type comisionUpsertWithoutOrden_trabajoInput = {
    update: XOR<comisionUpdateWithoutOrden_trabajoInput, comisionUncheckedUpdateWithoutOrden_trabajoInput>
    create: XOR<comisionCreateWithoutOrden_trabajoInput, comisionUncheckedCreateWithoutOrden_trabajoInput>
    where?: comisionWhereInput
  }

  export type comisionUpdateToOneWithWhereWithoutOrden_trabajoInput = {
    where?: comisionWhereInput
    data: XOR<comisionUpdateWithoutOrden_trabajoInput, comisionUncheckedUpdateWithoutOrden_trabajoInput>
  }

  export type comisionUpdateWithoutOrden_trabajoInput = {
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_pago?: Enumestado_pagoFieldUpdateOperationsInput | $Enums.estado_pago
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type comisionUncheckedUpdateWithoutOrden_trabajoInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_pago?: Enumestado_pagoFieldUpdateOperationsInput | $Enums.estado_pago
    fecha_pago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type movimiento_herramientaUpsertWithWhereUniqueWithoutOrden_trabajoInput = {
    where: movimiento_herramientaWhereUniqueInput
    update: XOR<movimiento_herramientaUpdateWithoutOrden_trabajoInput, movimiento_herramientaUncheckedUpdateWithoutOrden_trabajoInput>
    create: XOR<movimiento_herramientaCreateWithoutOrden_trabajoInput, movimiento_herramientaUncheckedCreateWithoutOrden_trabajoInput>
  }

  export type movimiento_herramientaUpdateWithWhereUniqueWithoutOrden_trabajoInput = {
    where: movimiento_herramientaWhereUniqueInput
    data: XOR<movimiento_herramientaUpdateWithoutOrden_trabajoInput, movimiento_herramientaUncheckedUpdateWithoutOrden_trabajoInput>
  }

  export type movimiento_herramientaUpdateManyWithWhereWithoutOrden_trabajoInput = {
    where: movimiento_herramientaScalarWhereInput
    data: XOR<movimiento_herramientaUpdateManyMutationInput, movimiento_herramientaUncheckedUpdateManyWithoutOrden_trabajoInput>
  }

  export type administradorUpsertWithoutOrden_trabajoInput = {
    update: XOR<administradorUpdateWithoutOrden_trabajoInput, administradorUncheckedUpdateWithoutOrden_trabajoInput>
    create: XOR<administradorCreateWithoutOrden_trabajoInput, administradorUncheckedCreateWithoutOrden_trabajoInput>
    where?: administradorWhereInput
  }

  export type administradorUpdateToOneWithWhereWithoutOrden_trabajoInput = {
    where?: administradorWhereInput
    data: XOR<administradorUpdateWithoutOrden_trabajoInput, administradorUncheckedUpdateWithoutOrden_trabajoInput>
  }

  export type administradorUpdateWithoutOrden_trabajoInput = {
    usuario?: usuarioUpdateOneRequiredWithoutAdministradorNestedInput
  }

  export type administradorUncheckedUpdateWithoutOrden_trabajoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type empleadoUpsertWithoutOrden_trabajoInput = {
    update: XOR<empleadoUpdateWithoutOrden_trabajoInput, empleadoUncheckedUpdateWithoutOrden_trabajoInput>
    create: XOR<empleadoCreateWithoutOrden_trabajoInput, empleadoUncheckedCreateWithoutOrden_trabajoInput>
    where?: empleadoWhereInput
  }

  export type empleadoUpdateToOneWithWhereWithoutOrden_trabajoInput = {
    where?: empleadoWhereInput
    data: XOR<empleadoUpdateWithoutOrden_trabajoInput, empleadoUncheckedUpdateWithoutOrden_trabajoInput>
  }

  export type empleadoUpdateWithoutOrden_trabajoInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    diagnostico?: diagnosticoUpdateManyWithoutEmpleadoNestedInput
    horario_empleado?: horario_empleadoUpdateManyWithoutEmpleadoNestedInput
    usuario?: usuarioUpdateOneWithoutEmpleadoNestedInput
  }

  export type empleadoUncheckedUpdateWithoutOrden_trabajoInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    diagnostico?: diagnosticoUncheckedUpdateManyWithoutEmpleadoNestedInput
    horario_empleado?: horario_empleadoUncheckedUpdateManyWithoutEmpleadoNestedInput
    usuario?: usuarioUncheckedUpdateOneWithoutEmpleadoNestedInput
  }

  export type servicioUpsertWithoutOrden_trabajoInput = {
    update: XOR<servicioUpdateWithoutOrden_trabajoInput, servicioUncheckedUpdateWithoutOrden_trabajoInput>
    create: XOR<servicioCreateWithoutOrden_trabajoInput, servicioUncheckedCreateWithoutOrden_trabajoInput>
    where?: servicioWhereInput
  }

  export type servicioUpdateToOneWithWhereWithoutOrden_trabajoInput = {
    where?: servicioWhereInput
    data: XOR<servicioUpdateWithoutOrden_trabajoInput, servicioUncheckedUpdateWithoutOrden_trabajoInput>
  }

  export type servicioUpdateWithoutOrden_trabajoInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    detalle_proforma?: detalle_proformaUpdateManyWithoutServicioNestedInput
    categoria?: categoriaUpdateOneRequiredWithoutServicioNestedInput
  }

  export type servicioUncheckedUpdateWithoutOrden_trabajoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    categoria_id?: IntFieldUpdateOperationsInput | number
    detalle_proforma?: detalle_proformaUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type detalle_proformaCreateWithoutProformaInput = {
    id?: bigint | number
    descripcion: string
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    servicio?: servicioCreateNestedOneWithoutDetalle_proformaInput
  }

  export type detalle_proformaUncheckedCreateWithoutProformaInput = {
    id?: bigint | number
    servicio_id?: number | null
    descripcion: string
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_proformaCreateOrConnectWithoutProformaInput = {
    where: detalle_proformaWhereUniqueInput
    create: XOR<detalle_proformaCreateWithoutProformaInput, detalle_proformaUncheckedCreateWithoutProformaInput>
  }

  export type detalle_proformaCreateManyProformaInputEnvelope = {
    data: detalle_proformaCreateManyProformaInput | detalle_proformaCreateManyProformaInput[]
    skipDuplicates?: boolean
  }

  export type clienteCreateWithoutProformaInput = {
    ci: number
    nombre: string
    telefono: string
    direccion: string
    factura?: facturaCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateWithoutProformaInput = {
    ci: number
    nombre: string
    telefono: string
    direccion: string
    factura?: facturaUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteCreateOrConnectWithoutProformaInput = {
    where: clienteWhereUniqueInput
    create: XOR<clienteCreateWithoutProformaInput, clienteUncheckedCreateWithoutProformaInput>
  }

  export type diagnosticoCreateWithoutProformaInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    detalle_diagnostico?: detalle_diagnosticoCreateNestedManyWithoutDiagnosticoInput
    empleado: empleadoCreateNestedOneWithoutDiagnosticoInput
    moto: motoCreateNestedOneWithoutDiagnosticoInput
  }

  export type diagnosticoUncheckedCreateWithoutProformaInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    placa_moto: string
    empleado_ci: number
    detalle_diagnostico?: detalle_diagnosticoUncheckedCreateNestedManyWithoutDiagnosticoInput
  }

  export type diagnosticoCreateOrConnectWithoutProformaInput = {
    where: diagnosticoWhereUniqueInput
    create: XOR<diagnosticoCreateWithoutProformaInput, diagnosticoUncheckedCreateWithoutProformaInput>
  }

  export type proforma_repuestoCreateWithoutProformaInput = {
    nombre: string
  }

  export type proforma_repuestoUncheckedCreateWithoutProformaInput = {
    id?: number
    nombre: string
  }

  export type proforma_repuestoCreateOrConnectWithoutProformaInput = {
    where: proforma_repuestoWhereUniqueInput
    create: XOR<proforma_repuestoCreateWithoutProformaInput, proforma_repuestoUncheckedCreateWithoutProformaInput>
  }

  export type proforma_repuestoCreateManyProformaInputEnvelope = {
    data: proforma_repuestoCreateManyProformaInput | proforma_repuestoCreateManyProformaInput[]
    skipDuplicates?: boolean
  }

  export type detalle_proformaUpsertWithWhereUniqueWithoutProformaInput = {
    where: detalle_proformaWhereUniqueInput
    update: XOR<detalle_proformaUpdateWithoutProformaInput, detalle_proformaUncheckedUpdateWithoutProformaInput>
    create: XOR<detalle_proformaCreateWithoutProformaInput, detalle_proformaUncheckedCreateWithoutProformaInput>
  }

  export type detalle_proformaUpdateWithWhereUniqueWithoutProformaInput = {
    where: detalle_proformaWhereUniqueInput
    data: XOR<detalle_proformaUpdateWithoutProformaInput, detalle_proformaUncheckedUpdateWithoutProformaInput>
  }

  export type detalle_proformaUpdateManyWithWhereWithoutProformaInput = {
    where: detalle_proformaScalarWhereInput
    data: XOR<detalle_proformaUpdateManyMutationInput, detalle_proformaUncheckedUpdateManyWithoutProformaInput>
  }

  export type detalle_proformaScalarWhereInput = {
    AND?: detalle_proformaScalarWhereInput | detalle_proformaScalarWhereInput[]
    OR?: detalle_proformaScalarWhereInput[]
    NOT?: detalle_proformaScalarWhereInput | detalle_proformaScalarWhereInput[]
    id?: BigIntFilter<"detalle_proforma"> | bigint | number
    proforma_id?: BigIntFilter<"detalle_proforma"> | bigint | number
    servicio_id?: IntNullableFilter<"detalle_proforma"> | number | null
    descripcion?: StringFilter<"detalle_proforma"> | string
    cantidad?: DecimalFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalNullableFilter<"detalle_proforma"> | Decimal | DecimalJsLike | number | string | null
  }

  export type clienteUpsertWithoutProformaInput = {
    update: XOR<clienteUpdateWithoutProformaInput, clienteUncheckedUpdateWithoutProformaInput>
    create: XOR<clienteCreateWithoutProformaInput, clienteUncheckedCreateWithoutProformaInput>
    where?: clienteWhereInput
  }

  export type clienteUpdateToOneWithWhereWithoutProformaInput = {
    where?: clienteWhereInput
    data: XOR<clienteUpdateWithoutProformaInput, clienteUncheckedUpdateWithoutProformaInput>
  }

  export type clienteUpdateWithoutProformaInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    factura?: facturaUpdateManyWithoutClienteNestedInput
  }

  export type clienteUncheckedUpdateWithoutProformaInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    factura?: facturaUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type diagnosticoUpsertWithoutProformaInput = {
    update: XOR<diagnosticoUpdateWithoutProformaInput, diagnosticoUncheckedUpdateWithoutProformaInput>
    create: XOR<diagnosticoCreateWithoutProformaInput, diagnosticoUncheckedCreateWithoutProformaInput>
    where?: diagnosticoWhereInput
  }

  export type diagnosticoUpdateToOneWithWhereWithoutProformaInput = {
    where?: diagnosticoWhereInput
    data: XOR<diagnosticoUpdateWithoutProformaInput, diagnosticoUncheckedUpdateWithoutProformaInput>
  }

  export type diagnosticoUpdateWithoutProformaInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    detalle_diagnostico?: detalle_diagnosticoUpdateManyWithoutDiagnosticoNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutDiagnosticoNestedInput
    moto?: motoUpdateOneRequiredWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateWithoutProformaInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    placa_moto?: StringFieldUpdateOperationsInput | string
    empleado_ci?: IntFieldUpdateOperationsInput | number
    detalle_diagnostico?: detalle_diagnosticoUncheckedUpdateManyWithoutDiagnosticoNestedInput
  }

  export type proforma_repuestoUpsertWithWhereUniqueWithoutProformaInput = {
    where: proforma_repuestoWhereUniqueInput
    update: XOR<proforma_repuestoUpdateWithoutProformaInput, proforma_repuestoUncheckedUpdateWithoutProformaInput>
    create: XOR<proforma_repuestoCreateWithoutProformaInput, proforma_repuestoUncheckedCreateWithoutProformaInput>
  }

  export type proforma_repuestoUpdateWithWhereUniqueWithoutProformaInput = {
    where: proforma_repuestoWhereUniqueInput
    data: XOR<proforma_repuestoUpdateWithoutProformaInput, proforma_repuestoUncheckedUpdateWithoutProformaInput>
  }

  export type proforma_repuestoUpdateManyWithWhereWithoutProformaInput = {
    where: proforma_repuestoScalarWhereInput
    data: XOR<proforma_repuestoUpdateManyMutationInput, proforma_repuestoUncheckedUpdateManyWithoutProformaInput>
  }

  export type proforma_repuestoScalarWhereInput = {
    AND?: proforma_repuestoScalarWhereInput | proforma_repuestoScalarWhereInput[]
    OR?: proforma_repuestoScalarWhereInput[]
    NOT?: proforma_repuestoScalarWhereInput | proforma_repuestoScalarWhereInput[]
    id?: IntFilter<"proforma_repuesto"> | number
    nombre?: StringFilter<"proforma_repuesto"> | string
    proforma_id?: BigIntFilter<"proforma_repuesto"> | bigint | number
  }

  export type proformaCreateWithoutProforma_repuestoInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    detalle_proforma?: detalle_proformaCreateNestedManyWithoutProformaInput
    cliente: clienteCreateNestedOneWithoutProformaInput
    diagnostico?: diagnosticoCreateNestedOneWithoutProformaInput
  }

  export type proformaUncheckedCreateWithoutProforma_repuestoInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    cliente_ci: number
    diagnostico_id?: bigint | number | null
    detalle_proforma?: detalle_proformaUncheckedCreateNestedManyWithoutProformaInput
  }

  export type proformaCreateOrConnectWithoutProforma_repuestoInput = {
    where: proformaWhereUniqueInput
    create: XOR<proformaCreateWithoutProforma_repuestoInput, proformaUncheckedCreateWithoutProforma_repuestoInput>
  }

  export type proformaUpsertWithoutProforma_repuestoInput = {
    update: XOR<proformaUpdateWithoutProforma_repuestoInput, proformaUncheckedUpdateWithoutProforma_repuestoInput>
    create: XOR<proformaCreateWithoutProforma_repuestoInput, proformaUncheckedCreateWithoutProforma_repuestoInput>
    where?: proformaWhereInput
  }

  export type proformaUpdateToOneWithWhereWithoutProforma_repuestoInput = {
    where?: proformaWhereInput
    data: XOR<proformaUpdateWithoutProforma_repuestoInput, proformaUncheckedUpdateWithoutProforma_repuestoInput>
  }

  export type proformaUpdateWithoutProforma_repuestoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_proforma?: detalle_proformaUpdateManyWithoutProformaNestedInput
    cliente?: clienteUpdateOneRequiredWithoutProformaNestedInput
    diagnostico?: diagnosticoUpdateOneWithoutProformaNestedInput
  }

  export type proformaUncheckedUpdateWithoutProforma_repuestoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cliente_ci?: IntFieldUpdateOperationsInput | number
    diagnostico_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    detalle_proforma?: detalle_proformaUncheckedUpdateManyWithoutProformaNestedInput
  }

  export type detalle_proformaCreateWithoutServicioInput = {
    id?: bigint | number
    descripcion: string
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
    proforma: proformaCreateNestedOneWithoutDetalle_proformaInput
  }

  export type detalle_proformaUncheckedCreateWithoutServicioInput = {
    id?: bigint | number
    proforma_id: bigint | number
    descripcion: string
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_proformaCreateOrConnectWithoutServicioInput = {
    where: detalle_proformaWhereUniqueInput
    create: XOR<detalle_proformaCreateWithoutServicioInput, detalle_proformaUncheckedCreateWithoutServicioInput>
  }

  export type detalle_proformaCreateManyServicioInputEnvelope = {
    data: detalle_proformaCreateManyServicioInput | detalle_proformaCreateManyServicioInput[]
    skipDuplicates?: boolean
  }

  export type orden_trabajoCreateWithoutServicioInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    comision?: comisionCreateNestedOneWithoutOrden_trabajoInput
    movimiento_herramienta?: movimiento_herramientaCreateNestedManyWithoutOrden_trabajoInput
    administrador?: administradorCreateNestedOneWithoutOrden_trabajoInput
    empleado: empleadoCreateNestedOneWithoutOrden_trabajoInput
  }

  export type orden_trabajoUncheckedCreateWithoutServicioInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    empleado_ci: number
    administrador_id?: number | null
    comision?: comisionUncheckedCreateNestedOneWithoutOrden_trabajoInput
    movimiento_herramienta?: movimiento_herramientaUncheckedCreateNestedManyWithoutOrden_trabajoInput
  }

  export type orden_trabajoCreateOrConnectWithoutServicioInput = {
    where: orden_trabajoWhereUniqueInput
    create: XOR<orden_trabajoCreateWithoutServicioInput, orden_trabajoUncheckedCreateWithoutServicioInput>
  }

  export type orden_trabajoCreateManyServicioInputEnvelope = {
    data: orden_trabajoCreateManyServicioInput | orden_trabajoCreateManyServicioInput[]
    skipDuplicates?: boolean
  }

  export type categoriaCreateWithoutServicioInput = {
    nombre: string
  }

  export type categoriaUncheckedCreateWithoutServicioInput = {
    id?: number
    nombre: string
  }

  export type categoriaCreateOrConnectWithoutServicioInput = {
    where: categoriaWhereUniqueInput
    create: XOR<categoriaCreateWithoutServicioInput, categoriaUncheckedCreateWithoutServicioInput>
  }

  export type detalle_proformaUpsertWithWhereUniqueWithoutServicioInput = {
    where: detalle_proformaWhereUniqueInput
    update: XOR<detalle_proformaUpdateWithoutServicioInput, detalle_proformaUncheckedUpdateWithoutServicioInput>
    create: XOR<detalle_proformaCreateWithoutServicioInput, detalle_proformaUncheckedCreateWithoutServicioInput>
  }

  export type detalle_proformaUpdateWithWhereUniqueWithoutServicioInput = {
    where: detalle_proformaWhereUniqueInput
    data: XOR<detalle_proformaUpdateWithoutServicioInput, detalle_proformaUncheckedUpdateWithoutServicioInput>
  }

  export type detalle_proformaUpdateManyWithWhereWithoutServicioInput = {
    where: detalle_proformaScalarWhereInput
    data: XOR<detalle_proformaUpdateManyMutationInput, detalle_proformaUncheckedUpdateManyWithoutServicioInput>
  }

  export type orden_trabajoUpsertWithWhereUniqueWithoutServicioInput = {
    where: orden_trabajoWhereUniqueInput
    update: XOR<orden_trabajoUpdateWithoutServicioInput, orden_trabajoUncheckedUpdateWithoutServicioInput>
    create: XOR<orden_trabajoCreateWithoutServicioInput, orden_trabajoUncheckedCreateWithoutServicioInput>
  }

  export type orden_trabajoUpdateWithWhereUniqueWithoutServicioInput = {
    where: orden_trabajoWhereUniqueInput
    data: XOR<orden_trabajoUpdateWithoutServicioInput, orden_trabajoUncheckedUpdateWithoutServicioInput>
  }

  export type orden_trabajoUpdateManyWithWhereWithoutServicioInput = {
    where: orden_trabajoScalarWhereInput
    data: XOR<orden_trabajoUpdateManyMutationInput, orden_trabajoUncheckedUpdateManyWithoutServicioInput>
  }

  export type categoriaUpsertWithoutServicioInput = {
    update: XOR<categoriaUpdateWithoutServicioInput, categoriaUncheckedUpdateWithoutServicioInput>
    create: XOR<categoriaCreateWithoutServicioInput, categoriaUncheckedCreateWithoutServicioInput>
    where?: categoriaWhereInput
  }

  export type categoriaUpdateToOneWithWhereWithoutServicioInput = {
    where?: categoriaWhereInput
    data: XOR<categoriaUpdateWithoutServicioInput, categoriaUncheckedUpdateWithoutServicioInput>
  }

  export type categoriaUpdateWithoutServicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type categoriaUncheckedUpdateWithoutServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type administradorCreateWithoutUsuarioInput = {
    orden_trabajo?: orden_trabajoCreateNestedManyWithoutAdministradorInput
  }

  export type administradorUncheckedCreateWithoutUsuarioInput = {
    id?: number
    orden_trabajo?: orden_trabajoUncheckedCreateNestedManyWithoutAdministradorInput
  }

  export type administradorCreateOrConnectWithoutUsuarioInput = {
    where: administradorWhereUniqueInput
    create: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput>
  }

  export type empleadoCreateWithoutUsuarioInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
    diagnostico?: diagnosticoCreateNestedManyWithoutEmpleadoInput
    horario_empleado?: horario_empleadoCreateNestedManyWithoutEmpleadoInput
    orden_trabajo?: orden_trabajoCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutUsuarioInput = {
    ci: number
    nombre: string
    fechanac: Date | string
    direccion: string
    telefono: number
    diagnostico?: diagnosticoUncheckedCreateNestedManyWithoutEmpleadoInput
    horario_empleado?: horario_empleadoUncheckedCreateNestedManyWithoutEmpleadoInput
    orden_trabajo?: orden_trabajoUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutUsuarioInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutUsuarioInput, empleadoUncheckedCreateWithoutUsuarioInput>
  }

  export type administradorUpsertWithoutUsuarioInput = {
    update: XOR<administradorUpdateWithoutUsuarioInput, administradorUncheckedUpdateWithoutUsuarioInput>
    create: XOR<administradorCreateWithoutUsuarioInput, administradorUncheckedCreateWithoutUsuarioInput>
    where?: administradorWhereInput
  }

  export type administradorUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: administradorWhereInput
    data: XOR<administradorUpdateWithoutUsuarioInput, administradorUncheckedUpdateWithoutUsuarioInput>
  }

  export type administradorUpdateWithoutUsuarioInput = {
    orden_trabajo?: orden_trabajoUpdateManyWithoutAdministradorNestedInput
  }

  export type administradorUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    orden_trabajo?: orden_trabajoUncheckedUpdateManyWithoutAdministradorNestedInput
  }

  export type empleadoUpsertWithoutUsuarioInput = {
    update: XOR<empleadoUpdateWithoutUsuarioInput, empleadoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<empleadoCreateWithoutUsuarioInput, empleadoUncheckedCreateWithoutUsuarioInput>
    where?: empleadoWhereInput
  }

  export type empleadoUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: empleadoWhereInput
    data: XOR<empleadoUpdateWithoutUsuarioInput, empleadoUncheckedUpdateWithoutUsuarioInput>
  }

  export type empleadoUpdateWithoutUsuarioInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    diagnostico?: diagnosticoUpdateManyWithoutEmpleadoNestedInput
    horario_empleado?: horario_empleadoUpdateManyWithoutEmpleadoNestedInput
    orden_trabajo?: orden_trabajoUpdateManyWithoutEmpleadoNestedInput
  }

  export type empleadoUncheckedUpdateWithoutUsuarioInput = {
    ci?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fechanac?: DateTimeFieldUpdateOperationsInput | Date | string
    direccion?: StringFieldUpdateOperationsInput | string
    telefono?: IntFieldUpdateOperationsInput | number
    diagnostico?: diagnosticoUncheckedUpdateManyWithoutEmpleadoNestedInput
    horario_empleado?: horario_empleadoUncheckedUpdateManyWithoutEmpleadoNestedInput
    orden_trabajo?: orden_trabajoUncheckedUpdateManyWithoutEmpleadoNestedInput
  }

  export type orden_trabajoCreateManyAdministradorInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    empleado_ci: number
    servicio_id: number
  }

  export type orden_trabajoUpdateWithoutAdministradorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    comision?: comisionUpdateOneWithoutOrden_trabajoNestedInput
    movimiento_herramienta?: movimiento_herramientaUpdateManyWithoutOrden_trabajoNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutOrden_trabajoNestedInput
    servicio?: servicioUpdateOneRequiredWithoutOrden_trabajoNestedInput
  }

  export type orden_trabajoUncheckedUpdateWithoutAdministradorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    empleado_ci?: IntFieldUpdateOperationsInput | number
    servicio_id?: IntFieldUpdateOperationsInput | number
    comision?: comisionUncheckedUpdateOneWithoutOrden_trabajoNestedInput
    movimiento_herramienta?: movimiento_herramientaUncheckedUpdateManyWithoutOrden_trabajoNestedInput
  }

  export type orden_trabajoUncheckedUpdateManyWithoutAdministradorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    empleado_ci?: IntFieldUpdateOperationsInput | number
    servicio_id?: IntFieldUpdateOperationsInput | number
  }

  export type servicioCreateManyCategoriaInput = {
    id?: number
    descripcion: string
  }

  export type servicioUpdateWithoutCategoriaInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    detalle_proforma?: detalle_proformaUpdateManyWithoutServicioNestedInput
    orden_trabajo?: orden_trabajoUpdateManyWithoutServicioNestedInput
  }

  export type servicioUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    detalle_proforma?: detalle_proformaUncheckedUpdateManyWithoutServicioNestedInput
    orden_trabajo?: orden_trabajoUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type servicioUncheckedUpdateManyWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type facturaCreateManyClienteInput = {
    id?: bigint | number
    monto: Decimal | DecimalJsLike | number | string
    fecha?: Date | string
  }

  export type proformaCreateManyClienteInput = {
    id?: bigint | number
    fecha: Date | string
    estado?: $Enums.estado_proforma
    total?: Decimal | DecimalJsLike | number | string
    diagnostico_id?: bigint | number | null
  }

  export type facturaUpdateWithoutClienteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type facturaUncheckedUpdateWithoutClienteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type facturaUncheckedUpdateManyWithoutClienteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type proformaUpdateWithoutClienteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    detalle_proforma?: detalle_proformaUpdateManyWithoutProformaNestedInput
    diagnostico?: diagnosticoUpdateOneWithoutProformaNestedInput
    proforma_repuesto?: proforma_repuestoUpdateManyWithoutProformaNestedInput
  }

  export type proformaUncheckedUpdateWithoutClienteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    diagnostico_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    detalle_proforma?: detalle_proformaUncheckedUpdateManyWithoutProformaNestedInput
    proforma_repuesto?: proforma_repuestoUncheckedUpdateManyWithoutProformaNestedInput
  }

  export type proformaUncheckedUpdateManyWithoutClienteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: Enumestado_proformaFieldUpdateOperationsInput | $Enums.estado_proforma
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    diagnostico_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type detalle_diagnosticoCreateManyDiagnosticoInput = {
    id?: bigint | number
    descripcion: string
  }

  export type detalle_diagnosticoUpdateWithoutDiagnosticoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type detalle_diagnosticoUncheckedUpdateWithoutDiagnosticoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type detalle_diagnosticoUncheckedUpdateManyWithoutDiagnosticoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type diagnosticoCreateManyEmpleadoInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    placa_moto: string
  }

  export type horario_empleadoCreateManyEmpleadoInput = {
    horario_id: number
    fecha: Date | string
  }

  export type orden_trabajoCreateManyEmpleadoInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    administrador_id?: number | null
    servicio_id: number
  }

  export type diagnosticoUpdateWithoutEmpleadoInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    detalle_diagnostico?: detalle_diagnosticoUpdateManyWithoutDiagnosticoNestedInput
    moto?: motoUpdateOneRequiredWithoutDiagnosticoNestedInput
    proforma?: proformaUpdateOneWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateWithoutEmpleadoInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    placa_moto?: StringFieldUpdateOperationsInput | string
    detalle_diagnostico?: detalle_diagnosticoUncheckedUpdateManyWithoutDiagnosticoNestedInput
    proforma?: proformaUncheckedUpdateOneWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateManyWithoutEmpleadoInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    placa_moto?: StringFieldUpdateOperationsInput | string
  }

  export type horario_empleadoUpdateWithoutEmpleadoInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horario?: horarioUpdateOneRequiredWithoutHorario_empleadoNestedInput
  }

  export type horario_empleadoUncheckedUpdateWithoutEmpleadoInput = {
    horario_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type horario_empleadoUncheckedUpdateManyWithoutEmpleadoInput = {
    horario_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orden_trabajoUpdateWithoutEmpleadoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    comision?: comisionUpdateOneWithoutOrden_trabajoNestedInput
    movimiento_herramienta?: movimiento_herramientaUpdateManyWithoutOrden_trabajoNestedInput
    administrador?: administradorUpdateOneWithoutOrden_trabajoNestedInput
    servicio?: servicioUpdateOneRequiredWithoutOrden_trabajoNestedInput
  }

  export type orden_trabajoUncheckedUpdateWithoutEmpleadoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    administrador_id?: NullableIntFieldUpdateOperationsInput | number | null
    servicio_id?: IntFieldUpdateOperationsInput | number
    comision?: comisionUncheckedUpdateOneWithoutOrden_trabajoNestedInput
    movimiento_herramienta?: movimiento_herramientaUncheckedUpdateManyWithoutOrden_trabajoNestedInput
  }

  export type orden_trabajoUncheckedUpdateManyWithoutEmpleadoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    administrador_id?: NullableIntFieldUpdateOperationsInput | number | null
    servicio_id?: IntFieldUpdateOperationsInput | number
  }

  export type movimiento_herramientaCreateManyHerramientaInput = {
    orden_trabajo_id: bigint | number
    fecha: Date | string
    cantidad: number
  }

  export type movimiento_herramientaUpdateWithoutHerramientaInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    orden_trabajo?: orden_trabajoUpdateOneRequiredWithoutMovimiento_herramientaNestedInput
  }

  export type movimiento_herramientaUncheckedUpdateWithoutHerramientaInput = {
    orden_trabajo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type movimiento_herramientaUncheckedUpdateManyWithoutHerramientaInput = {
    orden_trabajo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type horario_empleadoCreateManyHorarioInput = {
    empleado_ci: number
    fecha: Date | string
  }

  export type horario_empleadoUpdateWithoutHorarioInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    empleado?: empleadoUpdateOneRequiredWithoutHorario_empleadoNestedInput
  }

  export type horario_empleadoUncheckedUpdateWithoutHorarioInput = {
    empleado_ci?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type horario_empleadoUncheckedUpdateManyWithoutHorarioInput = {
    empleado_ci?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type herramientaCreateManyMarca_herramientaInput = {
    id?: number
    nombre: string
    descripcion?: string | null
  }

  export type herramientaUpdateWithoutMarca_herramientaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimiento_herramienta?: movimiento_herramientaUpdateManyWithoutHerramientaNestedInput
  }

  export type herramientaUncheckedUpdateWithoutMarca_herramientaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimiento_herramienta?: movimiento_herramientaUncheckedUpdateManyWithoutHerramientaNestedInput
  }

  export type herramientaUncheckedUpdateManyWithoutMarca_herramientaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type motoCreateManyMarca_motoInput = {
    placa: string
    modelo: string
    year: number
    chasis?: string | null
  }

  export type motoUpdateWithoutMarca_motoInput = {
    placa?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostico?: diagnosticoUpdateManyWithoutMotoNestedInput
  }

  export type motoUncheckedUpdateWithoutMarca_motoInput = {
    placa?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostico?: diagnosticoUncheckedUpdateManyWithoutMotoNestedInput
  }

  export type motoUncheckedUpdateManyWithoutMarca_motoInput = {
    placa?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    chasis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type diagnosticoCreateManyMotoInput = {
    nro?: bigint | number
    fecha: Date | string
    hora: Date | string
    empleado_ci: number
  }

  export type diagnosticoUpdateWithoutMotoInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    detalle_diagnostico?: detalle_diagnosticoUpdateManyWithoutDiagnosticoNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutDiagnosticoNestedInput
    proforma?: proformaUpdateOneWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateWithoutMotoInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    empleado_ci?: IntFieldUpdateOperationsInput | number
    detalle_diagnostico?: detalle_diagnosticoUncheckedUpdateManyWithoutDiagnosticoNestedInput
    proforma?: proformaUncheckedUpdateOneWithoutDiagnosticoNestedInput
  }

  export type diagnosticoUncheckedUpdateManyWithoutMotoInput = {
    nro?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: DateTimeFieldUpdateOperationsInput | Date | string
    empleado_ci?: IntFieldUpdateOperationsInput | number
  }

  export type movimiento_herramientaCreateManyOrden_trabajoInput = {
    herramienta_id: number
    fecha: Date | string
    cantidad: number
  }

  export type movimiento_herramientaUpdateWithoutOrden_trabajoInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
    herramienta?: herramientaUpdateOneRequiredWithoutMovimiento_herramientaNestedInput
  }

  export type movimiento_herramientaUncheckedUpdateWithoutOrden_trabajoInput = {
    herramienta_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type movimiento_herramientaUncheckedUpdateManyWithoutOrden_trabajoInput = {
    herramienta_id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type detalle_proformaCreateManyProformaInput = {
    id?: bigint | number
    servicio_id?: number | null
    descripcion: string
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
  }

  export type proforma_repuestoCreateManyProformaInput = {
    id?: number
    nombre: string
  }

  export type detalle_proformaUpdateWithoutProformaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    servicio?: servicioUpdateOneWithoutDetalle_proformaNestedInput
  }

  export type detalle_proformaUncheckedUpdateWithoutProformaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    servicio_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_proformaUncheckedUpdateManyWithoutProformaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    servicio_id?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type proforma_repuestoUpdateWithoutProformaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type proforma_repuestoUncheckedUpdateWithoutProformaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type proforma_repuestoUncheckedUpdateManyWithoutProformaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type detalle_proformaCreateManyServicioInput = {
    id?: bigint | number
    proforma_id: bigint | number
    descripcion: string
    cantidad: Decimal | DecimalJsLike | number | string
    precio_unit: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string | null
  }

  export type orden_trabajoCreateManyServicioInput = {
    id?: bigint | number
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    estado?: $Enums.estado_orden
    empleado_ci: number
    administrador_id?: number | null
  }

  export type detalle_proformaUpdateWithoutServicioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    proforma?: proformaUpdateOneRequiredWithoutDetalle_proformaNestedInput
  }

  export type detalle_proformaUncheckedUpdateWithoutServicioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    proforma_id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type detalle_proformaUncheckedUpdateManyWithoutServicioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    proforma_id?: BigIntFieldUpdateOperationsInput | bigint | number
    descripcion?: StringFieldUpdateOperationsInput | string
    cantidad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_unit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type orden_trabajoUpdateWithoutServicioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    comision?: comisionUpdateOneWithoutOrden_trabajoNestedInput
    movimiento_herramienta?: movimiento_herramientaUpdateManyWithoutOrden_trabajoNestedInput
    administrador?: administradorUpdateOneWithoutOrden_trabajoNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutOrden_trabajoNestedInput
  }

  export type orden_trabajoUncheckedUpdateWithoutServicioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    empleado_ci?: IntFieldUpdateOperationsInput | number
    administrador_id?: NullableIntFieldUpdateOperationsInput | number | null
    comision?: comisionUncheckedUpdateOneWithoutOrden_trabajoNestedInput
    movimiento_herramienta?: movimiento_herramientaUncheckedUpdateManyWithoutOrden_trabajoNestedInput
  }

  export type orden_trabajoUncheckedUpdateManyWithoutServicioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: Enumestado_ordenFieldUpdateOperationsInput | $Enums.estado_orden
    empleado_ci?: IntFieldUpdateOperationsInput | number
    administrador_id?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}